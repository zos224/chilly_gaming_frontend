import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/@ckeditor/ckeditor5-build-classic/build/ckeditor.js
var require_ckeditor = __commonJS({
  "node_modules/@ckeditor/ckeditor5-build-classic/build/ckeditor.js"(exports, module) {
    !function(t) {
      const e = t.en = t.en || {};
      e.dictionary = Object.assign(e.dictionary || {}, { "%0 of %1": "%0 of %1", "Block quote": "Block quote", Bold: "Bold", "Bulleted List": "Bulleted List", Cancel: "Cancel", "Cannot upload file:": "Cannot upload file:", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Choose heading": "Choose heading", Column: "Column", "Could not insert image at the current position.": "Could not insert image at the current position.", "Could not obtain resized image URL.": "Could not obtain resized image URL.", "Decrease indent": "Decrease indent", "Delete column": "Delete column", "Delete row": "Delete row", Downloadable: "Downloadable", "Dropdown toolbar": "Dropdown toolbar", "Edit link": "Edit link", "Editor toolbar": "Editor toolbar", "Enter image caption": "Enter image caption", "Full size image": "Full size image", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", "Image toolbar": "Image toolbar", "image widget": "image widget", "Increase indent": "Increase indent", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert image or file": "Insert image or file", "Insert media": "Insert media", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Insert table", "Inserting image failed": "Inserting image failed", Italic: "Italic", "Left aligned image": "Left aligned image", Link: "Link", "Link URL": "Link URL", "Media URL": "Media URL", "media widget": "media widget", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", Next: "Next", "Numbered List": "Numbered List", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", Paragraph: "Paragraph", "Paste the media URL in the input.": "Paste the media URL in the input.", Previous: "Previous", Redo: "Redo", "Rich Text Editor": "Rich Text Editor", "Rich Text Editor, %0": "Rich Text Editor, %0", "Right aligned image": "Right aligned image", Row: "Row", Save: "Save", "Select column": "Select column", "Select row": "Select row", "Selecting resized image failed": "Selecting resized image failed", "Show more items": "Show more items", "Side image": "Side image", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", "Table toolbar": "Table toolbar", "Text alternative": "Text alternative", "The URL must not be empty.": "The URL must not be empty.", "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", Undo: "Undo", Unlink: "Unlink", "Upload failed": "Upload failed", "Upload in progress": "Upload in progress", "Widget toolbar": "Widget toolbar" });
    }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.ClassicEditor = e() : t.ClassicEditor = e();
    }(window, function() {
      return function(t) {
        var e = {};
        function n(i) {
          if (e[i])
            return e[i].exports;
          var o = e[i] = { i, l: false, exports: {} };
          return t[i].call(o.exports, o, o.exports, n), o.l = true, o.exports;
        }
        return n.m = t, n.c = e, n.d = function(t2, e2, i) {
          n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: i });
        }, n.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, n.t = function(t2, e2) {
          if (1 & e2 && (t2 = n(t2)), 8 & e2)
            return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var i = /* @__PURE__ */ Object.create(null);
          if (n.r(i), Object.defineProperty(i, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
            for (var o in t2)
              n.d(i, o, function(e3) {
                return t2[e3];
              }.bind(null, o));
          return i;
        }, n.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return n.d(e2, "a", e2), e2;
        }, n.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, n.p = "", n(n.s = 94);
      }([function(t, e, n) {
        "use strict";
        n.d(e, "b", function() {
          return i;
        }), n.d(e, "a", function() {
          return o;
        });
        class i extends Error {
          constructor(t2, e2, n2) {
            t2 = o(t2), n2 && (t2 += " " + JSON.stringify(n2)), super(t2), this.name = "CKEditorError", this.context = e2, this.data = n2;
          }
          is(t2) {
            return "CKEditorError" === t2;
          }
          static rethrowUnexpectedError(t2, e2) {
            if (t2.is && t2.is("CKEditorError"))
              throw t2;
            const n2 = new i(t2.message, e2);
            throw n2.stack = t2.stack, n2;
          }
        }
        function o(t2) {
          const e2 = t2.match(/^([^:]+):/);
          return e2 ? t2 + ` Read more: https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html#error-${e2[1]}
` : t2;
        }
      }, function(t, e, n) {
        "use strict";
        var i, o = function() {
          return void 0 === i && (i = Boolean(window && document && document.all && !window.atob)), i;
        }, r = function() {
          var t2 = {};
          return function(e2) {
            if (void 0 === t2[e2]) {
              var n2 = document.querySelector(e2);
              if (window.HTMLIFrameElement && n2 instanceof window.HTMLIFrameElement)
                try {
                  n2 = n2.contentDocument.head;
                } catch (t3) {
                  n2 = null;
                }
              t2[e2] = n2;
            }
            return t2[e2];
          };
        }(), s = [];
        function a(t2) {
          for (var e2 = -1, n2 = 0; n2 < s.length; n2++)
            if (s[n2].identifier === t2) {
              e2 = n2;
              break;
            }
          return e2;
        }
        function c(t2, e2) {
          for (var n2 = {}, i2 = [], o2 = 0; o2 < t2.length; o2++) {
            var r2 = t2[o2], c2 = e2.base ? r2[0] + e2.base : r2[0], l2 = n2[c2] || 0, d2 = "".concat(c2, " ").concat(l2);
            n2[c2] = l2 + 1;
            var u2 = a(d2), h2 = { css: r2[1], media: r2[2], sourceMap: r2[3] };
            -1 !== u2 ? (s[u2].references++, s[u2].updater(h2)) : s.push({ identifier: d2, updater: p(h2, e2), references: 1 }), i2.push(d2);
          }
          return i2;
        }
        function l(t2) {
          var e2 = document.createElement("style"), i2 = t2.attributes || {};
          if (void 0 === i2.nonce) {
            var o2 = n.nc;
            o2 && (i2.nonce = o2);
          }
          if (Object.keys(i2).forEach(function(t3) {
            e2.setAttribute(t3, i2[t3]);
          }), "function" == typeof t2.insert)
            t2.insert(e2);
          else {
            var s2 = r(t2.insert || "head");
            if (!s2)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            s2.appendChild(e2);
          }
          return e2;
        }
        var d, u = (d = [], function(t2, e2) {
          return d[t2] = e2, d.filter(Boolean).join("\n");
        });
        function h(t2, e2, n2, i2) {
          var o2 = n2 ? "" : i2.media ? "@media ".concat(i2.media, " {").concat(i2.css, "}") : i2.css;
          if (t2.styleSheet)
            t2.styleSheet.cssText = u(e2, o2);
          else {
            var r2 = document.createTextNode(o2), s2 = t2.childNodes;
            s2[e2] && t2.removeChild(s2[e2]), s2.length ? t2.insertBefore(r2, s2[e2]) : t2.appendChild(r2);
          }
        }
        function f(t2, e2, n2) {
          var i2 = n2.css, o2 = n2.media, r2 = n2.sourceMap;
          if (o2 ? t2.setAttribute("media", o2) : t2.removeAttribute("media"), r2 && btoa && (i2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), " */")), t2.styleSheet)
            t2.styleSheet.cssText = i2;
          else {
            for (; t2.firstChild; )
              t2.removeChild(t2.firstChild);
            t2.appendChild(document.createTextNode(i2));
          }
        }
        var m = null, g = 0;
        function p(t2, e2) {
          var n2, i2, o2;
          if (e2.singleton) {
            var r2 = g++;
            n2 = m || (m = l(e2)), i2 = h.bind(null, n2, r2, false), o2 = h.bind(null, n2, r2, true);
          } else
            n2 = l(e2), i2 = f.bind(null, n2, e2), o2 = function() {
              !function(t3) {
                if (null === t3.parentNode)
                  return false;
                t3.parentNode.removeChild(t3);
              }(n2);
            };
          return i2(t2), function(e3) {
            if (e3) {
              if (e3.css === t2.css && e3.media === t2.media && e3.sourceMap === t2.sourceMap)
                return;
              i2(t2 = e3);
            } else
              o2();
          };
        }
        t.exports = function(t2, e2) {
          (e2 = e2 || {}).singleton || "boolean" == typeof e2.singleton || (e2.singleton = o());
          var n2 = c(t2 = t2 || [], e2);
          return function(t3) {
            if (t3 = t3 || [], "[object Array]" === Object.prototype.toString.call(t3)) {
              for (var i2 = 0; i2 < n2.length; i2++) {
                var o2 = a(n2[i2]);
                s[o2].references--;
              }
              for (var r2 = c(t3, e2), l2 = 0; l2 < n2.length; l2++) {
                var d2 = a(n2[l2]);
                0 === s[d2].references && (s[d2].updater(), s.splice(d2, 1));
              }
              n2 = r2;
            }
          };
        };
      }, , function(t, e, n) {
        "use strict";
        var i = n(7), o = "object" == typeof self && self && self.Object === Object && self, r = i.a || o || Function("return this")();
        e.a = r;
      }, function(t, e, n) {
        "use strict";
        (function(t2) {
          var i = n(3), o = n(12), r = "object" == typeof exports && exports && !exports.nodeType && exports, s = r && "object" == typeof t2 && t2 && !t2.nodeType && t2, a = s && s.exports === r ? i.a.Buffer : void 0, c = (a ? a.isBuffer : void 0) || o.a;
          e.a = c;
        }).call(this, n(9)(t));
      }, function(t, e, n) {
        "use strict";
        (function(t2) {
          var i = n(7), o = "object" == typeof exports && exports && !exports.nodeType && exports, r = o && "object" == typeof t2 && t2 && !t2.nodeType && t2, s = r && r.exports === o && i.a.process, a = function() {
            try {
              var t3 = r && r.require && r.require("util").types;
              return t3 || s && s.binding && s.binding("util");
            } catch (t4) {
            }
          }();
          e.a = a;
        }).call(this, n(9)(t));
      }, function(t, e, n) {
        "use strict";
        (function(t2) {
          var e2 = n(0);
          const i = "object" == typeof window ? window : t2;
          if (i.CKEDITOR_VERSION)
            throw new e2.b("ckeditor-duplicated-modules: Some CKEditor 5 modules are duplicated.", null);
          i.CKEDITOR_VERSION = "19.0.0";
        }).call(this, n(10));
      }, function(t, e, n) {
        "use strict";
        (function(t2) {
          var n2 = "object" == typeof t2 && t2 && t2.Object === Object && t2;
          e.a = n2;
        }).call(this, n(10));
      }, function(t, e, n) {
        "use strict";
        (function(t2) {
          var i = n(3), o = "object" == typeof exports && exports && !exports.nodeType && exports, r = o && "object" == typeof t2 && t2 && !t2.nodeType && t2, s = r && r.exports === o ? i.a.Buffer : void 0, a = s ? s.allocUnsafe : void 0;
          e.a = function(t3, e2) {
            if (e2)
              return t3.slice();
            var n2 = t3.length, i2 = a ? a(n2) : new t3.constructor(n2);
            return t3.copy(i2), i2;
          };
        }).call(this, n(9)(t));
      }, function(t, e) {
        t.exports = function(t2) {
          if (!t2.webpackPolyfill) {
            var e2 = Object.create(t2);
            e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
              return e2.l;
            } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
              return e2.i;
            } }), Object.defineProperty(e2, "exports", { enumerable: true }), e2.webpackPolyfill = 1;
          }
          return e2;
        };
      }, function(t, e) {
        var n;
        n = function() {
          return this;
        }();
        try {
          n = n || new Function("return this")();
        } catch (t2) {
          "object" == typeof window && (n = window);
        }
        t.exports = n;
      }, function(t, e, n) {
        var i = n(1), o = n(69);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e, n) {
        "use strict";
        e.a = function() {
          return false;
        };
      }, function(t, e, n) {
        var i = n(1), o = n(14);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}";
      }, function(t, e, n) {
        var i = n(1), o = n(16);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border:#1f89e5;--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}";
      }, function(t, e, n) {
        var i = n(1), o = n(18);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}";
      }, function(t, e, n) {
        var i = n(1), o = n(20);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}";
      }, function(t, e, n) {
        var i = n(1), o = n(22);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}";
      }, function(t, e, n) {
        var i = n(1), o = n(24);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}:root{--ck-dropdown-arrow-size:calc(0.5*var(--ck-icon-size))}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}";
      }, function(t, e, n) {
        var i = n(1), o = n(26);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}";
      }, function(t, e, n) {
        var i = n(1), o = n(28);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}';
      }, function(t, e, n) {
        var i = n(1), o = n(30);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(-1*var(--ck-spacing-small));margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(-1*var(--ck-spacing-small));margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}";
      }, function(t, e, n) {
        var i = n(1), o = n(32);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(0.2*var(--ck-line-height-base)*var(--ck-font-size-base)) calc(0.4*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(1.2*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}";
      }, function(t, e, n) {
        var i = n(1), o = n(34);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2*var(--ck-switch-button-toggle-spacing))}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(2*var(--ck-spacing-large))}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(2*var(--ck-spacing-large))}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(0.5*var(--ck-border-radius))}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(-1*var(--ck-switch-button-translation)))}";
      }, function(t, e, n) {
        var i = n(1), o = n(36);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}";
      }, function(t, e, n) {
        var i = n(1), o = n(38);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}";
      }, function(t, e, n) {
        var i = n(1), o = n(40);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;margin-top:0;margin-bottom:0;background:var(--ck-color-toolbar-border)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}";
      }, function(t, e, n) {
        var i = n(1), o = n(42);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}";
      }, function(t, e, n) {
        var i = n(1), o = n(44);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}";
      }, function(t, e, n) {
        var i = n(1), o = n(46);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}";
      }, function(t, e, n) {
        var i = n(1), o = n(48);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}";
      }, function(t, e, n) {
        var i = n(1), o = n(50);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view>.ck.ck-label{width:100%;text-overflow:ellipsis;overflow:hidden}";
      }, function(t, e, n) {
        var i = n(1), o = n(52);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}";
      }, function(t, e, n) {
        var i = n(1), o = n(54);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}.ck.ck-text-alternative-form{padding:var(--ck-spacing-standard)}.ck.ck-text-alternative-form:focus{outline:none}[dir=ltr] .ck.ck-text-alternative-form>:not(:first-child),[dir=rtl] .ck.ck-text-alternative-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-text-alternative-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-text-alternative-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-text-alternative-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-text-alternative-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-text-alternative-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-text-alternative-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}";
      }, function(t, e, n) {
        var i = n(1), o = n(56);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}';
      }, function(t, e, n) {
        var i = n(1), o = n(58);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}";
      }, function(t, e, n) {
        var i = n(1), o = n(60);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}";
      }, function(t, e, n) {
        var i = n(1), o = n(62);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image>img{display:block;margin:0 auto;max-width:100%;min-width:50px}";
      }, function(t, e, n) {
        var i = n(1), o = n(64);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}";
      }, function(t, e, n) {
        var i = n(1), o = n(66);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}';
      }, function(t, e, n) {
        var i = n(1), o = n(68);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}';
      }, function(t, e) {
        t.exports = ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}";
      }, function(t, e, n) {
        var i = n(1), o = n(71);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:#333;background-color:#f7f7f7;padding:.6em;font-size:.75em;outline-offset:-1px}";
      }, function(t, e, n) {
        var i = n(1), o = n(73);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ":root{--ck-image-style-spacing:1.5em}.ck-content .image-style-align-center,.ck-content .image-style-align-left,.ck-content .image-style-align-right,.ck-content .image-style-side{max-width:50%}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}";
      }, function(t, e, n) {
        var i = n(1), o = n(75);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form{padding:var(--ck-spacing-standard)}.ck.ck-link-form:focus{outline:none}[dir=ltr] .ck.ck-link-form>:not(:first-child),[dir=rtl] .ck.ck-link-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}";
      }, function(t, e, n) {
        var i = n(1), o = n(77);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions{padding:var(--ck-spacing-standard)}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}.ck.ck-link-actions:focus{outline:none}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):last-of-type{border-right:1px solid var(--ck-color-base-border)}}";
      }, function(t, e, n) {
        var i = n(1), o = n(79);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(3*var(--ck-spacing-standard));background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}';
      }, function(t, e, n) {
        var i = n(1), o = n(81);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}.ck.ck-media-form{padding:var(--ck-spacing-standard)}.ck.ck-media-form:focus{outline:none}[dir=ltr] .ck.ck-media-form>:not(:first-child),[dir=rtl] .ck.ck-media-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-media-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-media-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-media-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-media-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-media-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-media-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-media-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-media-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-media-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}";
      }, function(t, e, n) {
        var i = n(1), o = n(83);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-content .media{clear:both;margin:1em 0;display:block;min-width:15em}";
      }, function(t, e, n) {
        var i = n(1), o = n(85);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}";
      }, function(t, e, n) {
        var i = n(1), o = n(87);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}";
      }, function(t, e, n) {
        var i = n(1), o = n(89);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}";
      }, function(t, e, n) {
        var i = n(1), o = n(91);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}';
      }, function(t, e, n) {
        var i = n(1), o = n(93);
        "string" == typeof (o = o.__esModule ? o.default : o) && (o = [[t.i, o, ""]]);
        var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        i(o, r);
        t.exports = o.locals || {};
      }, function(t, e) {
        t.exports = ".ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}";
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "default", function() {
          return Yp;
        });
        var i = n(3), o = i.a.Symbol, r = Object.prototype, s = r.hasOwnProperty, a = r.toString, c = o ? o.toStringTag : void 0;
        var l = function(t2) {
          var e2 = s.call(t2, c), n2 = t2[c];
          try {
            t2[c] = void 0;
            var i2 = true;
          } catch (t3) {
          }
          var o2 = a.call(t2);
          return i2 && (e2 ? t2[c] = n2 : delete t2[c]), o2;
        }, d = Object.prototype.toString;
        var u = function(t2) {
          return d.call(t2);
        }, h = o ? o.toStringTag : void 0;
        var f = function(t2) {
          return null == t2 ? void 0 === t2 ? "[object Undefined]" : "[object Null]" : h && h in Object(t2) ? l(t2) : u(t2);
        };
        var m = function(t2, e2) {
          return function(n2) {
            return t2(e2(n2));
          };
        }, g = m(Object.getPrototypeOf, Object);
        var p = function(t2) {
          return null != t2 && "object" == typeof t2;
        }, b = Function.prototype, w = Object.prototype, k = b.toString, _ = w.hasOwnProperty, v = k.call(Object);
        var y = function(t2) {
          if (!p(t2) || "[object Object]" != f(t2))
            return false;
          var e2 = g(t2);
          if (null === e2)
            return true;
          var n2 = _.call(e2, "constructor") && e2.constructor;
          return "function" == typeof n2 && n2 instanceof n2 && k.call(n2) == v;
        };
        var x = function() {
          this.__data__ = [], this.size = 0;
        };
        var A = function(t2, e2) {
          return t2 === e2 || t2 != t2 && e2 != e2;
        };
        var T = function(t2, e2) {
          for (var n2 = t2.length; n2--; )
            if (A(t2[n2][0], e2))
              return n2;
          return -1;
        }, C = Array.prototype.splice;
        var P = function(t2) {
          var e2 = this.__data__, n2 = T(e2, t2);
          return !(n2 < 0) && (n2 == e2.length - 1 ? e2.pop() : C.call(e2, n2, 1), --this.size, true);
        };
        var S = function(t2) {
          var e2 = this.__data__, n2 = T(e2, t2);
          return n2 < 0 ? void 0 : e2[n2][1];
        };
        var M = function(t2) {
          return T(this.__data__, t2) > -1;
        };
        var E = function(t2, e2) {
          var n2 = this.__data__, i2 = T(n2, t2);
          return i2 < 0 ? (++this.size, n2.push([t2, e2])) : n2[i2][1] = e2, this;
        };
        function I(t2) {
          var e2 = -1, n2 = null == t2 ? 0 : t2.length;
          for (this.clear(); ++e2 < n2; ) {
            var i2 = t2[e2];
            this.set(i2[0], i2[1]);
          }
        }
        I.prototype.clear = x, I.prototype.delete = P, I.prototype.get = S, I.prototype.has = M, I.prototype.set = E;
        var N = I;
        var O = function() {
          this.__data__ = new N(), this.size = 0;
        };
        var R = function(t2) {
          var e2 = this.__data__, n2 = e2.delete(t2);
          return this.size = e2.size, n2;
        };
        var D = function(t2) {
          return this.__data__.get(t2);
        };
        var L = function(t2) {
          return this.__data__.has(t2);
        };
        var j = function(t2) {
          var e2 = typeof t2;
          return null != t2 && ("object" == e2 || "function" == e2);
        };
        var V, z = function(t2) {
          if (!j(t2))
            return false;
          var e2 = f(t2);
          return "[object Function]" == e2 || "[object GeneratorFunction]" == e2 || "[object AsyncFunction]" == e2 || "[object Proxy]" == e2;
        }, B = i.a["__core-js_shared__"], F = (V = /[^.]+$/.exec(B && B.keys && B.keys.IE_PROTO || "")) ? "Symbol(src)_1." + V : "";
        var U = function(t2) {
          return !!F && F in t2;
        }, H = Function.prototype.toString;
        var q = function(t2) {
          if (null != t2) {
            try {
              return H.call(t2);
            } catch (t3) {
            }
            try {
              return t2 + "";
            } catch (t3) {
            }
          }
          return "";
        }, W = /^\[object .+?Constructor\]$/, Y = Function.prototype, G = Object.prototype, $ = Y.toString, Q = G.hasOwnProperty, K = RegExp("^" + $.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var J = function(t2) {
          return !(!j(t2) || U(t2)) && (z(t2) ? K : W).test(q(t2));
        };
        var Z = function(t2, e2) {
          return null == t2 ? void 0 : t2[e2];
        };
        var X = function(t2, e2) {
          var n2 = Z(t2, e2);
          return J(n2) ? n2 : void 0;
        }, tt = X(i.a, "Map"), et = X(Object, "create");
        var nt = function() {
          this.__data__ = et ? et(null) : {}, this.size = 0;
        };
        var it = function(t2) {
          var e2 = this.has(t2) && delete this.__data__[t2];
          return this.size -= e2 ? 1 : 0, e2;
        }, ot = Object.prototype.hasOwnProperty;
        var rt = function(t2) {
          var e2 = this.__data__;
          if (et) {
            var n2 = e2[t2];
            return "__lodash_hash_undefined__" === n2 ? void 0 : n2;
          }
          return ot.call(e2, t2) ? e2[t2] : void 0;
        }, st = Object.prototype.hasOwnProperty;
        var at = function(t2) {
          var e2 = this.__data__;
          return et ? void 0 !== e2[t2] : st.call(e2, t2);
        };
        var ct = function(t2, e2) {
          var n2 = this.__data__;
          return this.size += this.has(t2) ? 0 : 1, n2[t2] = et && void 0 === e2 ? "__lodash_hash_undefined__" : e2, this;
        };
        function lt(t2) {
          var e2 = -1, n2 = null == t2 ? 0 : t2.length;
          for (this.clear(); ++e2 < n2; ) {
            var i2 = t2[e2];
            this.set(i2[0], i2[1]);
          }
        }
        lt.prototype.clear = nt, lt.prototype.delete = it, lt.prototype.get = rt, lt.prototype.has = at, lt.prototype.set = ct;
        var dt = lt;
        var ut = function() {
          this.size = 0, this.__data__ = { hash: new dt(), map: new (tt || N)(), string: new dt() };
        };
        var ht = function(t2) {
          var e2 = typeof t2;
          return "string" == e2 || "number" == e2 || "symbol" == e2 || "boolean" == e2 ? "__proto__" !== t2 : null === t2;
        };
        var ft = function(t2, e2) {
          var n2 = t2.__data__;
          return ht(e2) ? n2["string" == typeof e2 ? "string" : "hash"] : n2.map;
        };
        var mt = function(t2) {
          var e2 = ft(this, t2).delete(t2);
          return this.size -= e2 ? 1 : 0, e2;
        };
        var gt = function(t2) {
          return ft(this, t2).get(t2);
        };
        var pt = function(t2) {
          return ft(this, t2).has(t2);
        };
        var bt = function(t2, e2) {
          var n2 = ft(this, t2), i2 = n2.size;
          return n2.set(t2, e2), this.size += n2.size == i2 ? 0 : 1, this;
        };
        function wt(t2) {
          var e2 = -1, n2 = null == t2 ? 0 : t2.length;
          for (this.clear(); ++e2 < n2; ) {
            var i2 = t2[e2];
            this.set(i2[0], i2[1]);
          }
        }
        wt.prototype.clear = ut, wt.prototype.delete = mt, wt.prototype.get = gt, wt.prototype.has = pt, wt.prototype.set = bt;
        var kt = wt;
        var _t = function(t2, e2) {
          var n2 = this.__data__;
          if (n2 instanceof N) {
            var i2 = n2.__data__;
            if (!tt || i2.length < 199)
              return i2.push([t2, e2]), this.size = ++n2.size, this;
            n2 = this.__data__ = new kt(i2);
          }
          return n2.set(t2, e2), this.size = n2.size, this;
        };
        function vt(t2) {
          var e2 = this.__data__ = new N(t2);
          this.size = e2.size;
        }
        vt.prototype.clear = O, vt.prototype.delete = R, vt.prototype.get = D, vt.prototype.has = L, vt.prototype.set = _t;
        var yt = vt;
        var xt = function(t2, e2) {
          for (var n2 = -1, i2 = null == t2 ? 0 : t2.length; ++n2 < i2 && false !== e2(t2[n2], n2, t2); )
            ;
          return t2;
        }, At = function() {
          try {
            var t2 = X(Object, "defineProperty");
            return t2({}, "", {}), t2;
          } catch (t3) {
          }
        }();
        var Tt = function(t2, e2, n2) {
          "__proto__" == e2 && At ? At(t2, e2, { configurable: true, enumerable: true, value: n2, writable: true }) : t2[e2] = n2;
        }, Ct = Object.prototype.hasOwnProperty;
        var Pt = function(t2, e2, n2) {
          var i2 = t2[e2];
          Ct.call(t2, e2) && A(i2, n2) && (void 0 !== n2 || e2 in t2) || Tt(t2, e2, n2);
        };
        var St = function(t2, e2, n2, i2) {
          var o2 = !n2;
          n2 || (n2 = {});
          for (var r2 = -1, s2 = e2.length; ++r2 < s2; ) {
            var a2 = e2[r2], c2 = i2 ? i2(n2[a2], t2[a2], a2, n2, t2) : void 0;
            void 0 === c2 && (c2 = t2[a2]), o2 ? Tt(n2, a2, c2) : Pt(n2, a2, c2);
          }
          return n2;
        };
        var Mt = function(t2, e2) {
          for (var n2 = -1, i2 = Array(t2); ++n2 < t2; )
            i2[n2] = e2(n2);
          return i2;
        };
        var Et = function(t2) {
          return p(t2) && "[object Arguments]" == f(t2);
        }, It = Object.prototype, Nt = It.hasOwnProperty, Ot = It.propertyIsEnumerable, Rt = Et(function() {
          return arguments;
        }()) ? Et : function(t2) {
          return p(t2) && Nt.call(t2, "callee") && !Ot.call(t2, "callee");
        }, Dt = Array.isArray, Lt = n(4), jt = /^(?:0|[1-9]\d*)$/;
        var Vt = function(t2, e2) {
          var n2 = typeof t2;
          return !!(e2 = null == e2 ? 9007199254740991 : e2) && ("number" == n2 || "symbol" != n2 && jt.test(t2)) && t2 > -1 && t2 % 1 == 0 && t2 < e2;
        };
        var zt = function(t2) {
          return "number" == typeof t2 && t2 > -1 && t2 % 1 == 0 && t2 <= 9007199254740991;
        }, Bt = {};
        Bt["[object Float32Array]"] = Bt["[object Float64Array]"] = Bt["[object Int8Array]"] = Bt["[object Int16Array]"] = Bt["[object Int32Array]"] = Bt["[object Uint8Array]"] = Bt["[object Uint8ClampedArray]"] = Bt["[object Uint16Array]"] = Bt["[object Uint32Array]"] = true, Bt["[object Arguments]"] = Bt["[object Array]"] = Bt["[object ArrayBuffer]"] = Bt["[object Boolean]"] = Bt["[object DataView]"] = Bt["[object Date]"] = Bt["[object Error]"] = Bt["[object Function]"] = Bt["[object Map]"] = Bt["[object Number]"] = Bt["[object Object]"] = Bt["[object RegExp]"] = Bt["[object Set]"] = Bt["[object String]"] = Bt["[object WeakMap]"] = false;
        var Ft = function(t2) {
          return p(t2) && zt(t2.length) && !!Bt[f(t2)];
        };
        var Ut = function(t2) {
          return function(e2) {
            return t2(e2);
          };
        }, Ht = n(5), qt = Ht.a && Ht.a.isTypedArray, Wt = qt ? Ut(qt) : Ft, Yt = Object.prototype.hasOwnProperty;
        var Gt = function(t2, e2) {
          var n2 = Dt(t2), i2 = !n2 && Rt(t2), o2 = !n2 && !i2 && Object(Lt.a)(t2), r2 = !n2 && !i2 && !o2 && Wt(t2), s2 = n2 || i2 || o2 || r2, a2 = s2 ? Mt(t2.length, String) : [], c2 = a2.length;
          for (var l2 in t2)
            !e2 && !Yt.call(t2, l2) || s2 && ("length" == l2 || o2 && ("offset" == l2 || "parent" == l2) || r2 && ("buffer" == l2 || "byteLength" == l2 || "byteOffset" == l2) || Vt(l2, c2)) || a2.push(l2);
          return a2;
        }, $t = Object.prototype;
        var Qt = function(t2) {
          var e2 = t2 && t2.constructor;
          return t2 === ("function" == typeof e2 && e2.prototype || $t);
        }, Kt = m(Object.keys, Object), Jt = Object.prototype.hasOwnProperty;
        var Zt = function(t2) {
          if (!Qt(t2))
            return Kt(t2);
          var e2 = [];
          for (var n2 in Object(t2))
            Jt.call(t2, n2) && "constructor" != n2 && e2.push(n2);
          return e2;
        };
        var Xt = function(t2) {
          return null != t2 && zt(t2.length) && !z(t2);
        };
        var te = function(t2) {
          return Xt(t2) ? Gt(t2) : Zt(t2);
        };
        var ee = function(t2, e2) {
          return t2 && St(e2, te(e2), t2);
        };
        var ne = function(t2) {
          var e2 = [];
          if (null != t2)
            for (var n2 in Object(t2))
              e2.push(n2);
          return e2;
        }, ie = Object.prototype.hasOwnProperty;
        var oe = function(t2) {
          if (!j(t2))
            return ne(t2);
          var e2 = Qt(t2), n2 = [];
          for (var i2 in t2)
            ("constructor" != i2 || !e2 && ie.call(t2, i2)) && n2.push(i2);
          return n2;
        };
        var re = function(t2) {
          return Xt(t2) ? Gt(t2, true) : oe(t2);
        };
        var se = function(t2, e2) {
          return t2 && St(e2, re(e2), t2);
        }, ae = n(8);
        var ce = function(t2, e2) {
          var n2 = -1, i2 = t2.length;
          for (e2 || (e2 = Array(i2)); ++n2 < i2; )
            e2[n2] = t2[n2];
          return e2;
        };
        var le = function(t2, e2) {
          for (var n2 = -1, i2 = null == t2 ? 0 : t2.length, o2 = 0, r2 = []; ++n2 < i2; ) {
            var s2 = t2[n2];
            e2(s2, n2, t2) && (r2[o2++] = s2);
          }
          return r2;
        };
        var de = function() {
          return [];
        }, ue = Object.prototype.propertyIsEnumerable, he = Object.getOwnPropertySymbols, fe = he ? function(t2) {
          return null == t2 ? [] : (t2 = Object(t2), le(he(t2), function(e2) {
            return ue.call(t2, e2);
          }));
        } : de;
        var me = function(t2, e2) {
          return St(t2, fe(t2), e2);
        };
        var ge = function(t2, e2) {
          for (var n2 = -1, i2 = e2.length, o2 = t2.length; ++n2 < i2; )
            t2[o2 + n2] = e2[n2];
          return t2;
        }, pe = Object.getOwnPropertySymbols ? function(t2) {
          for (var e2 = []; t2; )
            ge(e2, fe(t2)), t2 = g(t2);
          return e2;
        } : de;
        var be = function(t2, e2) {
          return St(t2, pe(t2), e2);
        };
        var we = function(t2, e2, n2) {
          var i2 = e2(t2);
          return Dt(t2) ? i2 : ge(i2, n2(t2));
        };
        var ke = function(t2) {
          return we(t2, te, fe);
        };
        var _e = function(t2) {
          return we(t2, re, pe);
        }, ve = X(i.a, "DataView"), ye = X(i.a, "Promise"), xe = X(i.a, "Set"), Ae = X(i.a, "WeakMap"), Te = q(ve), Ce = q(tt), Pe = q(ye), Se = q(xe), Me = q(Ae), Ee = f;
        (ve && "[object DataView]" != Ee(new ve(new ArrayBuffer(1))) || tt && "[object Map]" != Ee(new tt()) || ye && "[object Promise]" != Ee(ye.resolve()) || xe && "[object Set]" != Ee(new xe()) || Ae && "[object WeakMap]" != Ee(new Ae())) && (Ee = function(t2) {
          var e2 = f(t2), n2 = "[object Object]" == e2 ? t2.constructor : void 0, i2 = n2 ? q(n2) : "";
          if (i2)
            switch (i2) {
              case Te:
                return "[object DataView]";
              case Ce:
                return "[object Map]";
              case Pe:
                return "[object Promise]";
              case Se:
                return "[object Set]";
              case Me:
                return "[object WeakMap]";
            }
          return e2;
        });
        var Ie = Ee, Ne = Object.prototype.hasOwnProperty;
        var Oe = function(t2) {
          var e2 = t2.length, n2 = new t2.constructor(e2);
          return e2 && "string" == typeof t2[0] && Ne.call(t2, "index") && (n2.index = t2.index, n2.input = t2.input), n2;
        }, Re = i.a.Uint8Array;
        var De = function(t2) {
          var e2 = new t2.constructor(t2.byteLength);
          return new Re(e2).set(new Re(t2)), e2;
        };
        var Le = function(t2, e2) {
          var n2 = e2 ? De(t2.buffer) : t2.buffer;
          return new t2.constructor(n2, t2.byteOffset, t2.byteLength);
        }, je = /\w*$/;
        var Ve = function(t2) {
          var e2 = new t2.constructor(t2.source, je.exec(t2));
          return e2.lastIndex = t2.lastIndex, e2;
        }, ze = o ? o.prototype : void 0, Be = ze ? ze.valueOf : void 0;
        var Fe = function(t2) {
          return Be ? Object(Be.call(t2)) : {};
        };
        var Ue = function(t2, e2) {
          var n2 = e2 ? De(t2.buffer) : t2.buffer;
          return new t2.constructor(n2, t2.byteOffset, t2.length);
        };
        var He = function(t2, e2, n2) {
          var i2 = t2.constructor;
          switch (e2) {
            case "[object ArrayBuffer]":
              return De(t2);
            case "[object Boolean]":
            case "[object Date]":
              return new i2(+t2);
            case "[object DataView]":
              return Le(t2, n2);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
              return Ue(t2, n2);
            case "[object Map]":
              return new i2();
            case "[object Number]":
            case "[object String]":
              return new i2(t2);
            case "[object RegExp]":
              return Ve(t2);
            case "[object Set]":
              return new i2();
            case "[object Symbol]":
              return Fe(t2);
          }
        }, qe = Object.create, We = function() {
          function t2() {
          }
          return function(e2) {
            if (!j(e2))
              return {};
            if (qe)
              return qe(e2);
            t2.prototype = e2;
            var n2 = new t2();
            return t2.prototype = void 0, n2;
          };
        }();
        var Ye = function(t2) {
          return "function" != typeof t2.constructor || Qt(t2) ? {} : We(g(t2));
        };
        var Ge = function(t2) {
          return p(t2) && "[object Map]" == Ie(t2);
        }, $e = Ht.a && Ht.a.isMap, Qe = $e ? Ut($e) : Ge;
        var Ke = function(t2) {
          return p(t2) && "[object Set]" == Ie(t2);
        }, Je = Ht.a && Ht.a.isSet, Ze = Je ? Ut(Je) : Ke, Xe = {};
        Xe["[object Arguments]"] = Xe["[object Array]"] = Xe["[object ArrayBuffer]"] = Xe["[object DataView]"] = Xe["[object Boolean]"] = Xe["[object Date]"] = Xe["[object Float32Array]"] = Xe["[object Float64Array]"] = Xe["[object Int8Array]"] = Xe["[object Int16Array]"] = Xe["[object Int32Array]"] = Xe["[object Map]"] = Xe["[object Number]"] = Xe["[object Object]"] = Xe["[object RegExp]"] = Xe["[object Set]"] = Xe["[object String]"] = Xe["[object Symbol]"] = Xe["[object Uint8Array]"] = Xe["[object Uint8ClampedArray]"] = Xe["[object Uint16Array]"] = Xe["[object Uint32Array]"] = true, Xe["[object Error]"] = Xe["[object Function]"] = Xe["[object WeakMap]"] = false;
        var tn = function t2(e2, n2, i2, o2, r2, s2) {
          var a2, c2 = 1 & n2, l2 = 2 & n2, d2 = 4 & n2;
          if (i2 && (a2 = r2 ? i2(e2, o2, r2, s2) : i2(e2)), void 0 !== a2)
            return a2;
          if (!j(e2))
            return e2;
          var u2 = Dt(e2);
          if (u2) {
            if (a2 = Oe(e2), !c2)
              return ce(e2, a2);
          } else {
            var h2 = Ie(e2), f2 = "[object Function]" == h2 || "[object GeneratorFunction]" == h2;
            if (Object(Lt.a)(e2))
              return Object(ae.a)(e2, c2);
            if ("[object Object]" == h2 || "[object Arguments]" == h2 || f2 && !r2) {
              if (a2 = l2 || f2 ? {} : Ye(e2), !c2)
                return l2 ? be(e2, se(a2, e2)) : me(e2, ee(a2, e2));
            } else {
              if (!Xe[h2])
                return r2 ? e2 : {};
              a2 = He(e2, h2, c2);
            }
          }
          s2 || (s2 = new yt());
          var m2 = s2.get(e2);
          if (m2)
            return m2;
          s2.set(e2, a2), Ze(e2) ? e2.forEach(function(o3) {
            a2.add(t2(o3, n2, i2, o3, e2, s2));
          }) : Qe(e2) && e2.forEach(function(o3, r3) {
            a2.set(r3, t2(o3, n2, i2, r3, e2, s2));
          });
          var g2 = d2 ? l2 ? _e : ke : l2 ? keysIn : te, p2 = u2 ? void 0 : g2(e2);
          return xt(p2 || e2, function(o3, r3) {
            p2 && (o3 = e2[r3 = o3]), Pt(a2, r3, t2(o3, n2, i2, r3, e2, s2));
          }), a2;
        };
        var en = function(t2, e2) {
          return tn(t2, 5, e2 = "function" == typeof e2 ? e2 : void 0);
        };
        var nn = function(t2) {
          return p(t2) && 1 === t2.nodeType && !y(t2);
        };
        class on {
          constructor(t2, e2) {
            this._config = {}, e2 && this.define(rn(e2)), t2 && this._setObjectToTarget(this._config, t2);
          }
          set(t2, e2) {
            this._setToTarget(this._config, t2, e2);
          }
          define(t2, e2) {
            this._setToTarget(this._config, t2, e2, true);
          }
          get(t2) {
            return this._getFromSource(this._config, t2);
          }
          *names() {
            for (const t2 of Object.keys(this._config))
              yield t2;
          }
          _setToTarget(t2, e2, n2, i2 = false) {
            if (y(e2))
              return void this._setObjectToTarget(t2, e2, i2);
            const o2 = e2.split(".");
            e2 = o2.pop();
            for (const e3 of o2)
              y(t2[e3]) || (t2[e3] = {}), t2 = t2[e3];
            if (y(n2))
              return y(t2[e2]) || (t2[e2] = {}), t2 = t2[e2], void this._setObjectToTarget(t2, n2, i2);
            i2 && void 0 !== t2[e2] || (t2[e2] = n2);
          }
          _getFromSource(t2, e2) {
            const n2 = e2.split(".");
            e2 = n2.pop();
            for (const e3 of n2) {
              if (!y(t2[e3])) {
                t2 = null;
                break;
              }
              t2 = t2[e3];
            }
            return t2 ? rn(t2[e2]) : void 0;
          }
          _setObjectToTarget(t2, e2, n2) {
            Object.keys(e2).forEach((i2) => {
              this._setToTarget(t2, i2, e2[i2], n2);
            });
          }
        }
        function rn(t2) {
          return en(t2, sn);
        }
        function sn(t2) {
          return nn(t2) ? t2 : void 0;
        }
        var an = function() {
          return function t2() {
            t2.called = true;
          };
        };
        class cn {
          constructor(t2, e2) {
            this.source = t2, this.name = e2, this.path = [], this.stop = an(), this.off = an();
          }
        }
        const ln = new Array(256).fill().map((t2, e2) => ("0" + e2.toString(16)).slice(-2));
        function dn() {
          const t2 = 4294967296 * Math.random() >>> 0, e2 = 4294967296 * Math.random() >>> 0, n2 = 4294967296 * Math.random() >>> 0, i2 = 4294967296 * Math.random() >>> 0;
          return "e" + ln[t2 >> 0 & 255] + ln[t2 >> 8 & 255] + ln[t2 >> 16 & 255] + ln[t2 >> 24 & 255] + ln[e2 >> 0 & 255] + ln[e2 >> 8 & 255] + ln[e2 >> 16 & 255] + ln[e2 >> 24 & 255] + ln[n2 >> 0 & 255] + ln[n2 >> 8 & 255] + ln[n2 >> 16 & 255] + ln[n2 >> 24 & 255] + ln[i2 >> 0 & 255] + ln[i2 >> 8 & 255] + ln[i2 >> 16 & 255] + ln[i2 >> 24 & 255];
        }
        var un = { get(t2) {
          return "number" != typeof t2 ? this[t2] || this.normal : t2;
        }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 }, hn = (n(6), n(0));
        const fn = Symbol("listeningTo"), mn = Symbol("emitterId");
        var gn = { on(t2, e2, n2 = {}) {
          this.listenTo(this, t2, e2, n2);
        }, once(t2, e2, n2) {
          let i2 = false;
          this.listenTo(this, t2, function(t3, ...n3) {
            i2 || (i2 = true, t3.off(), e2.call(this, t3, ...n3));
          }, n2);
        }, off(t2, e2) {
          this.stopListening(this, t2, e2);
        }, listenTo(t2, e2, n2, i2 = {}) {
          let o2, r2;
          this[fn] || (this[fn] = {});
          const s2 = this[fn];
          bn(t2) || pn(t2);
          const a2 = bn(t2);
          (o2 = s2[a2]) || (o2 = s2[a2] = { emitter: t2, callbacks: {} }), (r2 = o2.callbacks[e2]) || (r2 = o2.callbacks[e2] = []), r2.push(n2), function(t3, e3) {
            const n3 = wn(t3);
            if (n3[e3])
              return;
            let i3 = e3, o3 = null;
            const r3 = [];
            for (; "" !== i3 && !n3[i3]; )
              n3[i3] = { callbacks: [], childEvents: [] }, r3.push(n3[i3]), o3 && n3[i3].childEvents.push(o3), o3 = i3, i3 = i3.substr(0, i3.lastIndexOf(":"));
            if ("" !== i3) {
              for (const t4 of r3)
                t4.callbacks = n3[i3].callbacks.slice();
              n3[i3].childEvents.push(o3);
            }
          }(t2, e2);
          const c2 = kn(t2, e2), l2 = un.get(i2.priority), d2 = { callback: n2, priority: l2 };
          for (const t3 of c2) {
            let e3 = false;
            for (let n3 = 0; n3 < t3.length; n3++)
              if (t3[n3].priority < l2) {
                t3.splice(n3, 0, d2), e3 = true;
                break;
              }
            e3 || t3.push(d2);
          }
        }, stopListening(t2, e2, n2) {
          const i2 = this[fn];
          let o2 = t2 && bn(t2);
          const r2 = i2 && o2 && i2[o2], s2 = r2 && e2 && r2.callbacks[e2];
          if (!(!i2 || t2 && !r2 || e2 && !s2))
            if (n2)
              vn(t2, e2, n2);
            else if (s2) {
              for (; n2 = s2.pop(); )
                vn(t2, e2, n2);
              delete r2.callbacks[e2];
            } else if (r2) {
              for (e2 in r2.callbacks)
                this.stopListening(t2, e2);
              delete i2[o2];
            } else {
              for (o2 in i2)
                this.stopListening(i2[o2].emitter);
              delete this[fn];
            }
        }, fire(t2, ...e2) {
          try {
            const n2 = t2 instanceof cn ? t2 : new cn(this, t2), i2 = n2.name;
            let o2 = function t3(e3, n3) {
              let i3;
              if (!e3._events || !(i3 = e3._events[n3]) || !i3.callbacks.length)
                return n3.indexOf(":") > -1 ? t3(e3, n3.substr(0, n3.lastIndexOf(":"))) : null;
              return i3.callbacks;
            }(this, i2);
            if (n2.path.push(this), o2) {
              const t3 = [n2, ...e2];
              o2 = Array.from(o2);
              for (let e3 = 0; e3 < o2.length && (o2[e3].callback.apply(this, t3), n2.off.called && (delete n2.off.called, vn(this, i2, o2[e3].callback)), !n2.stop.called); e3++)
                ;
            }
            if (this._delegations) {
              const t3 = this._delegations.get(i2), o3 = this._delegations.get("*");
              t3 && _n(t3, n2, e2), o3 && _n(o3, n2, e2);
            }
            return n2.return;
          } catch (t3) {
            hn.b.rethrowUnexpectedError(t3, this);
          }
        }, delegate(...t2) {
          return { to: (e2, n2) => {
            this._delegations || (this._delegations = /* @__PURE__ */ new Map()), t2.forEach((t3) => {
              const i2 = this._delegations.get(t3);
              i2 ? i2.set(e2, n2) : this._delegations.set(t3, /* @__PURE__ */ new Map([[e2, n2]]));
            });
          } };
        }, stopDelegating(t2, e2) {
          if (this._delegations)
            if (t2)
              if (e2) {
                const n2 = this._delegations.get(t2);
                n2 && n2.delete(e2);
              } else
                this._delegations.delete(t2);
            else
              this._delegations.clear();
        } };
        function pn(t2, e2) {
          t2[mn] || (t2[mn] = e2 || dn());
        }
        function bn(t2) {
          return t2[mn];
        }
        function wn(t2) {
          return t2._events || Object.defineProperty(t2, "_events", { value: {} }), t2._events;
        }
        function kn(t2, e2) {
          const n2 = wn(t2)[e2];
          if (!n2)
            return [];
          let i2 = [n2.callbacks];
          for (let e3 = 0; e3 < n2.childEvents.length; e3++) {
            const o2 = kn(t2, n2.childEvents[e3]);
            i2 = i2.concat(o2);
          }
          return i2;
        }
        function _n(t2, e2, n2) {
          for (let [i2, o2] of t2) {
            o2 ? "function" == typeof o2 && (o2 = o2(e2.name)) : o2 = e2.name;
            const t3 = new cn(e2.source, o2);
            t3.path = [...e2.path], i2.fire(t3, ...n2);
          }
        }
        function vn(t2, e2, n2) {
          const i2 = kn(t2, e2);
          for (const t3 of i2)
            for (let e3 = 0; e3 < t3.length; e3++)
              t3[e3].callback == n2 && (t3.splice(e3, 1), e3--);
        }
        function yn(t2) {
          return !(!t2 || !t2[Symbol.iterator]);
        }
        function xn(t2, ...e2) {
          e2.forEach((e3) => {
            Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3)).forEach((n2) => {
              if (n2 in t2.prototype)
                return;
              const i2 = Object.getOwnPropertyDescriptor(e3, n2);
              i2.enumerable = false, Object.defineProperty(t2.prototype, n2, i2);
            });
          });
        }
        class An {
          constructor(t2 = {}, e2 = {}) {
            const n2 = yn(t2);
            if (n2 || (e2 = t2), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = e2.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n2)
              for (const e3 of t2)
                this._items.push(e3), this._itemMap.set(this._getItemIdBeforeAdding(e3), e3);
          }
          get length() {
            return this._items.length;
          }
          get first() {
            return this._items[0] || null;
          }
          get last() {
            return this._items[this.length - 1] || null;
          }
          add(t2, e2) {
            const n2 = this._getItemIdBeforeAdding(t2);
            if (void 0 === e2)
              e2 = this._items.length;
            else if (e2 > this._items.length || e2 < 0)
              throw new hn.b("collection-add-item-invalid-index", this);
            return this._items.splice(e2, 0, t2), this._itemMap.set(n2, t2), this.fire("add", t2, e2), this;
          }
          get(t2) {
            let e2;
            if ("string" == typeof t2)
              e2 = this._itemMap.get(t2);
            else {
              if ("number" != typeof t2)
                throw new hn.b("collection-get-invalid-arg: Index or id must be given.", this);
              e2 = this._items[t2];
            }
            return e2 || null;
          }
          has(t2) {
            if ("string" == typeof t2)
              return this._itemMap.has(t2);
            {
              const e2 = t2[this._idProperty];
              return this._itemMap.has(e2);
            }
          }
          getIndex(t2) {
            let e2;
            return e2 = "string" == typeof t2 ? this._itemMap.get(t2) : t2, this._items.indexOf(e2);
          }
          remove(t2) {
            let e2, n2, i2, o2 = false;
            const r2 = this._idProperty;
            if ("string" == typeof t2 ? (n2 = t2, i2 = this._itemMap.get(n2), o2 = !i2, i2 && (e2 = this._items.indexOf(i2))) : "number" == typeof t2 ? (e2 = t2, i2 = this._items[e2], o2 = !i2, i2 && (n2 = i2[r2])) : (i2 = t2, n2 = i2[r2], e2 = this._items.indexOf(i2), o2 = -1 == e2 || !this._itemMap.get(n2)), o2)
              throw new hn.b("collection-remove-404: Item not found.", this);
            this._items.splice(e2, 1), this._itemMap.delete(n2);
            const s2 = this._bindToInternalToExternalMap.get(i2);
            return this._bindToInternalToExternalMap.delete(i2), this._bindToExternalToInternalMap.delete(s2), this.fire("remove", i2, e2), i2;
          }
          map(t2, e2) {
            return this._items.map(t2, e2);
          }
          find(t2, e2) {
            return this._items.find(t2, e2);
          }
          filter(t2, e2) {
            return this._items.filter(t2, e2);
          }
          clear() {
            for (this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null); this.length; )
              this.remove(0);
          }
          bindTo(t2) {
            if (this._bindToCollection)
              throw new hn.b("collection-bind-to-rebind: The collection cannot be bound more than once.", this);
            return this._bindToCollection = t2, { as: (t3) => {
              this._setUpBindToBinding((e2) => new t3(e2));
            }, using: (t3) => {
              "function" == typeof t3 ? this._setUpBindToBinding((e2) => t3(e2)) : this._setUpBindToBinding((e2) => e2[t3]);
            } };
          }
          _setUpBindToBinding(t2) {
            const e2 = this._bindToCollection, n2 = (n3, i2, o2) => {
              const r2 = e2._bindToCollection == this, s2 = e2._bindToInternalToExternalMap.get(i2);
              if (r2 && s2)
                this._bindToExternalToInternalMap.set(i2, s2), this._bindToInternalToExternalMap.set(s2, i2);
              else {
                const n4 = t2(i2);
                if (!n4)
                  return void this._skippedIndexesFromExternal.push(o2);
                let r3 = o2;
                for (const t3 of this._skippedIndexesFromExternal)
                  o2 > t3 && r3--;
                for (const t3 of e2._skippedIndexesFromExternal)
                  r3 >= t3 && r3++;
                this._bindToExternalToInternalMap.set(i2, n4), this._bindToInternalToExternalMap.set(n4, i2), this.add(n4, r3);
                for (let t3 = 0; t3 < e2._skippedIndexesFromExternal.length; t3++)
                  r3 <= e2._skippedIndexesFromExternal[t3] && e2._skippedIndexesFromExternal[t3]++;
              }
            };
            for (const t3 of e2)
              n2(0, t3, e2.getIndex(t3));
            this.listenTo(e2, "add", n2), this.listenTo(e2, "remove", (t3, e3, n3) => {
              const i2 = this._bindToExternalToInternalMap.get(e3);
              i2 && this.remove(i2), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t4, e4) => (n3 < e4 && t4.push(e4 - 1), n3 > e4 && t4.push(e4), t4), []);
            });
          }
          _getItemIdBeforeAdding(t2) {
            const e2 = this._idProperty;
            let n2;
            if (e2 in t2) {
              if (n2 = t2[e2], "string" != typeof n2)
                throw new hn.b("collection-add-invalid-id", this);
              if (this.get(n2))
                throw new hn.b("collection-add-item-already-exists", this);
            } else
              t2[e2] = n2 = dn();
            return n2;
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
        }
        xn(An, gn);
        class Tn {
          constructor(t2, e2 = [], n2 = []) {
            this._context = t2, this._plugins = /* @__PURE__ */ new Map(), this._availablePlugins = /* @__PURE__ */ new Map();
            for (const t3 of e2)
              t3.pluginName && this._availablePlugins.set(t3.pluginName, t3);
            this._contextPlugins = /* @__PURE__ */ new Map();
            for (const [t3, e3] of n2)
              this._contextPlugins.set(t3, e3), this._contextPlugins.set(e3, t3), t3.pluginName && this._availablePlugins.set(t3.pluginName, t3);
          }
          *[Symbol.iterator]() {
            for (const t2 of this._plugins)
              "function" == typeof t2[0] && (yield t2);
          }
          get(t2) {
            const e2 = this._plugins.get(t2);
            if (!e2) {
              const e3 = "plugincollection-plugin-not-loaded: The requested plugin is not loaded.";
              let n2 = t2;
              throw "function" == typeof t2 && (n2 = t2.pluginName || t2.name), new hn.b(e3, this._context, { plugin: n2 });
            }
            return e2;
          }
          has(t2) {
            return this._plugins.has(t2);
          }
          init(t2, e2 = []) {
            const n2 = this, i2 = this._context, o2 = /* @__PURE__ */ new Set(), r2 = [], s2 = h2(t2), a2 = h2(e2), c2 = function(t3) {
              const e3 = [];
              for (const n3 of t3)
                u2(n3) || e3.push(n3);
              return e3.length ? e3 : null;
            }(t2);
            if (c2) {
              const t3 = "plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.";
              return console.error(Object(hn.a)(t3), { plugins: c2 }), Promise.reject(new hn.b(t3, i2, { plugins: c2 }));
            }
            return Promise.all(s2.map(l2)).then(() => d2(r2, "init")).then(() => d2(r2, "afterInit")).then(() => r2);
            function l2(t3) {
              if (!a2.includes(t3) && !n2._plugins.has(t3) && !o2.has(t3))
                return function(t4) {
                  return new Promise((s3) => {
                    o2.add(t4), t4.requires && t4.requires.forEach((n3) => {
                      const o3 = u2(n3);
                      if (t4.isContextPlugin && !o3.isContextPlugin)
                        throw new hn.b("plugincollection-context-required: Context plugin can not require plugin which is not a context plugin", null, { plugin: o3.name, requiredBy: t4.name });
                      if (e2.includes(o3))
                        throw new hn.b("plugincollection-required: Cannot load a plugin because one of its dependencies is listed inthe `removePlugins` option.", i2, { plugin: o3.name, requiredBy: t4.name });
                      l2(o3);
                    });
                    const a3 = n2._contextPlugins.get(t4) || new t4(i2);
                    n2._add(t4, a3), r2.push(a3), s3();
                  });
                }(t3).catch((e3) => {
                  throw console.error(Object(hn.a)("plugincollection-load: It was not possible to load the plugin."), { plugin: t3 }), e3;
                });
            }
            function d2(t3, e3) {
              return t3.reduce((t4, i3) => i3[e3] ? n2._contextPlugins.has(i3) ? t4 : t4.then(i3[e3].bind(i3)) : t4, Promise.resolve());
            }
            function u2(t3) {
              return "function" == typeof t3 ? t3 : n2._availablePlugins.get(t3);
            }
            function h2(t3) {
              return t3.map((t4) => u2(t4)).filter((t4) => !!t4);
            }
          }
          destroy() {
            const t2 = [];
            for (const [, e2] of this)
              "function" != typeof e2.destroy || this._contextPlugins.has(e2) || t2.push(e2.destroy());
            return Promise.all(t2);
          }
          _add(t2, e2) {
            this._plugins.set(t2, e2);
            const n2 = t2.pluginName;
            if (n2) {
              if (this._plugins.has(n2))
                throw new hn.b("plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.", null, { pluginName: n2, plugin1: this._plugins.get(n2).constructor, plugin2: t2 });
              this._plugins.set(n2, e2);
            }
          }
        }
        function Cn(t2, e2, n2 = 1) {
          if ("number" != typeof n2)
            throw new hn.b("translation-service-quantity-not-a-number: Expecting `quantity` to be a number.", null, { quantity: n2 });
          const i2 = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
          1 === i2 && (t2 = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
          const o2 = e2.id || e2.string;
          if (0 === i2 || !function(t3, e3) {
            return !!window.CKEDITOR_TRANSLATIONS[t3] && !!window.CKEDITOR_TRANSLATIONS[t3].dictionary[e3];
          }(t2, o2))
            return 1 !== n2 ? e2.plural : e2.string;
          const r2 = window.CKEDITOR_TRANSLATIONS[t2].dictionary, s2 = window.CKEDITOR_TRANSLATIONS[t2].getPluralForm || ((t3) => 1 === t3 ? 0 : 1);
          if ("string" == typeof r2[o2])
            return r2[o2];
          const a2 = Number(s2(n2));
          return r2[o2][a2];
        }
        xn(Tn, gn), window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
        const Pn = ["ar", "fa", "he", "ku", "ug"];
        class Sn {
          constructor(t2 = {}) {
            this.uiLanguage = t2.uiLanguage || "en", this.contentLanguage = t2.contentLanguage || this.uiLanguage, this.uiLanguageDirection = Mn(this.uiLanguage), this.contentLanguageDirection = Mn(this.contentLanguage), this.t = (t3, e2) => this._t(t3, e2);
          }
          get language() {
            return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
          }
          _t(t2, e2 = []) {
            Array.isArray(e2) || (e2 = [e2]), "string" == typeof t2 && (t2 = { string: t2 });
            const n2 = !!t2.plural ? e2[0] : 1;
            return function(t3, e3) {
              return t3.replace(/%(\d+)/g, (t4, n3) => n3 < e3.length ? e3[n3] : t4);
            }(Cn(this.uiLanguage, t2, n2), e2);
          }
        }
        function Mn(t2) {
          return Pn.includes(t2) ? "rtl" : "ltr";
        }
        class En {
          constructor(t2) {
            this.config = new on(t2, this.constructor.defaultConfig);
            const e2 = this.constructor.builtinPlugins;
            this.config.define("plugins", e2), this.plugins = new Tn(this, e2);
            const n2 = this.config.get("language") || {};
            this.locale = new Sn({ uiLanguage: "string" == typeof n2 ? n2 : n2.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new An(), this._contextOwner = null;
          }
          initPlugins() {
            const t2 = this.config.get("plugins") || [];
            for (const e2 of t2) {
              if ("function" != typeof e2)
                throw new hn.b("context-initplugins-constructor-only: Only a constructor function is allowed as a context plugin.", null, { Plugin: e2 });
              if (true !== e2.isContextPlugin)
                throw new hn.b("context-initplugins-invalid-plugin: Only a plugin marked as a context plugin is allowed to be used with a context.", null, { Plugin: e2 });
            }
            return this.plugins.init(t2);
          }
          destroy() {
            return Promise.all(Array.from(this.editors, (t2) => t2.destroy())).then(() => this.plugins.destroy());
          }
          _addEditor(t2, e2) {
            if (this._contextOwner)
              throw new hn.b("context-addEditor-private-context: Cannot add multiple editors to the context which is created by the editor.");
            this.editors.add(t2), e2 && (this._contextOwner = t2);
          }
          _removeEditor(t2) {
            return this.editors.has(t2) && this.editors.remove(t2), this._contextOwner === t2 ? this.destroy() : Promise.resolve();
          }
          _getEditorConfig() {
            const t2 = {};
            for (const e2 of this.config.names())
              ["plugins", "removePlugins", "extraPlugins"].includes(e2) || (t2[e2] = this.config.get(e2));
            return t2;
          }
          static create(t2) {
            return new Promise((e2) => {
              const n2 = new this(t2);
              e2(n2.initPlugins().then(() => n2));
            });
          }
        }
        function In(t2, e2) {
          const n2 = Math.min(t2.length, e2.length);
          for (let i2 = 0; i2 < n2; i2++)
            if (t2[i2] != e2[i2])
              return i2;
          return t2.length == e2.length ? "same" : t2.length < e2.length ? "prefix" : "extension";
        }
        var Nn = function(t2) {
          return tn(t2, 4);
        };
        class On {
          constructor(t2) {
            this.document = t2, this.parent = null;
          }
          get index() {
            let t2;
            if (!this.parent)
              return null;
            if (-1 == (t2 = this.parent.getChildIndex(this)))
              throw new hn.b("view-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t2;
          }
          get nextSibling() {
            const t2 = this.index;
            return null !== t2 && this.parent.getChild(t2 + 1) || null;
          }
          get previousSibling() {
            const t2 = this.index;
            return null !== t2 && this.parent.getChild(t2 - 1) || null;
          }
          get root() {
            let t2 = this;
            for (; t2.parent; )
              t2 = t2.parent;
            return t2;
          }
          isAttached() {
            return this.root.is("rootElement");
          }
          getPath() {
            const t2 = [];
            let e2 = this;
            for (; e2.parent; )
              t2.unshift(e2.index), e2 = e2.parent;
            return t2;
          }
          getAncestors(t2 = { includeSelf: false, parentFirst: false }) {
            const e2 = [];
            let n2 = t2.includeSelf ? this : this.parent;
            for (; n2; )
              e2[t2.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
            return e2;
          }
          getCommonAncestor(t2, e2 = {}) {
            const n2 = this.getAncestors(e2), i2 = t2.getAncestors(e2);
            let o2 = 0;
            for (; n2[o2] == i2[o2] && n2[o2]; )
              o2++;
            return 0 === o2 ? null : n2[o2 - 1];
          }
          isBefore(t2) {
            if (this == t2)
              return false;
            if (this.root !== t2.root)
              return false;
            const e2 = this.getPath(), n2 = t2.getPath(), i2 = In(e2, n2);
            switch (i2) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e2[i2] < n2[i2];
            }
          }
          isAfter(t2) {
            return this != t2 && (this.root === t2.root && !this.isBefore(t2));
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _fireChange(t2, e2) {
            this.fire("change:" + t2, e2), this.parent && this.parent._fireChange(t2, e2);
          }
          toJSON() {
            const t2 = Nn(this);
            return delete t2.parent, t2;
          }
          is(t2) {
            return "node" === t2 || "view:node" === t2;
          }
        }
        xn(On, gn);
        class Rn extends On {
          constructor(t2, e2) {
            super(t2), this._textData = e2;
          }
          is(t2) {
            return "text" === t2 || "view:text" === t2 || "node" === t2 || "view:node" === t2;
          }
          get data() {
            return this._textData;
          }
          get _data() {
            return this.data;
          }
          set _data(t2) {
            this._fireChange("text", this), this._textData = t2;
          }
          isSimilar(t2) {
            return t2 instanceof Rn && (this === t2 || this.data === t2.data);
          }
          _clone() {
            return new Rn(this.document, this.data);
          }
        }
        class Dn {
          constructor(t2, e2, n2) {
            if (this.textNode = t2, e2 < 0 || e2 > t2.data.length)
              throw new hn.b("view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this);
            if (n2 < 0 || e2 + n2 > t2.data.length)
              throw new hn.b("view-textproxy-wrong-length: Given length value is incorrect.", this);
            this.data = t2.data.substring(e2, e2 + n2), this.offsetInText = e2;
          }
          get offsetSize() {
            return this.data.length;
          }
          get isPartial() {
            return this.data.length !== this.textNode.data.length;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          get document() {
            return this.textNode.document;
          }
          is(t2) {
            return "textProxy" === t2 || "view:textProxy" === t2;
          }
          getAncestors(t2 = { includeSelf: false, parentFirst: false }) {
            const e2 = [];
            let n2 = t2.includeSelf ? this.textNode : this.parent;
            for (; null !== n2; )
              e2[t2.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
            return e2;
          }
        }
        function Ln(t2) {
          return yn(t2) ? new Map(t2) : function(t3) {
            const e2 = /* @__PURE__ */ new Map();
            for (const n2 in t3)
              e2.set(n2, t3[n2]);
            return e2;
          }(t2);
        }
        class jn {
          constructor(...t2) {
            this._patterns = [], this.add(...t2);
          }
          add(...t2) {
            for (let e2 of t2)
              ("string" == typeof e2 || e2 instanceof RegExp) && (e2 = { name: e2 }), e2.classes && ("string" == typeof e2.classes || e2.classes instanceof RegExp) && (e2.classes = [e2.classes]), this._patterns.push(e2);
          }
          match(...t2) {
            for (const e2 of t2)
              for (const t3 of this._patterns) {
                const n2 = Vn(e2, t3);
                if (n2)
                  return { element: e2, pattern: t3, match: n2 };
              }
            return null;
          }
          matchAll(...t2) {
            const e2 = [];
            for (const n2 of t2)
              for (const t3 of this._patterns) {
                const i2 = Vn(n2, t3);
                i2 && e2.push({ element: n2, pattern: t3, match: i2 });
              }
            return e2.length > 0 ? e2 : null;
          }
          getElementName() {
            if (1 !== this._patterns.length)
              return null;
            const t2 = this._patterns[0], e2 = t2.name;
            return "function" == typeof t2 || !e2 || e2 instanceof RegExp ? null : e2;
          }
        }
        function Vn(t2, e2) {
          if ("function" == typeof e2)
            return e2(t2);
          const n2 = {};
          return e2.name && (n2.name = function(t3, e3) {
            if (t3 instanceof RegExp)
              return t3.test(e3);
            return t3 === e3;
          }(e2.name, t2.name), !n2.name) || e2.attributes && (n2.attributes = function(t3, e3) {
            const n3 = [];
            for (const i2 in t3) {
              const o2 = t3[i2];
              if (!e3.hasAttribute(i2))
                return null;
              {
                const t4 = e3.getAttribute(i2);
                if (true === o2)
                  n3.push(i2);
                else if (o2 instanceof RegExp) {
                  if (!o2.test(t4))
                    return null;
                  n3.push(i2);
                } else {
                  if (t4 !== o2)
                    return null;
                  n3.push(i2);
                }
              }
            }
            return n3;
          }(e2.attributes, t2), !n2.attributes) ? null : !(e2.classes && (n2.classes = function(t3, e3) {
            const n3 = [];
            for (const i2 of t3)
              if (i2 instanceof RegExp) {
                const t4 = e3.getClassNames();
                for (const e4 of t4)
                  i2.test(e4) && n3.push(e4);
                if (0 === n3.length)
                  return null;
              } else {
                if (!e3.hasClass(i2))
                  return null;
                n3.push(i2);
              }
            return n3;
          }(e2.classes, t2), !n2.classes)) && (!(e2.styles && (n2.styles = function(t3, e3) {
            const n3 = [];
            for (const i2 in t3) {
              const o2 = t3[i2];
              if (!e3.hasStyle(i2))
                return null;
              {
                const t4 = e3.getStyle(i2);
                if (o2 instanceof RegExp) {
                  if (!o2.test(t4))
                    return null;
                  n3.push(i2);
                } else {
                  if (t4 !== o2)
                    return null;
                  n3.push(i2);
                }
              }
            }
            return n3;
          }(e2.styles, t2), !n2.styles)) && n2);
        }
        var zn = function(t2) {
          return "symbol" == typeof t2 || p(t2) && "[object Symbol]" == f(t2);
        }, Bn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Fn = /^\w*$/;
        var Un = function(t2, e2) {
          if (Dt(t2))
            return false;
          var n2 = typeof t2;
          return !("number" != n2 && "symbol" != n2 && "boolean" != n2 && null != t2 && !zn(t2)) || (Fn.test(t2) || !Bn.test(t2) || null != e2 && t2 in Object(e2));
        };
        function Hn(t2, e2) {
          if ("function" != typeof t2 || null != e2 && "function" != typeof e2)
            throw new TypeError("Expected a function");
          var n2 = function() {
            var i2 = arguments, o2 = e2 ? e2.apply(this, i2) : i2[0], r2 = n2.cache;
            if (r2.has(o2))
              return r2.get(o2);
            var s2 = t2.apply(this, i2);
            return n2.cache = r2.set(o2, s2) || r2, s2;
          };
          return n2.cache = new (Hn.Cache || kt)(), n2;
        }
        Hn.Cache = kt;
        var qn = Hn;
        var Wn = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Yn = /\\(\\)?/g, Gn = function(t2) {
          var e2 = qn(t2, function(t3) {
            return 500 === n2.size && n2.clear(), t3;
          }), n2 = e2.cache;
          return e2;
        }(function(t2) {
          var e2 = [];
          return 46 === t2.charCodeAt(0) && e2.push(""), t2.replace(Wn, function(t3, n2, i2, o2) {
            e2.push(i2 ? o2.replace(Yn, "$1") : n2 || t3);
          }), e2;
        });
        var $n = function(t2, e2) {
          for (var n2 = -1, i2 = null == t2 ? 0 : t2.length, o2 = Array(i2); ++n2 < i2; )
            o2[n2] = e2(t2[n2], n2, t2);
          return o2;
        }, Qn = o ? o.prototype : void 0, Kn = Qn ? Qn.toString : void 0;
        var Jn = function t2(e2) {
          if ("string" == typeof e2)
            return e2;
          if (Dt(e2))
            return $n(e2, t2) + "";
          if (zn(e2))
            return Kn ? Kn.call(e2) : "";
          var n2 = e2 + "";
          return "0" == n2 && 1 / e2 == -1 / 0 ? "-0" : n2;
        };
        var Zn = function(t2) {
          return null == t2 ? "" : Jn(t2);
        };
        var Xn = function(t2, e2) {
          return Dt(t2) ? t2 : Un(t2, e2) ? [t2] : Gn(Zn(t2));
        };
        var ti = function(t2) {
          var e2 = null == t2 ? 0 : t2.length;
          return e2 ? t2[e2 - 1] : void 0;
        };
        var ei = function(t2) {
          if ("string" == typeof t2 || zn(t2))
            return t2;
          var e2 = t2 + "";
          return "0" == e2 && 1 / t2 == -1 / 0 ? "-0" : e2;
        };
        var ni = function(t2, e2) {
          for (var n2 = 0, i2 = (e2 = Xn(e2, t2)).length; null != t2 && n2 < i2; )
            t2 = t2[ei(e2[n2++])];
          return n2 && n2 == i2 ? t2 : void 0;
        };
        var ii = function(t2, e2, n2) {
          var i2 = -1, o2 = t2.length;
          e2 < 0 && (e2 = -e2 > o2 ? 0 : o2 + e2), (n2 = n2 > o2 ? o2 : n2) < 0 && (n2 += o2), o2 = e2 > n2 ? 0 : n2 - e2 >>> 0, e2 >>>= 0;
          for (var r2 = Array(o2); ++i2 < o2; )
            r2[i2] = t2[i2 + e2];
          return r2;
        };
        var oi = function(t2, e2) {
          return e2.length < 2 ? t2 : ni(t2, ii(e2, 0, -1));
        };
        var ri = function(t2, e2) {
          return e2 = Xn(e2, t2), null == (t2 = oi(t2, e2)) || delete t2[ei(ti(e2))];
        };
        var si = function(t2, e2) {
          return null == t2 || ri(t2, e2);
        };
        var ai = function(t2, e2, n2) {
          var i2 = null == t2 ? void 0 : ni(t2, e2);
          return void 0 === i2 ? n2 : i2;
        };
        var ci = function(t2, e2, n2) {
          (void 0 !== n2 && !A(t2[e2], n2) || void 0 === n2 && !(e2 in t2)) && Tt(t2, e2, n2);
        };
        var li = function(t2) {
          return function(e2, n2, i2) {
            for (var o2 = -1, r2 = Object(e2), s2 = i2(e2), a2 = s2.length; a2--; ) {
              var c2 = s2[t2 ? a2 : ++o2];
              if (false === n2(r2[c2], c2, r2))
                break;
            }
            return e2;
          };
        }();
        var di = function(t2) {
          return p(t2) && Xt(t2);
        };
        var ui = function(t2, e2) {
          if (("constructor" !== e2 || "function" != typeof t2[e2]) && "__proto__" != e2)
            return t2[e2];
        };
        var hi = function(t2) {
          return St(t2, re(t2));
        };
        var fi = function(t2, e2, n2, i2, o2, r2, s2) {
          var a2 = ui(t2, n2), c2 = ui(e2, n2), l2 = s2.get(c2);
          if (l2)
            ci(t2, n2, l2);
          else {
            var d2 = r2 ? r2(a2, c2, n2 + "", t2, e2, s2) : void 0, u2 = void 0 === d2;
            if (u2) {
              var h2 = Dt(c2), f2 = !h2 && Object(Lt.a)(c2), m2 = !h2 && !f2 && Wt(c2);
              d2 = c2, h2 || f2 || m2 ? Dt(a2) ? d2 = a2 : di(a2) ? d2 = ce(a2) : f2 ? (u2 = false, d2 = Object(ae.a)(c2, true)) : m2 ? (u2 = false, d2 = Ue(c2, true)) : d2 = [] : y(c2) || Rt(c2) ? (d2 = a2, Rt(a2) ? d2 = hi(a2) : j(a2) && !z(a2) || (d2 = Ye(c2))) : u2 = false;
            }
            u2 && (s2.set(c2, d2), o2(d2, c2, i2, r2, s2), s2.delete(c2)), ci(t2, n2, d2);
          }
        };
        var mi = function t2(e2, n2, i2, o2, r2) {
          e2 !== n2 && li(n2, function(s2, a2) {
            if (r2 || (r2 = new yt()), j(s2))
              fi(e2, n2, a2, i2, t2, o2, r2);
            else {
              var c2 = o2 ? o2(ui(e2, a2), s2, a2 + "", e2, n2, r2) : void 0;
              void 0 === c2 && (c2 = s2), ci(e2, a2, c2);
            }
          }, re);
        };
        var gi = function(t2) {
          return t2;
        };
        var pi = function(t2, e2, n2) {
          switch (n2.length) {
            case 0:
              return t2.call(e2);
            case 1:
              return t2.call(e2, n2[0]);
            case 2:
              return t2.call(e2, n2[0], n2[1]);
            case 3:
              return t2.call(e2, n2[0], n2[1], n2[2]);
          }
          return t2.apply(e2, n2);
        }, bi = Math.max;
        var wi = function(t2, e2, n2) {
          return e2 = bi(void 0 === e2 ? t2.length - 1 : e2, 0), function() {
            for (var i2 = arguments, o2 = -1, r2 = bi(i2.length - e2, 0), s2 = Array(r2); ++o2 < r2; )
              s2[o2] = i2[e2 + o2];
            o2 = -1;
            for (var a2 = Array(e2 + 1); ++o2 < e2; )
              a2[o2] = i2[o2];
            return a2[e2] = n2(s2), pi(t2, this, a2);
          };
        };
        var ki = function(t2) {
          return function() {
            return t2;
          };
        }, _i = At ? function(t2, e2) {
          return At(t2, "toString", { configurable: true, enumerable: false, value: ki(e2), writable: true });
        } : gi, vi = Date.now;
        var yi = function(t2) {
          var e2 = 0, n2 = 0;
          return function() {
            var i2 = vi(), o2 = 16 - (i2 - n2);
            if (n2 = i2, o2 > 0) {
              if (++e2 >= 800)
                return arguments[0];
            } else
              e2 = 0;
            return t2.apply(void 0, arguments);
          };
        }(_i);
        var xi = function(t2, e2) {
          return yi(wi(t2, e2, gi), t2 + "");
        };
        var Ai = function(t2, e2, n2) {
          if (!j(n2))
            return false;
          var i2 = typeof e2;
          return !!("number" == i2 ? Xt(n2) && Vt(e2, n2.length) : "string" == i2 && e2 in n2) && A(n2[e2], t2);
        };
        var Ti = function(t2) {
          return xi(function(e2, n2) {
            var i2 = -1, o2 = n2.length, r2 = o2 > 1 ? n2[o2 - 1] : void 0, s2 = o2 > 2 ? n2[2] : void 0;
            for (r2 = t2.length > 3 && "function" == typeof r2 ? (o2--, r2) : void 0, s2 && Ai(n2[0], n2[1], s2) && (r2 = o2 < 3 ? void 0 : r2, o2 = 1), e2 = Object(e2); ++i2 < o2; ) {
              var a2 = n2[i2];
              a2 && t2(e2, a2, i2, r2);
            }
            return e2;
          });
        }, Ci = Ti(function(t2, e2, n2) {
          mi(t2, e2, n2);
        });
        var Pi = function(t2, e2, n2, i2) {
          if (!j(t2))
            return t2;
          for (var o2 = -1, r2 = (e2 = Xn(e2, t2)).length, s2 = r2 - 1, a2 = t2; null != a2 && ++o2 < r2; ) {
            var c2 = ei(e2[o2]), l2 = n2;
            if (o2 != s2) {
              var d2 = a2[c2];
              void 0 === (l2 = i2 ? i2(d2, c2, a2) : void 0) && (l2 = j(d2) ? d2 : Vt(e2[o2 + 1]) ? [] : {});
            }
            Pt(a2, c2, l2), a2 = a2[c2];
          }
          return t2;
        };
        var Si = function(t2, e2, n2) {
          return null == t2 ? t2 : Pi(t2, e2, n2);
        };
        class Mi {
          constructor(t2) {
            this._styles = {}, this._styleProcessor = t2;
          }
          get isEmpty() {
            const t2 = Object.entries(this._styles);
            return !Array.from(t2).length;
          }
          get size() {
            return this.isEmpty ? 0 : this.getStyleNames().length;
          }
          setTo(t2) {
            this.clear();
            const e2 = Array.from(function(t3) {
              let e3 = null, n2 = 0, i2 = 0, o2 = null;
              const r2 = /* @__PURE__ */ new Map();
              if ("" === t3)
                return r2;
              ";" != t3.charAt(t3.length - 1) && (t3 += ";");
              for (let s2 = 0; s2 < t3.length; s2++) {
                const a2 = t3.charAt(s2);
                if (null === e3)
                  switch (a2) {
                    case ":":
                      o2 || (o2 = t3.substr(n2, s2 - n2), i2 = s2 + 1);
                      break;
                    case '"':
                    case "'":
                      e3 = a2;
                      break;
                    case ";": {
                      const e4 = t3.substr(i2, s2 - i2);
                      o2 && r2.set(o2.trim(), e4.trim()), o2 = null, n2 = s2 + 1;
                      break;
                    }
                  }
                else
                  a2 === e3 && (e3 = null);
              }
              return r2;
            }(t2).entries());
            for (const [t3, n2] of e2)
              this._styleProcessor.toNormalizedForm(t3, n2, this._styles);
          }
          has(t2) {
            if (this.isEmpty)
              return false;
            const e2 = this._styleProcessor.getReducedForm(t2, this._styles).find(([e3]) => e3 === t2);
            return Array.isArray(e2);
          }
          set(t2, e2) {
            if (j(t2))
              for (const [e3, n2] of Object.entries(t2))
                this._styleProcessor.toNormalizedForm(e3, n2, this._styles);
            else
              this._styleProcessor.toNormalizedForm(t2, e2, this._styles);
          }
          remove(t2) {
            const e2 = Ii(t2);
            si(this._styles, e2), delete this._styles[t2], this._cleanEmptyObjectsOnPath(e2);
          }
          getNormalized(t2) {
            return this._styleProcessor.getNormalized(t2, this._styles);
          }
          toString() {
            return this.isEmpty ? "" : this._getStylesEntries().map((t2) => t2.join(":")).sort().join(";") + ";";
          }
          getAsString(t2) {
            if (this.isEmpty)
              return;
            if (this._styles[t2] && !j(this._styles[t2]))
              return this._styles[t2];
            const e2 = this._styleProcessor.getReducedForm(t2, this._styles).find(([e3]) => e3 === t2);
            return Array.isArray(e2) ? e2[1] : void 0;
          }
          getStyleNames() {
            if (this.isEmpty)
              return [];
            return this._getStylesEntries().map(([t2]) => t2);
          }
          clear() {
            this._styles = {};
          }
          _getStylesEntries() {
            const t2 = [], e2 = Object.keys(this._styles);
            for (const n2 of e2)
              t2.push(...this._styleProcessor.getReducedForm(n2, this._styles));
            return t2;
          }
          _cleanEmptyObjectsOnPath(t2) {
            const e2 = t2.split(".");
            if (!(e2.length > 1))
              return;
            const n2 = e2.splice(0, e2.length - 1).join("."), i2 = ai(this._styles, n2);
            i2 && !Array.from(Object.keys(i2)).length && this.remove(n2);
          }
        }
        class Ei {
          constructor() {
            this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
          }
          toNormalizedForm(t2, e2, n2) {
            if (j(e2))
              Ni(n2, Ii(t2), e2);
            else if (this._normalizers.has(t2)) {
              const i2 = this._normalizers.get(t2), { path: o2, value: r2 } = i2(e2);
              Ni(n2, o2, r2);
            } else
              Ni(n2, t2, e2);
          }
          getNormalized(t2, e2) {
            if (!t2)
              return Ci({}, e2);
            if (void 0 !== e2[t2])
              return e2[t2];
            if (this._extractors.has(t2)) {
              const n2 = this._extractors.get(t2);
              if ("string" == typeof n2)
                return ai(e2, n2);
              const i2 = n2(t2, e2);
              if (i2)
                return i2;
            }
            return ai(e2, Ii(t2));
          }
          getReducedForm(t2, e2) {
            const n2 = this.getNormalized(t2, e2);
            if (void 0 === n2)
              return [];
            if (this._reducers.has(t2)) {
              return this._reducers.get(t2)(n2);
            }
            return [[t2, n2]];
          }
          getRelatedStyles(t2) {
            return this._consumables.get(t2) || [];
          }
          setNormalizer(t2, e2) {
            this._normalizers.set(t2, e2);
          }
          setExtractor(t2, e2) {
            this._extractors.set(t2, e2);
          }
          setReducer(t2, e2) {
            this._reducers.set(t2, e2);
          }
          setStyleRelation(t2, e2) {
            this._mapStyleNames(t2, e2);
            for (const n2 of e2)
              this._mapStyleNames(n2, [t2]);
          }
          _mapStyleNames(t2, e2) {
            this._consumables.has(t2) || this._consumables.set(t2, []), this._consumables.get(t2).push(...e2);
          }
        }
        function Ii(t2) {
          return t2.replace("-", ".");
        }
        function Ni(t2, e2, n2) {
          let i2 = n2;
          j(n2) && (i2 = Ci({}, ai(t2, e2), n2)), Si(t2, e2, i2);
        }
        class Oi extends On {
          constructor(t2, e2, n2, i2) {
            if (super(t2), this.name = e2, this._attrs = function(t3) {
              t3 = Ln(t3);
              for (const [e3, n3] of t3)
                null === n3 ? t3.delete(e3) : "string" != typeof n3 && t3.set(e3, String(n3));
              return t3;
            }(n2), this._children = [], i2 && this._insertChild(0, i2), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
              const t3 = this._attrs.get("class");
              Ri(this._classes, t3), this._attrs.delete("class");
            }
            this._styles = new Mi(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style")), this._customProperties = /* @__PURE__ */ new Map();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this._children.length;
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("element" === t2 || "view:element" === t2) : t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          getChild(t2) {
            return this._children[t2];
          }
          getChildIndex(t2) {
            return this._children.indexOf(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          *getAttributeKeys() {
            this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
          }
          *getAttributes() {
            yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
          }
          getAttribute(t2) {
            if ("class" == t2)
              return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
            if ("style" == t2) {
              const t3 = this._styles.toString();
              return "" == t3 ? void 0 : t3;
            }
            return this._attrs.get(t2);
          }
          hasAttribute(t2) {
            return "class" == t2 ? this._classes.size > 0 : "style" == t2 ? !this._styles.isEmpty : this._attrs.has(t2);
          }
          isSimilar(t2) {
            if (!(t2 instanceof Oi))
              return false;
            if (this === t2)
              return true;
            if (this.name != t2.name)
              return false;
            if (this._attrs.size !== t2._attrs.size || this._classes.size !== t2._classes.size || this._styles.size !== t2._styles.size)
              return false;
            for (const [e2, n2] of this._attrs)
              if (!t2._attrs.has(e2) || t2._attrs.get(e2) !== n2)
                return false;
            for (const e2 of this._classes)
              if (!t2._classes.has(e2))
                return false;
            for (const e2 of this._styles.getStyleNames())
              if (!t2._styles.has(e2) || t2._styles.getAsString(e2) !== this._styles.getAsString(e2))
                return false;
            return true;
          }
          hasClass(...t2) {
            for (const e2 of t2)
              if (!this._classes.has(e2))
                return false;
            return true;
          }
          getClassNames() {
            return this._classes.keys();
          }
          getStyle(t2) {
            return this._styles.getAsString(t2);
          }
          getNormalizedStyle(t2) {
            return this._styles.getNormalized(t2);
          }
          getStyleNames() {
            return this._styles.getStyleNames();
          }
          hasStyle(...t2) {
            for (const e2 of t2)
              if (!this._styles.has(e2))
                return false;
            return true;
          }
          findAncestor(...t2) {
            const e2 = new jn(...t2);
            let n2 = this.parent;
            for (; n2; ) {
              if (e2.match(n2))
                return n2;
              n2 = n2.parent;
            }
            return null;
          }
          getCustomProperty(t2) {
            return this._customProperties.get(t2);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          getIdentity() {
            const t2 = Array.from(this._classes).sort().join(","), e2 = this._styles.toString(), n2 = Array.from(this._attrs).map((t3) => `${t3[0]}="${t3[1]}"`).sort().join(" ");
            return this.name + ("" == t2 ? "" : ` class="${t2}"`) + (e2 ? ` style="${e2}"` : "") + ("" == n2 ? "" : " " + n2);
          }
          _clone(t2 = false) {
            const e2 = [];
            if (t2)
              for (const n3 of this.getChildren())
                e2.push(n3._clone(t2));
            const n2 = new this.constructor(this.document, this.name, this._attrs, e2);
            return n2._classes = new Set(this._classes), n2._styles.set(this._styles.getNormalized()), n2._customProperties = new Map(this._customProperties), n2.getFillerOffset = this.getFillerOffset, n2;
          }
          _appendChild(t2) {
            return this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            this._fireChange("children", this);
            let n2 = 0;
            const i2 = function(t3, e3) {
              if ("string" == typeof e3)
                return [new Rn(t3, e3)];
              yn(e3) || (e3 = [e3]);
              return Array.from(e3).map((e4) => "string" == typeof e4 ? new Rn(t3, e4) : e4 instanceof Dn ? new Rn(t3, e4.data) : e4);
            }(this.document, e2);
            for (const e3 of i2)
              null !== e3.parent && e3._remove(), e3.parent = this, e3.document = this.document, this._children.splice(t2, 0, e3), t2++, n2++;
            return n2;
          }
          _removeChildren(t2, e2 = 1) {
            this._fireChange("children", this);
            for (let n2 = t2; n2 < t2 + e2; n2++)
              this._children[n2].parent = null;
            return this._children.splice(t2, e2);
          }
          _setAttribute(t2, e2) {
            e2 = String(e2), this._fireChange("attributes", this), "class" == t2 ? Ri(this._classes, e2) : "style" == t2 ? this._styles.setTo(e2) : this._attrs.set(t2, e2);
          }
          _removeAttribute(t2) {
            return this._fireChange("attributes", this), "class" == t2 ? this._classes.size > 0 && (this._classes.clear(), true) : "style" == t2 ? !this._styles.isEmpty && (this._styles.clear(), true) : this._attrs.delete(t2);
          }
          _addClass(t2) {
            this._fireChange("attributes", this), (t2 = Array.isArray(t2) ? t2 : [t2]).forEach((t3) => this._classes.add(t3));
          }
          _removeClass(t2) {
            this._fireChange("attributes", this), (t2 = Array.isArray(t2) ? t2 : [t2]).forEach((t3) => this._classes.delete(t3));
          }
          _setStyle(t2, e2) {
            this._fireChange("attributes", this), this._styles.set(t2, e2);
          }
          _removeStyle(t2) {
            this._fireChange("attributes", this), (t2 = Array.isArray(t2) ? t2 : [t2]).forEach((t3) => this._styles.remove(t3));
          }
          _setCustomProperty(t2, e2) {
            this._customProperties.set(t2, e2);
          }
          _removeCustomProperty(t2) {
            return this._customProperties.delete(t2);
          }
        }
        function Ri(t2, e2) {
          const n2 = e2.split(/\s+/);
          t2.clear(), n2.forEach((e3) => t2.add(e3));
        }
        class Di extends Oi {
          constructor(t2, e2, n2, i2) {
            super(t2, e2, n2, i2), this.getFillerOffset = Li;
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("containerElement" === t2 || "view:containerElement" === t2 || "element" === t2 || "view:element" === t2) : "containerElement" === t2 || "view:containerElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
        }
        function Li() {
          const t2 = [...this.getChildren()], e2 = t2[this.childCount - 1];
          if (e2 && e2.is("element", "br"))
            return this.childCount;
          for (const e3 of t2)
            if (!e3.is("uiElement"))
              return null;
          return this.childCount;
        }
        var ji = Ti(function(t2, e2) {
          St(e2, re(e2), t2);
        });
        const Vi = Symbol("observableProperties"), zi = Symbol("boundObservables"), Bi = Symbol("boundProperties"), Fi = { set(t2, e2) {
          if (j(t2))
            return void Object.keys(t2).forEach((e3) => {
              this.set(e3, t2[e3]);
            }, this);
          Hi(this);
          const n2 = this[Vi];
          if (t2 in this && !n2.has(t2))
            throw new hn.b("observable-set-cannot-override: Cannot override an existing property.", this);
          Object.defineProperty(this, t2, { enumerable: true, configurable: true, get: () => n2.get(t2), set(e3) {
            const i2 = n2.get(t2);
            let o2 = this.fire("set:" + t2, t2, e3, i2);
            void 0 === o2 && (o2 = e3), i2 === o2 && n2.has(t2) || (n2.set(t2, o2), this.fire("change:" + t2, t2, o2, i2));
          } }), this[t2] = e2;
        }, bind(...t2) {
          if (!t2.length || !Yi(t2))
            throw new hn.b("observable-bind-wrong-properties: All properties must be strings.", this);
          if (new Set(t2).size !== t2.length)
            throw new hn.b("observable-bind-duplicate-properties: Properties must be unique.", this);
          Hi(this);
          const e2 = this[Bi];
          t2.forEach((t3) => {
            if (e2.has(t3))
              throw new hn.b("observable-bind-rebind: Cannot bind the same property more than once.", this);
          });
          const n2 = /* @__PURE__ */ new Map();
          return t2.forEach((t3) => {
            const i2 = { property: t3, to: [] };
            e2.set(t3, i2), n2.set(t3, i2);
          }), { to: qi, toMany: Wi, _observable: this, _bindProperties: t2, _to: [], _bindings: n2 };
        }, unbind(...t2) {
          if (!this[Vi])
            return;
          const e2 = this[Bi], n2 = this[zi];
          if (t2.length) {
            if (!Yi(t2))
              throw new hn.b("observable-unbind-wrong-properties: Properties must be strings.", this);
            t2.forEach((t3) => {
              const i2 = e2.get(t3);
              if (!i2)
                return;
              let o2, r2, s2, a2;
              i2.to.forEach((t4) => {
                o2 = t4[0], r2 = t4[1], s2 = n2.get(o2), a2 = s2[r2], a2.delete(i2), a2.size || delete s2[r2], Object.keys(s2).length || (n2.delete(o2), this.stopListening(o2, "change"));
              }), e2.delete(t3);
            });
          } else
            n2.forEach((t3, e3) => {
              this.stopListening(e3, "change");
            }), n2.clear(), e2.clear();
        }, decorate(t2) {
          const e2 = this[t2];
          if (!e2)
            throw new hn.b("observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.", this, { object: this, methodName: t2 });
          this.on(t2, (t3, n2) => {
            t3.return = e2.apply(this, n2);
          }), this[t2] = function(...e3) {
            return this.fire(t2, e3);
          };
        } };
        ji(Fi, gn);
        var Ui = Fi;
        function Hi(t2) {
          t2[Vi] || (Object.defineProperty(t2, Vi, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t2, zi, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t2, Bi, { value: /* @__PURE__ */ new Map() }));
        }
        function qi(...t2) {
          const e2 = function(...t3) {
            if (!t3.length)
              throw new hn.b("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null);
            const e3 = { to: [] };
            let n3;
            "function" == typeof t3[t3.length - 1] && (e3.callback = t3.pop());
            return t3.forEach((t4) => {
              if ("string" == typeof t4)
                n3.properties.push(t4);
              else {
                if ("object" != typeof t4)
                  throw new hn.b("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null);
                n3 = { observable: t4, properties: [] }, e3.to.push(n3);
              }
            }), e3;
          }(...t2), n2 = Array.from(this._bindings.keys()), i2 = n2.length;
          if (!e2.callback && e2.to.length > 1)
            throw new hn.b("observable-bind-to-no-callback: Binding multiple observables only possible with callback.", this);
          if (i2 > 1 && e2.callback)
            throw new hn.b("observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.", this);
          var o2;
          e2.to.forEach((t3) => {
            if (t3.properties.length && t3.properties.length !== i2)
              throw new hn.b("observable-bind-to-properties-length: The number of properties must match.", this);
            t3.properties.length || (t3.properties = this._bindProperties);
          }), this._to = e2.to, e2.callback && (this._bindings.get(n2[0]).callback = e2.callback), o2 = this._observable, this._to.forEach((t3) => {
            const e3 = o2[zi];
            let n3;
            e3.get(t3.observable) || o2.listenTo(t3.observable, "change", (i3, r2) => {
              n3 = e3.get(t3.observable)[r2], n3 && n3.forEach((t4) => {
                Gi(o2, t4.property);
              });
            });
          }), function(t3) {
            let e3;
            t3._bindings.forEach((n3, i3) => {
              t3._to.forEach((o3) => {
                e3 = o3.properties[n3.callback ? 0 : t3._bindProperties.indexOf(i3)], n3.to.push([o3.observable, e3]), function(t4, e4, n4, i4) {
                  const o4 = t4[zi], r2 = o4.get(n4), s2 = r2 || {};
                  s2[i4] || (s2[i4] = /* @__PURE__ */ new Set());
                  s2[i4].add(e4), r2 || o4.set(n4, s2);
                }(t3._observable, n3, o3.observable, e3);
              });
            });
          }(this), this._bindProperties.forEach((t3) => {
            Gi(this._observable, t3);
          });
        }
        function Wi(t2, e2, n2) {
          if (this._bindings.size > 1)
            throw new hn.b("observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().", this);
          this.to(...function(t3, e3) {
            const n3 = t3.map((t4) => [t4, e3]);
            return Array.prototype.concat.apply([], n3);
          }(t2, e2), n2);
        }
        function Yi(t2) {
          return t2.every((t3) => "string" == typeof t3);
        }
        function Gi(t2, e2) {
          const n2 = t2[Bi].get(e2);
          let i2;
          n2.callback ? i2 = n2.callback.apply(t2, n2.to.map((t3) => t3[0][t3[1]])) : (i2 = n2.to[0], i2 = i2[0][i2[1]]), t2.hasOwnProperty(e2) ? t2[e2] = i2 : t2.set(e2, i2);
        }
        class $i extends Di {
          constructor(t2, e2, n2, i2) {
            super(t2, e2, n2, i2), this.set("isReadOnly", false), this.set("isFocused", false), this.bind("isReadOnly").to(t2), this.bind("isFocused").to(t2, "isFocused", (e3) => e3 && t2.selection.editableElement == this), this.listenTo(t2.selection, "change", () => {
              this.isFocused = t2.isFocused && t2.selection.editableElement == this;
            });
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("editableElement" === t2 || "view:editableElement" === t2 || "containerElement" === t2 || "view:containerElement" === t2 || "element" === t2 || "view:element" === t2) : "editableElement" === t2 || "view:editableElement" === t2 || "containerElement" === t2 || "view:containerElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          destroy() {
            this.stopListening();
          }
        }
        xn($i, Ui);
        const Qi = Symbol("rootName");
        class Ki extends $i {
          constructor(t2, e2) {
            super(t2, e2), this.rootName = "main";
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("rootElement" === t2 || "view:rootElement" === t2 || "editableElement" === t2 || "view:editableElement" === t2 || "containerElement" === t2 || "view:containerElement" === t2 || "element" === t2 || "view:element" === t2) : "rootElement" === t2 || "view:rootElement" === t2 || "editableElement" === t2 || "view:editableElement" === t2 || "containerElement" === t2 || "view:containerElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          get rootName() {
            return this.getCustomProperty(Qi);
          }
          set rootName(t2) {
            this._setCustomProperty(Qi, t2);
          }
          set _name(t2) {
            this.name = t2;
          }
        }
        class Ji {
          constructor(t2 = {}) {
            if (!t2.boundaries && !t2.startPosition)
              throw new hn.b("view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null);
            if (t2.direction && "forward" != t2.direction && "backward" != t2.direction)
              throw new hn.b("view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t2.startPosition, { direction: t2.direction });
            this.boundaries = t2.boundaries || null, t2.startPosition ? this.position = Zi._createAt(t2.startPosition) : this.position = Zi._createAt(t2.boundaries["backward" == t2.direction ? "end" : "start"]), this.direction = t2.direction || "forward", this.singleCharacters = !!t2.singleCharacters, this.shallow = !!t2.shallow, this.ignoreElementEnd = !!t2.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t2) {
            let e2, n2, i2;
            do {
              i2 = this.position, { done: e2, value: n2 } = this.next();
            } while (!e2 && t2(n2));
            e2 || (this.position = i2);
          }
          next() {
            return "forward" == this.direction ? this._next() : this._previous();
          }
          _next() {
            let t2 = this.position.clone();
            const e2 = this.position, n2 = t2.parent;
            if (null === n2.parent && t2.offset === n2.childCount)
              return { done: true };
            if (n2 === this._boundaryEndParent && t2.offset == this.boundaries.end.offset)
              return { done: true };
            let i2;
            if (n2 instanceof Rn) {
              if (t2.isAtEnd)
                return this.position = Zi._createAfter(n2), this._next();
              i2 = n2.data[t2.offset];
            } else
              i2 = n2.getChild(t2.offset);
            if (i2 instanceof Oi)
              return this.shallow ? t2.offset++ : t2 = new Zi(i2, 0), this.position = t2, this._formatReturnValue("elementStart", i2, e2, t2, 1);
            if (i2 instanceof Rn) {
              if (this.singleCharacters)
                return t2 = new Zi(i2, 0), this.position = t2, this._next();
              {
                let n3, o2 = i2.data.length;
                return i2 == this._boundaryEndParent ? (o2 = this.boundaries.end.offset, n3 = new Dn(i2, 0, o2), t2 = Zi._createAfter(n3)) : (n3 = new Dn(i2, 0, i2.data.length), t2.offset++), this.position = t2, this._formatReturnValue("text", n3, e2, t2, o2);
              }
            }
            if ("string" == typeof i2) {
              let i3;
              if (this.singleCharacters)
                i3 = 1;
              else {
                i3 = (n2 === this._boundaryEndParent ? this.boundaries.end.offset : n2.data.length) - t2.offset;
              }
              const o2 = new Dn(n2, t2.offset, i3);
              return t2.offset += i3, this.position = t2, this._formatReturnValue("text", o2, e2, t2, i3);
            }
            return t2 = Zi._createAfter(n2), this.position = t2, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n2, e2, t2);
          }
          _previous() {
            let t2 = this.position.clone();
            const e2 = this.position, n2 = t2.parent;
            if (null === n2.parent && 0 === t2.offset)
              return { done: true };
            if (n2 == this._boundaryStartParent && t2.offset == this.boundaries.start.offset)
              return { done: true };
            let i2;
            if (n2 instanceof Rn) {
              if (t2.isAtStart)
                return this.position = Zi._createBefore(n2), this._previous();
              i2 = n2.data[t2.offset - 1];
            } else
              i2 = n2.getChild(t2.offset - 1);
            if (i2 instanceof Oi)
              return this.shallow ? (t2.offset--, this.position = t2, this._formatReturnValue("elementStart", i2, e2, t2, 1)) : (t2 = new Zi(i2, i2.childCount), this.position = t2, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i2, e2, t2));
            if (i2 instanceof Rn) {
              if (this.singleCharacters)
                return t2 = new Zi(i2, i2.data.length), this.position = t2, this._previous();
              {
                let n3, o2 = i2.data.length;
                if (i2 == this._boundaryStartParent) {
                  const e3 = this.boundaries.start.offset;
                  n3 = new Dn(i2, e3, i2.data.length - e3), o2 = n3.data.length, t2 = Zi._createBefore(n3);
                } else
                  n3 = new Dn(i2, 0, i2.data.length), t2.offset--;
                return this.position = t2, this._formatReturnValue("text", n3, e2, t2, o2);
              }
            }
            if ("string" == typeof i2) {
              let i3;
              if (this.singleCharacters)
                i3 = 1;
              else {
                const e3 = n2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                i3 = t2.offset - e3;
              }
              t2.offset -= i3;
              const o2 = new Dn(n2, t2.offset, i3);
              return this.position = t2, this._formatReturnValue("text", o2, e2, t2, i3);
            }
            return t2 = Zi._createBefore(n2), this.position = t2, this._formatReturnValue("elementStart", n2, e2, t2, 1);
          }
          _formatReturnValue(t2, e2, n2, i2, o2) {
            return e2 instanceof Dn && (e2.offsetInText + e2.data.length == e2.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n2 = Zi._createAfter(e2.textNode) : (i2 = Zi._createAfter(e2.textNode), this.position = i2)), 0 === e2.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n2 = Zi._createBefore(e2.textNode) : (i2 = Zi._createBefore(e2.textNode), this.position = i2))), { done: false, value: { type: t2, item: e2, previousPosition: n2, nextPosition: i2, length: o2 } };
          }
        }
        class Zi {
          constructor(t2, e2) {
            this.parent = t2, this.offset = e2;
          }
          get nodeAfter() {
            return this.parent.is("text") ? null : this.parent.getChild(this.offset) || null;
          }
          get nodeBefore() {
            return this.parent.is("text") ? null : this.parent.getChild(this.offset - 1) || null;
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            const t2 = this.parent.is("text") ? this.parent.data.length : this.parent.childCount;
            return this.offset === t2;
          }
          get root() {
            return this.parent.root;
          }
          get editableElement() {
            let t2 = this.parent;
            for (; !(t2 instanceof $i); ) {
              if (!t2.parent)
                return null;
              t2 = t2.parent;
            }
            return t2;
          }
          getShiftedBy(t2) {
            const e2 = Zi._createAt(this), n2 = e2.offset + t2;
            return e2.offset = n2 < 0 ? 0 : n2, e2;
          }
          getLastMatchingPosition(t2, e2 = {}) {
            e2.startPosition = this;
            const n2 = new Ji(e2);
            return n2.skip(t2), n2.position;
          }
          getAncestors() {
            return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: true });
          }
          getCommonAncestor(t2) {
            const e2 = this.getAncestors(), n2 = t2.getAncestors();
            let i2 = 0;
            for (; e2[i2] == n2[i2] && e2[i2]; )
              i2++;
            return 0 === i2 ? null : e2[i2 - 1];
          }
          is(t2) {
            return "position" === t2 || "view:position" === t2;
          }
          isEqual(t2) {
            return this.parent == t2.parent && this.offset == t2.offset;
          }
          isBefore(t2) {
            return "before" == this.compareWith(t2);
          }
          isAfter(t2) {
            return "after" == this.compareWith(t2);
          }
          compareWith(t2) {
            if (this.root !== t2.root)
              return "different";
            if (this.isEqual(t2))
              return "same";
            const e2 = this.parent.is("node") ? this.parent.getPath() : [], n2 = t2.parent.is("node") ? t2.parent.getPath() : [];
            e2.push(this.offset), n2.push(t2.offset);
            const i2 = In(e2, n2);
            switch (i2) {
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return e2[i2] < n2[i2] ? "before" : "after";
            }
          }
          getWalker(t2 = {}) {
            return t2.startPosition = this, new Ji(t2);
          }
          clone() {
            return new Zi(this.parent, this.offset);
          }
          static _createAt(t2, e2) {
            if (t2 instanceof Zi)
              return new this(t2.parent, t2.offset);
            {
              const n2 = t2;
              if ("end" == e2)
                e2 = n2.is("text") ? n2.data.length : n2.childCount;
              else {
                if ("before" == e2)
                  return this._createBefore(n2);
                if ("after" == e2)
                  return this._createAfter(n2);
                if (0 !== e2 && !e2)
                  throw new hn.b("view-createPositionAt-offset-required: View#createPositionAt() requires the offset when the first parameter is a view item.", n2);
              }
              return new Zi(n2, e2);
            }
          }
          static _createAfter(t2) {
            if (t2.is("textProxy"))
              return new Zi(t2.textNode, t2.offsetInText + t2.data.length);
            if (!t2.parent)
              throw new hn.b("view-position-after-root: You can not make position after root.", t2, { root: t2 });
            return new Zi(t2.parent, t2.index + 1);
          }
          static _createBefore(t2) {
            if (t2.is("textProxy"))
              return new Zi(t2.textNode, t2.offsetInText);
            if (!t2.parent)
              throw new hn.b("view-position-before-root: You can not make position before root.", t2, { root: t2 });
            return new Zi(t2.parent, t2.index);
          }
        }
        class Xi {
          constructor(t2, e2 = null) {
            this.start = t2.clone(), this.end = e2 ? e2.clone() : t2.clone();
          }
          *[Symbol.iterator]() {
            yield* new Ji({ boundaries: this, ignoreElementEnd: true });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return this.start.parent === this.end.parent;
          }
          get root() {
            return this.start.root;
          }
          getEnlarged() {
            let t2 = this.start.getLastMatchingPosition(to, { direction: "backward" }), e2 = this.end.getLastMatchingPosition(to);
            return t2.parent.is("text") && t2.isAtStart && (t2 = Zi._createBefore(t2.parent)), e2.parent.is("text") && e2.isAtEnd && (e2 = Zi._createAfter(e2.parent)), new Xi(t2, e2);
          }
          getTrimmed() {
            let t2 = this.start.getLastMatchingPosition(to);
            if (t2.isAfter(this.end) || t2.isEqual(this.end))
              return new Xi(t2, t2);
            let e2 = this.end.getLastMatchingPosition(to, { direction: "backward" });
            const n2 = t2.nodeAfter, i2 = e2.nodeBefore;
            return n2 && n2.is("text") && (t2 = new Zi(n2, 0)), i2 && i2.is("text") && (e2 = new Zi(i2, i2.data.length)), new Xi(t2, e2);
          }
          isEqual(t2) {
            return this == t2 || this.start.isEqual(t2.start) && this.end.isEqual(t2.end);
          }
          containsPosition(t2) {
            return t2.isAfter(this.start) && t2.isBefore(this.end);
          }
          containsRange(t2, e2 = false) {
            t2.isCollapsed && (e2 = false);
            const n2 = this.containsPosition(t2.start) || e2 && this.start.isEqual(t2.start), i2 = this.containsPosition(t2.end) || e2 && this.end.isEqual(t2.end);
            return n2 && i2;
          }
          getDifference(t2) {
            const e2 = [];
            return this.isIntersecting(t2) ? (this.containsPosition(t2.start) && e2.push(new Xi(this.start, t2.start)), this.containsPosition(t2.end) && e2.push(new Xi(t2.end, this.end))) : e2.push(this.clone()), e2;
          }
          getIntersection(t2) {
            if (this.isIntersecting(t2)) {
              let e2 = this.start, n2 = this.end;
              return this.containsPosition(t2.start) && (e2 = t2.start), this.containsPosition(t2.end) && (n2 = t2.end), new Xi(e2, n2);
            }
            return null;
          }
          getWalker(t2 = {}) {
            return t2.boundaries = this, new Ji(t2);
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed)
              return null;
            let t2 = this.start.nodeAfter, e2 = this.end.nodeBefore;
            return this.start.parent.is("text") && this.start.isAtEnd && this.start.parent.nextSibling && (t2 = this.start.parent.nextSibling), this.end.parent.is("text") && this.end.isAtStart && this.end.parent.previousSibling && (e2 = this.end.parent.previousSibling), t2 && t2.is("element") && t2 === e2 ? t2 : null;
          }
          clone() {
            return new Xi(this.start, this.end);
          }
          *getItems(t2 = {}) {
            t2.boundaries = this, t2.ignoreElementEnd = true;
            const e2 = new Ji(t2);
            for (const t3 of e2)
              yield t3.item;
          }
          *getPositions(t2 = {}) {
            t2.boundaries = this;
            const e2 = new Ji(t2);
            yield e2.position;
            for (const t3 of e2)
              yield t3.nextPosition;
          }
          is(t2) {
            return "range" === t2 || "view:range" === t2;
          }
          isIntersecting(t2) {
            return this.start.isBefore(t2.end) && this.end.isAfter(t2.start);
          }
          static _createFromParentsAndOffsets(t2, e2, n2, i2) {
            return new this(new Zi(t2, e2), new Zi(n2, i2));
          }
          static _createFromPositionAndShift(t2, e2) {
            const n2 = t2, i2 = t2.getShiftedBy(e2);
            return e2 > 0 ? new this(n2, i2) : new this(i2, n2);
          }
          static _createIn(t2) {
            return this._createFromParentsAndOffsets(t2, 0, t2, t2.childCount);
          }
          static _createOn(t2) {
            const e2 = t2.is("textProxy") ? t2.offsetSize : 1;
            return this._createFromPositionAndShift(Zi._createBefore(t2), e2);
          }
        }
        function to(t2) {
          return !(!t2.item.is("attributeElement") && !t2.item.is("uiElement"));
        }
        function eo(t2) {
          let e2 = 0;
          for (const n2 of t2)
            e2++;
          return e2;
        }
        class no {
          constructor(t2 = null, e2, n2) {
            this._ranges = [], this._lastRangeBackward = false, this._isFake = false, this._fakeSelectionLabel = "", this.setTo(t2, e2, n2);
          }
          get isFake() {
            return this._isFake;
          }
          get fakeSelectionLabel() {
            return this._fakeSelectionLabel;
          }
          get anchor() {
            if (!this._ranges.length)
              return null;
            const t2 = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t2.end : t2.start).clone();
          }
          get focus() {
            if (!this._ranges.length)
              return null;
            const t2 = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t2.start : t2.end).clone();
          }
          get isCollapsed() {
            return 1 === this.rangeCount && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          get editableElement() {
            return this.anchor ? this.anchor.editableElement : null;
          }
          *getRanges() {
            for (const t2 of this._ranges)
              yield t2.clone();
          }
          getFirstRange() {
            let t2 = null;
            for (const e2 of this._ranges)
              t2 && !e2.start.isBefore(t2.start) || (t2 = e2);
            return t2 ? t2.clone() : null;
          }
          getLastRange() {
            let t2 = null;
            for (const e2 of this._ranges)
              t2 && !e2.end.isAfter(t2.end) || (t2 = e2);
            return t2 ? t2.clone() : null;
          }
          getFirstPosition() {
            const t2 = this.getFirstRange();
            return t2 ? t2.start.clone() : null;
          }
          getLastPosition() {
            const t2 = this.getLastRange();
            return t2 ? t2.end.clone() : null;
          }
          isEqual(t2) {
            if (this.isFake != t2.isFake)
              return false;
            if (this.isFake && this.fakeSelectionLabel != t2.fakeSelectionLabel)
              return false;
            if (this.rangeCount != t2.rangeCount)
              return false;
            if (0 === this.rangeCount)
              return true;
            if (!this.anchor.isEqual(t2.anchor) || !this.focus.isEqual(t2.focus))
              return false;
            for (const e2 of this._ranges) {
              let n2 = false;
              for (const i2 of t2._ranges)
                if (e2.isEqual(i2)) {
                  n2 = true;
                  break;
                }
              if (!n2)
                return false;
            }
            return true;
          }
          isSimilar(t2) {
            if (this.isBackward != t2.isBackward)
              return false;
            const e2 = eo(this.getRanges());
            if (e2 != eo(t2.getRanges()))
              return false;
            if (0 == e2)
              return true;
            for (let e3 of this.getRanges()) {
              e3 = e3.getTrimmed();
              let n2 = false;
              for (let i2 of t2.getRanges())
                if (i2 = i2.getTrimmed(), e3.start.isEqual(i2.start) && e3.end.isEqual(i2.end)) {
                  n2 = true;
                  break;
                }
              if (!n2)
                return false;
            }
            return true;
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          setTo(t2, e2, n2) {
            if (null === t2)
              this._setRanges([]), this._setFakeOptions(e2);
            else if (t2 instanceof no || t2 instanceof io)
              this._setRanges(t2.getRanges(), t2.isBackward), this._setFakeOptions({ fake: t2.isFake, label: t2.fakeSelectionLabel });
            else if (t2 instanceof Xi)
              this._setRanges([t2], e2 && e2.backward), this._setFakeOptions(e2);
            else if (t2 instanceof Zi)
              this._setRanges([new Xi(t2)]), this._setFakeOptions(e2);
            else if (t2 instanceof On) {
              const i2 = !!n2 && !!n2.backward;
              let o2;
              if (void 0 === e2)
                throw new hn.b("view-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.", this);
              o2 = "in" == e2 ? Xi._createIn(t2) : "on" == e2 ? Xi._createOn(t2) : new Xi(Zi._createAt(t2, e2)), this._setRanges([o2], i2), this._setFakeOptions(n2);
            } else {
              if (!yn(t2))
                throw new hn.b("view-selection-setTo-not-selectable: Cannot set selection to given place.", this);
              this._setRanges(t2, e2 && e2.backward), this._setFakeOptions(e2);
            }
            this.fire("change");
          }
          setFocus(t2, e2) {
            if (null === this.anchor)
              throw new hn.b("view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", this);
            const n2 = Zi._createAt(t2, e2);
            if ("same" == n2.compareWith(this.focus))
              return;
            const i2 = this.anchor;
            this._ranges.pop(), "before" == n2.compareWith(i2) ? this._addRange(new Xi(n2, i2), true) : this._addRange(new Xi(i2, n2)), this.fire("change");
          }
          is(t2) {
            return "selection" === t2 || "view:selection" === t2;
          }
          _setRanges(t2, e2 = false) {
            t2 = Array.from(t2), this._ranges = [];
            for (const e3 of t2)
              this._addRange(e3);
            this._lastRangeBackward = !!e2;
          }
          _setFakeOptions(t2 = {}) {
            this._isFake = !!t2.fake, this._fakeSelectionLabel = t2.fake && t2.label || "";
          }
          _addRange(t2, e2 = false) {
            if (!(t2 instanceof Xi))
              throw new hn.b("view-selection-add-range-not-range: Selection range set to an object that is not an instance of view.Range", this);
            this._pushRange(t2), this._lastRangeBackward = !!e2;
          }
          _pushRange(t2) {
            for (const e2 of this._ranges)
              if (t2.isIntersecting(e2))
                throw new hn.b("view-selection-range-intersects: Trying to add a range that intersects with another range from selection.", this, { addedRange: t2, intersectingRange: e2 });
            this._ranges.push(new Xi(t2.start, t2.end));
          }
        }
        xn(no, gn);
        class io {
          constructor(t2 = null, e2, n2) {
            this._selection = new no(), this._selection.delegate("change").to(this), this._selection.setTo(t2, e2, n2);
          }
          get isFake() {
            return this._selection.isFake;
          }
          get fakeSelectionLabel() {
            return this._selection.fakeSelectionLabel;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get editableElement() {
            return this._selection.editableElement;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          *getRanges() {
            yield* this._selection.getRanges();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          isEqual(t2) {
            return this._selection.isEqual(t2);
          }
          isSimilar(t2) {
            return this._selection.isSimilar(t2);
          }
          is(t2) {
            return "selection" === t2 || "documentSelection" == t2 || "view:selection" == t2 || "view:documentSelection" == t2;
          }
          _setTo(t2, e2, n2) {
            this._selection.setTo(t2, e2, n2);
          }
          _setFocus(t2, e2) {
            this._selection.setFocus(t2, e2);
          }
        }
        xn(io, gn);
        class oo {
          constructor(t2) {
            this.selection = new io(), this.roots = new An({ idProperty: "rootName" }), this.stylesProcessor = t2, this.set("isReadOnly", false), this.set("isFocused", false), this.set("isComposing", false), this._postFixers = /* @__PURE__ */ new Set();
          }
          getRoot(t2 = "main") {
            return this.roots.get(t2);
          }
          registerPostFixer(t2) {
            this._postFixers.add(t2);
          }
          destroy() {
            this.roots.map((t2) => t2.destroy()), this.stopListening();
          }
          _callPostFixers(t2) {
            let e2 = false;
            do {
              for (const n2 of this._postFixers)
                if (e2 = n2(t2), e2)
                  break;
            } while (e2);
          }
        }
        xn(oo, Ui);
        class ro extends Oi {
          constructor(t2, e2, n2, i2) {
            super(t2, e2, n2, i2), this.getFillerOffset = so, this._priority = 10, this._id = null, this._clonesGroup = null;
          }
          get priority() {
            return this._priority;
          }
          get id() {
            return this._id;
          }
          getElementsWithSameId() {
            if (null === this.id)
              throw new hn.b("attribute-element-get-elements-with-same-id-no-id: Cannot get elements with the same id for an attribute element without id.", this);
            return new Set(this._clonesGroup);
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("attributeElement" === t2 || "view:attributeElement" === t2 || "element" === t2 || "view:element" === t2) : "attributeElement" === t2 || "view:attributeElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          isSimilar(t2) {
            return null !== this.id || null !== t2.id ? this.id === t2.id : super.isSimilar(t2) && this.priority == t2.priority;
          }
          _clone(t2) {
            const e2 = super._clone(t2);
            return e2._priority = this._priority, e2._id = this._id, e2;
          }
        }
        function so() {
          if (ao(this))
            return null;
          let t2 = this.parent;
          for (; t2 && t2.is("attributeElement"); ) {
            if (ao(t2) > 1)
              return null;
            t2 = t2.parent;
          }
          return !t2 || ao(t2) > 1 ? null : this.childCount;
        }
        function ao(t2) {
          return Array.from(t2.getChildren()).filter((t3) => !t3.is("uiElement")).length;
        }
        ro.DEFAULT_PRIORITY = 10;
        class co extends Oi {
          constructor(t2, e2, n2, i2) {
            super(t2, e2, n2, i2), this.getFillerOffset = lo;
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("emptyElement" === t2 || "view:emptyElement" === t2 || "element" === t2 || "view:element" === t2) : "emptyElement" === t2 || "view:emptyElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          _insertChild(t2, e2) {
            if (e2 && (e2 instanceof On || Array.from(e2).length > 0))
              throw new hn.b("view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.", [this, e2]);
          }
        }
        function lo() {
          return null;
        }
        const uo = navigator.userAgent.toLowerCase();
        var ho = { isMac: function(t2) {
          return t2.indexOf("macintosh") > -1;
        }(uo), isGecko: function(t2) {
          return !!t2.match(/gecko\/\d+/);
        }(uo), isSafari: function(t2) {
          return t2.indexOf(" applewebkit/") > -1 && -1 === t2.indexOf("chrome");
        }(uo), isAndroid: function(t2) {
          return t2.indexOf("android") > -1;
        }(uo), features: { isRegExpUnicodePropertySupported: function() {
          let t2 = false;
          try {
            t2 = 0 === "\u0107".search(new RegExp("[\\p{L}]", "u"));
          } catch (t3) {
          }
          return t2;
        }() } };
        const fo = { "\u2318": "ctrl", "\u21E7": "shift", "\u2325": "alt" }, mo = { ctrl: "\u2318", shift: "\u21E7", alt: "\u2325" }, go = function() {
          const t2 = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, cmd: 1114112, shift: 2228224, alt: 4456448 };
          for (let e2 = 65; e2 <= 90; e2++) {
            const n2 = String.fromCharCode(e2);
            t2[n2.toLowerCase()] = e2;
          }
          for (let e2 = 48; e2 <= 57; e2++)
            t2[e2 - 48] = e2;
          for (let e2 = 112; e2 <= 123; e2++)
            t2["f" + (e2 - 111)] = e2;
          return t2;
        }();
        function po(t2) {
          let e2;
          if ("string" == typeof t2) {
            if (e2 = go[t2.toLowerCase()], !e2)
              throw new hn.b("keyboard-unknown-key: Unknown key name.", null, { key: t2 });
          } else
            e2 = t2.keyCode + (t2.altKey ? go.alt : 0) + (t2.ctrlKey ? go.ctrl : 0) + (t2.shiftKey ? go.shift : 0);
          return e2;
        }
        function bo(t2) {
          return "string" == typeof t2 && (t2 = ko(t2)), t2.map((t3) => "string" == typeof t3 ? po(t3) : t3).reduce((t3, e2) => e2 + t3, 0);
        }
        function wo(t2) {
          return ho.isMac ? ko(t2).map((t3) => mo[t3.toLowerCase()] || t3).reduce((t3, e2) => t3.slice(-1) in fo ? t3 + e2 : t3 + "+" + e2) : t2;
        }
        function ko(t2) {
          return t2.split(/\s*\+\s*/);
        }
        class _o extends Oi {
          constructor(t2, e2, n2, i2) {
            super(t2, e2, n2, i2), this.getFillerOffset = yo;
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("uiElement" === t2 || "view:uiElement" === t2 || "element" === t2 || "view:element" === t2) : "uiElement" === t2 || "view:uiElement" === t2 || t2 === this.name || t2 === "view:" + this.name || "element" === t2 || "view:element" === t2 || "node" === t2 || "view:node" === t2;
          }
          _insertChild(t2, e2) {
            if (e2 && (e2 instanceof On || Array.from(e2).length > 0))
              throw new hn.b("view-uielement-cannot-add: Cannot add child nodes to UIElement instance.", this);
          }
          render(t2) {
            return this.toDomElement(t2);
          }
          toDomElement(t2) {
            const e2 = t2.createElement(this.name);
            for (const t3 of this.getAttributeKeys())
              e2.setAttribute(t3, this.getAttribute(t3));
            return e2;
          }
        }
        function vo(t2) {
          t2.document.on("keydown", (e2, n2) => function(t3, e3, n3) {
            if (e3.keyCode == go.arrowright) {
              const t4 = e3.domTarget.ownerDocument.defaultView.getSelection(), i2 = 1 == t4.rangeCount && t4.getRangeAt(0).collapsed;
              if (i2 || e3.shiftKey) {
                const e4 = t4.focusNode, o2 = t4.focusOffset, r2 = n3.domPositionToView(e4, o2);
                if (null === r2)
                  return;
                let s2 = false;
                const a2 = r2.getLastMatchingPosition((t5) => (t5.item.is("uiElement") && (s2 = true), !(!t5.item.is("uiElement") && !t5.item.is("attributeElement"))));
                if (s2) {
                  const e5 = n3.viewPositionToDom(a2);
                  i2 ? t4.collapse(e5.parent, e5.offset) : t4.extend(e5.parent, e5.offset);
                }
              }
            }
          }(0, n2, t2.domConverter));
        }
        function yo() {
          return null;
        }
        class xo {
          constructor(t2, e2) {
            this.document = t2, this._children = [], e2 && this._insertChild(0, e2);
          }
          [Symbol.iterator]() {
            return this._children[Symbol.iterator]();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t2) {
            return "documentFragment" === t2 || "view:documentFragment" === t2;
          }
          _appendChild(t2) {
            return this._insertChild(this.childCount, t2);
          }
          getChild(t2) {
            return this._children[t2];
          }
          getChildIndex(t2) {
            return this._children.indexOf(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          _insertChild(t2, e2) {
            this._fireChange("children", this);
            let n2 = 0;
            const i2 = function(t3, e3) {
              if ("string" == typeof e3)
                return [new Rn(t3, e3)];
              yn(e3) || (e3 = [e3]);
              return Array.from(e3).map((e4) => "string" == typeof e4 ? new Rn(t3, e4) : e4 instanceof Dn ? new Rn(t3, e4.data) : e4);
            }(this.document, e2);
            for (const e3 of i2)
              null !== e3.parent && e3._remove(), e3.parent = this, this._children.splice(t2, 0, e3), t2++, n2++;
            return n2;
          }
          _removeChildren(t2, e2 = 1) {
            this._fireChange("children", this);
            for (let n2 = t2; n2 < t2 + e2; n2++)
              this._children[n2].parent = null;
            return this._children.splice(t2, e2);
          }
          _fireChange(t2, e2) {
            this.fire("change:" + t2, e2);
          }
        }
        xn(xo, gn);
        class Ao {
          constructor(t2) {
            this.document = t2, this._cloneGroups = /* @__PURE__ */ new Map();
          }
          setSelection(t2, e2, n2) {
            this.document.selection._setTo(t2, e2, n2);
          }
          setSelectionFocus(t2, e2) {
            this.document.selection._setFocus(t2, e2);
          }
          createText(t2) {
            return new Rn(this.document, t2);
          }
          createAttributeElement(t2, e2, n2 = {}) {
            const i2 = new ro(this.document, t2, e2);
            return n2.priority && (i2._priority = n2.priority), n2.id && (i2._id = n2.id), i2;
          }
          createContainerElement(t2, e2) {
            return new Di(this.document, t2, e2);
          }
          createEditableElement(t2, e2) {
            const n2 = new $i(this.document, t2, e2);
            return n2._document = this.document, n2;
          }
          createEmptyElement(t2, e2) {
            return new co(this.document, t2, e2);
          }
          createUIElement(t2, e2, n2) {
            const i2 = new _o(this.document, t2, e2);
            return n2 && (i2.render = n2), i2;
          }
          setAttribute(t2, e2, n2) {
            n2._setAttribute(t2, e2);
          }
          removeAttribute(t2, e2) {
            e2._removeAttribute(t2);
          }
          addClass(t2, e2) {
            e2._addClass(t2);
          }
          removeClass(t2, e2) {
            e2._removeClass(t2);
          }
          setStyle(t2, e2, n2) {
            y(t2) && void 0 === n2 && (n2 = e2), n2._setStyle(t2, e2);
          }
          removeStyle(t2, e2) {
            e2._removeStyle(t2);
          }
          setCustomProperty(t2, e2, n2) {
            n2._setCustomProperty(t2, e2);
          }
          removeCustomProperty(t2, e2) {
            return e2._removeCustomProperty(t2);
          }
          breakAttributes(t2) {
            return t2 instanceof Zi ? this._breakAttributes(t2) : this._breakAttributesRange(t2);
          }
          breakContainer(t2) {
            const e2 = t2.parent;
            if (!e2.is("containerElement"))
              throw new hn.b("view-writer-break-non-container-element: Trying to break an element which is not a container element.", this.document);
            if (!e2.parent)
              throw new hn.b("view-writer-break-root: Trying to break root element.", this.document);
            if (t2.isAtStart)
              return Zi._createBefore(e2);
            if (!t2.isAtEnd) {
              const n2 = e2._clone(false);
              this.insert(Zi._createAfter(e2), n2);
              const i2 = new Xi(t2, Zi._createAt(e2, "end")), o2 = new Zi(n2, 0);
              this.move(i2, o2);
            }
            return Zi._createAfter(e2);
          }
          mergeAttributes(t2) {
            const e2 = t2.offset, n2 = t2.parent;
            if (n2.is("text"))
              return t2;
            if (n2.is("attributeElement") && 0 === n2.childCount) {
              const t3 = n2.parent, e3 = n2.index;
              return n2._remove(), this._removeFromClonedElementsGroup(n2), this.mergeAttributes(new Zi(t3, e3));
            }
            const i2 = n2.getChild(e2 - 1), o2 = n2.getChild(e2);
            if (!i2 || !o2)
              return t2;
            if (i2.is("text") && o2.is("text"))
              return Mo(i2, o2);
            if (i2.is("attributeElement") && o2.is("attributeElement") && i2.isSimilar(o2)) {
              const t3 = i2.childCount;
              return i2._appendChild(o2.getChildren()), o2._remove(), this._removeFromClonedElementsGroup(o2), this.mergeAttributes(new Zi(i2, t3));
            }
            return t2;
          }
          mergeContainers(t2) {
            const e2 = t2.nodeBefore, n2 = t2.nodeAfter;
            if (!(e2 && n2 && e2.is("containerElement") && n2.is("containerElement")))
              throw new hn.b("view-writer-merge-containers-invalid-position: Element before and after given position cannot be merged.", this.document);
            const i2 = e2.getChild(e2.childCount - 1), o2 = i2 instanceof Rn ? Zi._createAt(i2, "end") : Zi._createAt(e2, "end");
            return this.move(Xi._createIn(n2), Zi._createAt(e2, "end")), this.remove(Xi._createOn(n2)), o2;
          }
          insert(t2, e2) {
            (function t3(e3, n3) {
              for (const i3 of e3) {
                if (!Eo.some((t4) => i3 instanceof t4))
                  throw new hn.b("view-writer-insert-invalid-node", n3);
                i3.is("text") || t3(i3.getChildren(), n3);
              }
            })(e2 = yn(e2) ? [...e2] : [e2], this.document);
            const n2 = To(t2);
            if (!n2)
              throw new hn.b("view-writer-invalid-position-container", this.document);
            const i2 = this._breakAttributes(t2, true), o2 = n2._insertChild(i2.offset, e2);
            for (const t3 of e2)
              this._addToClonedElementsGroup(t3);
            const r2 = i2.getShiftedBy(o2), s2 = this.mergeAttributes(i2);
            if (0 === o2)
              return new Xi(s2, s2);
            {
              s2.isEqual(i2) || r2.offset--;
              const t3 = this.mergeAttributes(r2);
              return new Xi(s2, t3);
            }
          }
          remove(t2) {
            const e2 = t2 instanceof Xi ? t2 : Xi._createOn(t2);
            if (No(e2, this.document), e2.isCollapsed)
              return new xo(this.document);
            const { start: n2, end: i2 } = this._breakAttributesRange(e2, true), o2 = n2.parent, r2 = i2.offset - n2.offset, s2 = o2._removeChildren(n2.offset, r2);
            for (const t3 of s2)
              this._removeFromClonedElementsGroup(t3);
            const a2 = this.mergeAttributes(n2);
            return e2.start = a2, e2.end = a2.clone(), new xo(this.document, s2);
          }
          clear(t2, e2) {
            No(t2, this.document);
            const n2 = t2.getWalker({ direction: "backward", ignoreElementEnd: true });
            for (const i2 of n2) {
              const n3 = i2.item;
              let o2;
              if (n3.is("element") && e2.isSimilar(n3))
                o2 = Xi._createOn(n3);
              else if (!i2.nextPosition.isAfter(t2.start) && n3.is("textProxy")) {
                const t3 = n3.getAncestors().find((t4) => t4.is("element") && e2.isSimilar(t4));
                t3 && (o2 = Xi._createIn(t3));
              }
              o2 && (o2.end.isAfter(t2.end) && (o2.end = t2.end), o2.start.isBefore(t2.start) && (o2.start = t2.start), this.remove(o2));
            }
          }
          move(t2, e2) {
            let n2;
            if (e2.isAfter(t2.end)) {
              const i2 = (e2 = this._breakAttributes(e2, true)).parent, o2 = i2.childCount;
              t2 = this._breakAttributesRange(t2, true), n2 = this.remove(t2), e2.offset += i2.childCount - o2;
            } else
              n2 = this.remove(t2);
            return this.insert(e2, n2);
          }
          wrap(t2, e2) {
            if (!(e2 instanceof ro))
              throw new hn.b("view-writer-wrap-invalid-attribute", this.document);
            if (No(t2, this.document), t2.isCollapsed) {
              let i2 = t2.start;
              i2.parent.is("element") && (n2 = i2.parent, !Array.from(n2.getChildren()).some((t3) => !t3.is("uiElement"))) && (i2 = i2.getLastMatchingPosition((t3) => t3.item.is("uiElement"))), i2 = this._wrapPosition(i2, e2);
              const o2 = this.document.selection;
              return o2.isCollapsed && o2.getFirstPosition().isEqual(t2.start) && this.setSelection(i2), new Xi(i2);
            }
            return this._wrapRange(t2, e2);
            var n2;
          }
          unwrap(t2, e2) {
            if (!(e2 instanceof ro))
              throw new hn.b("view-writer-unwrap-invalid-attribute", this.document);
            if (No(t2, this.document), t2.isCollapsed)
              return t2;
            const { start: n2, end: i2 } = this._breakAttributesRange(t2, true), o2 = n2.parent, r2 = this._unwrapChildren(o2, n2.offset, i2.offset, e2), s2 = this.mergeAttributes(r2.start);
            s2.isEqual(r2.start) || r2.end.offset--;
            const a2 = this.mergeAttributes(r2.end);
            return new Xi(s2, a2);
          }
          rename(t2, e2) {
            const n2 = new Di(this.document, t2, e2.getAttributes());
            return this.insert(Zi._createAfter(e2), n2), this.move(Xi._createIn(e2), Zi._createAt(n2, 0)), this.remove(Xi._createOn(e2)), n2;
          }
          clearClonedElementsGroup(t2) {
            this._cloneGroups.delete(t2);
          }
          createPositionAt(t2, e2) {
            return Zi._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return Zi._createAfter(t2);
          }
          createPositionBefore(t2) {
            return Zi._createBefore(t2);
          }
          createRange(t2, e2) {
            return new Xi(t2, e2);
          }
          createRangeOn(t2) {
            return Xi._createOn(t2);
          }
          createRangeIn(t2) {
            return Xi._createIn(t2);
          }
          createSelection(t2, e2, n2) {
            return new no(t2, e2, n2);
          }
          _wrapChildren(t2, e2, n2, i2) {
            let o2 = e2;
            const r2 = [];
            for (; o2 < n2; ) {
              const e3 = t2.getChild(o2), n3 = e3.is("text"), s3 = e3.is("attributeElement"), a2 = e3.is("emptyElement"), c2 = e3.is("uiElement");
              if (s3 && this._wrapAttributeElement(i2, e3))
                r2.push(new Zi(t2, o2));
              else if (n3 || a2 || c2 || s3 && Co(i2, e3)) {
                const n4 = i2._clone();
                e3._remove(), n4._appendChild(e3), t2._insertChild(o2, n4), this._addToClonedElementsGroup(n4), r2.push(new Zi(t2, o2));
              } else
                s3 && this._wrapChildren(e3, 0, e3.childCount, i2);
              o2++;
            }
            let s2 = 0;
            for (const t3 of r2) {
              if (t3.offset -= s2, t3.offset == e2)
                continue;
              this.mergeAttributes(t3).isEqual(t3) || (s2++, n2--);
            }
            return Xi._createFromParentsAndOffsets(t2, e2, t2, n2);
          }
          _unwrapChildren(t2, e2, n2, i2) {
            let o2 = e2;
            const r2 = [];
            for (; o2 < n2; ) {
              const e3 = t2.getChild(o2);
              if (e3.is("attributeElement"))
                if (e3.isSimilar(i2)) {
                  const i3 = e3.getChildren(), s3 = e3.childCount;
                  e3._remove(), t2._insertChild(o2, i3), this._removeFromClonedElementsGroup(e3), r2.push(new Zi(t2, o2), new Zi(t2, o2 + s3)), o2 += s3, n2 += s3 - 1;
                } else
                  this._unwrapAttributeElement(i2, e3) ? (r2.push(new Zi(t2, o2), new Zi(t2, o2 + 1)), o2++) : (this._unwrapChildren(e3, 0, e3.childCount, i2), o2++);
              else
                o2++;
            }
            let s2 = 0;
            for (const t3 of r2) {
              if (t3.offset -= s2, t3.offset == e2 || t3.offset == n2)
                continue;
              this.mergeAttributes(t3).isEqual(t3) || (s2++, n2--);
            }
            return Xi._createFromParentsAndOffsets(t2, e2, t2, n2);
          }
          _wrapRange(t2, e2) {
            const { start: n2, end: i2 } = this._breakAttributesRange(t2, true), o2 = n2.parent, r2 = this._wrapChildren(o2, n2.offset, i2.offset, e2), s2 = this.mergeAttributes(r2.start);
            s2.isEqual(r2.start) || r2.end.offset--;
            const a2 = this.mergeAttributes(r2.end);
            return new Xi(s2, a2);
          }
          _wrapPosition(t2, e2) {
            if (e2.isSimilar(t2.parent))
              return Po(t2.clone());
            t2.parent.is("text") && (t2 = So(t2));
            const n2 = this.createAttributeElement();
            n2._priority = Number.POSITIVE_INFINITY, n2.isSimilar = () => false, t2.parent._insertChild(t2.offset, n2);
            const i2 = new Xi(t2, t2.getShiftedBy(1));
            this.wrap(i2, e2);
            const o2 = new Zi(n2.parent, n2.index);
            n2._remove();
            const r2 = o2.nodeBefore, s2 = o2.nodeAfter;
            return r2 instanceof Rn && s2 instanceof Rn ? Mo(r2, s2) : Po(o2);
          }
          _wrapAttributeElement(t2, e2) {
            if (!Oo(t2, e2))
              return false;
            if (t2.name !== e2.name || t2.priority !== e2.priority)
              return false;
            for (const n2 of t2.getAttributeKeys())
              if ("class" !== n2 && "style" !== n2 && e2.hasAttribute(n2) && e2.getAttribute(n2) !== t2.getAttribute(n2))
                return false;
            for (const n2 of t2.getStyleNames())
              if (e2.hasStyle(n2) && e2.getStyle(n2) !== t2.getStyle(n2))
                return false;
            for (const n2 of t2.getAttributeKeys())
              "class" !== n2 && "style" !== n2 && (e2.hasAttribute(n2) || this.setAttribute(n2, t2.getAttribute(n2), e2));
            for (const n2 of t2.getStyleNames())
              e2.hasStyle(n2) || this.setStyle(n2, t2.getStyle(n2), e2);
            for (const n2 of t2.getClassNames())
              e2.hasClass(n2) || this.addClass(n2, e2);
            return true;
          }
          _unwrapAttributeElement(t2, e2) {
            if (!Oo(t2, e2))
              return false;
            if (t2.name !== e2.name || t2.priority !== e2.priority)
              return false;
            for (const n2 of t2.getAttributeKeys())
              if ("class" !== n2 && "style" !== n2 && (!e2.hasAttribute(n2) || e2.getAttribute(n2) !== t2.getAttribute(n2)))
                return false;
            if (!e2.hasClass(...t2.getClassNames()))
              return false;
            for (const n2 of t2.getStyleNames())
              if (!e2.hasStyle(n2) || e2.getStyle(n2) !== t2.getStyle(n2))
                return false;
            for (const n2 of t2.getAttributeKeys())
              "class" !== n2 && "style" !== n2 && this.removeAttribute(n2, e2);
            return this.removeClass(Array.from(t2.getClassNames()), e2), this.removeStyle(Array.from(t2.getStyleNames()), e2), true;
          }
          _breakAttributesRange(t2, e2 = false) {
            const n2 = t2.start, i2 = t2.end;
            if (No(t2, this.document), t2.isCollapsed) {
              const n3 = this._breakAttributes(t2.start, e2);
              return new Xi(n3, n3);
            }
            const o2 = this._breakAttributes(i2, e2), r2 = o2.parent.childCount, s2 = this._breakAttributes(n2, e2);
            return o2.offset += o2.parent.childCount - r2, new Xi(s2, o2);
          }
          _breakAttributes(t2, e2 = false) {
            const n2 = t2.offset, i2 = t2.parent;
            if (t2.parent.is("emptyElement"))
              throw new hn.b("view-writer-cannot-break-empty-element", this.document);
            if (t2.parent.is("uiElement"))
              throw new hn.b("view-writer-cannot-break-ui-element", this.document);
            if (!e2 && i2.is("text") && Io(i2.parent))
              return t2.clone();
            if (Io(i2))
              return t2.clone();
            if (i2.is("text"))
              return this._breakAttributes(So(t2), e2);
            if (n2 == i2.childCount) {
              const t3 = new Zi(i2.parent, i2.index + 1);
              return this._breakAttributes(t3, e2);
            }
            if (0 === n2) {
              const t3 = new Zi(i2.parent, i2.index);
              return this._breakAttributes(t3, e2);
            }
            {
              const t3 = i2.index + 1, o2 = i2._clone();
              i2.parent._insertChild(t3, o2), this._addToClonedElementsGroup(o2);
              const r2 = i2.childCount - n2, s2 = i2._removeChildren(n2, r2);
              o2._appendChild(s2);
              const a2 = new Zi(i2.parent, t3);
              return this._breakAttributes(a2, e2);
            }
          }
          _addToClonedElementsGroup(t2) {
            if (!t2.root.is("rootElement"))
              return;
            if (t2.is("element"))
              for (const e3 of t2.getChildren())
                this._addToClonedElementsGroup(e3);
            const e2 = t2.id;
            if (!e2)
              return;
            let n2 = this._cloneGroups.get(e2);
            n2 || (n2 = /* @__PURE__ */ new Set(), this._cloneGroups.set(e2, n2)), n2.add(t2), t2._clonesGroup = n2;
          }
          _removeFromClonedElementsGroup(t2) {
            if (t2.is("element"))
              for (const e3 of t2.getChildren())
                this._removeFromClonedElementsGroup(e3);
            const e2 = t2.id;
            if (!e2)
              return;
            const n2 = this._cloneGroups.get(e2);
            n2 && n2.delete(t2);
          }
        }
        function To(t2) {
          let e2 = t2.parent;
          for (; !Io(e2); ) {
            if (!e2)
              return;
            e2 = e2.parent;
          }
          return e2;
        }
        function Co(t2, e2) {
          return t2.priority < e2.priority || !(t2.priority > e2.priority) && t2.getIdentity() < e2.getIdentity();
        }
        function Po(t2) {
          const e2 = t2.nodeBefore;
          if (e2 && e2.is("text"))
            return new Zi(e2, e2.data.length);
          const n2 = t2.nodeAfter;
          return n2 && n2.is("text") ? new Zi(n2, 0) : t2;
        }
        function So(t2) {
          if (t2.offset == t2.parent.data.length)
            return new Zi(t2.parent.parent, t2.parent.index + 1);
          if (0 === t2.offset)
            return new Zi(t2.parent.parent, t2.parent.index);
          const e2 = t2.parent.data.slice(t2.offset);
          return t2.parent._data = t2.parent.data.slice(0, t2.offset), t2.parent.parent._insertChild(t2.parent.index + 1, new Rn(t2.root.document, e2)), new Zi(t2.parent.parent, t2.parent.index + 1);
        }
        function Mo(t2, e2) {
          const n2 = t2.data.length;
          return t2._data += e2.data, e2._remove(), new Zi(t2, n2);
        }
        const Eo = [Rn, ro, Di, co, _o];
        function Io(t2) {
          return t2 && (t2.is("containerElement") || t2.is("documentFragment"));
        }
        function No(t2, e2) {
          const n2 = To(t2.start), i2 = To(t2.end);
          if (!n2 || !i2 || n2 !== i2)
            throw new hn.b("view-writer-invalid-range-container", e2);
        }
        function Oo(t2, e2) {
          return null === t2.id && null === e2.id;
        }
        function Ro(t2) {
          return "[object Text]" == Object.prototype.toString.call(t2);
        }
        const Do = (t2) => t2.createTextNode("\xA0"), Lo = (t2) => {
          const e2 = t2.createElement("br");
          return e2.dataset.ckeFiller = true, e2;
        }, jo = (() => {
          let t2 = "";
          for (let e2 = 0; e2 < 7; e2++)
            t2 += "\u200B";
          return t2;
        })();
        function Vo(t2) {
          return Ro(t2) && t2.data.substr(0, 7) === jo;
        }
        function zo(t2) {
          return 7 == t2.data.length && Vo(t2);
        }
        function Bo(t2) {
          return Vo(t2) ? t2.data.slice(7) : t2.data;
        }
        function Fo(t2, e2) {
          if (e2.keyCode == go.arrowleft) {
            const t3 = e2.domTarget.ownerDocument.defaultView.getSelection();
            if (1 == t3.rangeCount && t3.getRangeAt(0).collapsed) {
              const e3 = t3.getRangeAt(0).startContainer, n2 = t3.getRangeAt(0).startOffset;
              Vo(e3) && n2 <= 7 && t3.collapse(e3, 0);
            }
          }
        }
        function Uo(t2, e2, n2, i2 = false) {
          n2 = n2 || function(t3, e3) {
            return t3 === e3;
          }, Array.isArray(t2) || (t2 = Array.prototype.slice.call(t2)), Array.isArray(e2) || (e2 = Array.prototype.slice.call(e2));
          const o2 = function(t3, e3, n3) {
            const i3 = Ho(t3, e3, n3);
            if (-1 === i3)
              return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
            const o3 = qo(t3, i3), r2 = qo(e3, i3), s2 = Ho(o3, r2, n3), a2 = t3.length - s2, c2 = e3.length - s2;
            return { firstIndex: i3, lastIndexOld: a2, lastIndexNew: c2 };
          }(t2, e2, n2);
          return i2 ? function(t3, e3) {
            const { firstIndex: n3, lastIndexOld: i3, lastIndexNew: o3 } = t3;
            if (-1 === n3)
              return Array(e3).fill("equal");
            let r2 = [];
            n3 > 0 && (r2 = r2.concat(Array(n3).fill("equal")));
            o3 - n3 > 0 && (r2 = r2.concat(Array(o3 - n3).fill("insert")));
            i3 - n3 > 0 && (r2 = r2.concat(Array(i3 - n3).fill("delete")));
            o3 < e3 && (r2 = r2.concat(Array(e3 - o3).fill("equal")));
            return r2;
          }(o2, e2.length) : function(t3, e3) {
            const n3 = [], { firstIndex: i3, lastIndexOld: o3, lastIndexNew: r2 } = e3;
            r2 - i3 > 0 && n3.push({ index: i3, type: "insert", values: t3.slice(i3, r2) });
            o3 - i3 > 0 && n3.push({ index: i3 + (r2 - i3), type: "delete", howMany: o3 - i3 });
            return n3;
          }(e2, o2);
        }
        function Ho(t2, e2, n2) {
          for (let i2 = 0; i2 < Math.max(t2.length, e2.length); i2++)
            if (void 0 === t2[i2] || void 0 === e2[i2] || !n2(t2[i2], e2[i2]))
              return i2;
          return -1;
        }
        function qo(t2, e2) {
          return t2.slice(e2).reverse();
        }
        function Wo(t2, e2, n2) {
          n2 = n2 || function(t3, e3) {
            return t3 === e3;
          };
          const i2 = t2.length, o2 = e2.length;
          if (i2 > 200 || o2 > 200 || i2 + o2 > 300)
            return Wo.fastDiff(t2, e2, n2, true);
          let r2, s2;
          if (o2 < i2) {
            const n3 = t2;
            t2 = e2, e2 = n3, r2 = "delete", s2 = "insert";
          } else
            r2 = "insert", s2 = "delete";
          const a2 = t2.length, c2 = e2.length, l2 = c2 - a2, d2 = {}, u2 = {};
          function h2(i3) {
            const o3 = (void 0 !== u2[i3 - 1] ? u2[i3 - 1] : -1) + 1, l3 = void 0 !== u2[i3 + 1] ? u2[i3 + 1] : -1, h3 = o3 > l3 ? -1 : 1;
            d2[i3 + h3] && (d2[i3] = d2[i3 + h3].slice(0)), d2[i3] || (d2[i3] = []), d2[i3].push(o3 > l3 ? r2 : s2);
            let f3 = Math.max(o3, l3), m3 = f3 - i3;
            for (; m3 < a2 && f3 < c2 && n2(t2[m3], e2[f3]); )
              m3++, f3++, d2[i3].push("equal");
            return f3;
          }
          let f2, m2 = 0;
          do {
            for (f2 = -m2; f2 < l2; f2++)
              u2[f2] = h2(f2);
            for (f2 = l2 + m2; f2 > l2; f2--)
              u2[f2] = h2(f2);
            u2[l2] = h2(l2), m2++;
          } while (u2[l2] !== c2);
          return d2[l2].slice(1);
        }
        function Yo(t2, e2, n2) {
          t2.insertBefore(n2, t2.childNodes[e2] || null);
        }
        function Go(t2) {
          const e2 = t2.parentNode;
          e2 && e2.removeChild(t2);
        }
        function $o(t2) {
          if (t2) {
            if (t2.defaultView)
              return t2 instanceof t2.defaultView.Document;
            if (t2.ownerDocument && t2.ownerDocument.defaultView)
              return t2 instanceof t2.ownerDocument.defaultView.Node;
          }
          return false;
        }
        Wo.fastDiff = Uo;
        class Qo {
          constructor(t2, e2) {
            this.domDocuments = /* @__PURE__ */ new Set(), this.domConverter = t2, this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this.selection = e2, this.isFocused = false, this._inlineFiller = null, this._fakeSelectionContainer = null;
          }
          markToSync(t2, e2) {
            if ("text" === t2)
              this.domConverter.mapViewToDom(e2.parent) && this.markedTexts.add(e2);
            else {
              if (!this.domConverter.mapViewToDom(e2))
                return;
              if ("attributes" === t2)
                this.markedAttributes.add(e2);
              else {
                if ("children" !== t2)
                  throw new hn.b("view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.", this);
                this.markedChildren.add(e2);
              }
            }
          }
          render() {
            let t2;
            for (const t3 of this.markedChildren)
              this._updateChildrenMappings(t3);
            this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t2 = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t2 = this.selection.getFirstPosition(), this.markedChildren.add(t2.parent));
            for (const t3 of this.markedAttributes)
              this._updateAttrs(t3);
            for (const e2 of this.markedChildren)
              this._updateChildren(e2, { inlineFillerPosition: t2 });
            for (const e2 of this.markedTexts)
              !this.markedChildren.has(e2.parent) && this.domConverter.mapViewToDom(e2.parent) && this._updateText(e2, { inlineFillerPosition: t2 });
            if (t2) {
              const e2 = this.domConverter.viewPositionToDom(t2), n2 = e2.parent.ownerDocument;
              Vo(e2.parent) ? this._inlineFiller = e2.parent : this._inlineFiller = Ko(n2, e2.parent, e2.offset);
            } else
              this._inlineFiller = null;
            this._updateSelection(), this._updateFocus(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
          }
          _updateChildrenMappings(t2) {
            const e2 = this.domConverter.mapViewToDom(t2);
            if (!e2)
              return;
            const n2 = this.domConverter.mapViewToDom(t2).childNodes, i2 = Array.from(this.domConverter.viewChildrenToDom(t2, e2.ownerDocument, { withChildren: false })), o2 = this._diffNodeLists(n2, i2), r2 = this._findReplaceActions(o2, n2, i2);
            if (-1 !== r2.indexOf("replace")) {
              const e3 = { equal: 0, insert: 0, delete: 0 };
              for (const o3 of r2)
                if ("replace" === o3) {
                  const o4 = e3.equal + e3.insert, r3 = e3.equal + e3.delete, s2 = t2.getChild(o4);
                  s2 && !s2.is("uiElement") && this._updateElementMappings(s2, n2[r3]), Go(i2[o4]), e3.equal++;
                } else
                  e3[o3]++;
            }
          }
          _updateElementMappings(t2, e2) {
            this.domConverter.unbindDomElement(e2), this.domConverter.bindElements(e2, t2), this.markedChildren.add(t2), this.markedAttributes.add(t2);
          }
          _getInlineFillerPosition() {
            const t2 = this.selection.getFirstPosition();
            return t2.parent.is("text") ? Zi._createBefore(this.selection.getFirstPosition().parent) : t2;
          }
          _isSelectionInInlineFiller() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
              return false;
            const t2 = this.selection.getFirstPosition(), e2 = this.domConverter.viewPositionToDom(t2);
            return !!(e2 && Ro(e2.parent) && Vo(e2.parent));
          }
          _removeInlineFiller() {
            const t2 = this._inlineFiller;
            if (!Vo(t2))
              throw new hn.b("view-renderer-filler-was-lost: The inline filler node was lost.", this);
            zo(t2) ? t2.parentNode.removeChild(t2) : t2.data = t2.data.substr(7), this._inlineFiller = null;
          }
          _needsInlineFillerAtSelection() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
              return false;
            const t2 = this.selection.getFirstPosition(), e2 = t2.parent, n2 = t2.offset;
            if (!this.domConverter.mapViewToDom(e2.root))
              return false;
            if (!e2.is("element"))
              return false;
            if (!function(t3) {
              if ("false" == t3.getAttribute("contenteditable"))
                return false;
              const e3 = t3.findAncestor((t4) => t4.hasAttribute("contenteditable"));
              return !e3 || "true" == e3.getAttribute("contenteditable");
            }(e2))
              return false;
            if (n2 === e2.getFillerOffset())
              return false;
            const i2 = t2.nodeBefore, o2 = t2.nodeAfter;
            return !(i2 instanceof Rn || o2 instanceof Rn);
          }
          _updateText(t2, e2) {
            const n2 = this.domConverter.findCorrespondingDomText(t2), i2 = this.domConverter.viewToDom(t2, n2.ownerDocument), o2 = n2.data;
            let r2 = i2.data;
            const s2 = e2.inlineFillerPosition;
            if (s2 && s2.parent == t2.parent && s2.offset == t2.index && (r2 = jo + r2), o2 != r2) {
              const t3 = Uo(o2, r2);
              for (const e3 of t3)
                "insert" === e3.type ? n2.insertData(e3.index, e3.values.join("")) : n2.deleteData(e3.index, e3.howMany);
            }
          }
          _updateAttrs(t2) {
            const e2 = this.domConverter.mapViewToDom(t2);
            if (!e2)
              return;
            const n2 = Array.from(e2.attributes).map((t3) => t3.name), i2 = t2.getAttributeKeys();
            for (const n3 of i2)
              e2.setAttribute(n3, t2.getAttribute(n3));
            for (const i3 of n2)
              t2.hasAttribute(i3) || e2.removeAttribute(i3);
          }
          _updateChildren(t2, e2) {
            const n2 = this.domConverter.mapViewToDom(t2);
            if (!n2)
              return;
            const i2 = e2.inlineFillerPosition, o2 = this.domConverter.mapViewToDom(t2).childNodes, r2 = Array.from(this.domConverter.viewChildrenToDom(t2, n2.ownerDocument, { bind: true, inlineFillerPosition: i2 }));
            i2 && i2.parent === t2 && Ko(n2.ownerDocument, r2, i2.offset);
            const s2 = this._diffNodeLists(o2, r2);
            let a2 = 0;
            const c2 = /* @__PURE__ */ new Set();
            for (const t3 of s2)
              "delete" === t3 ? (c2.add(o2[a2]), Go(o2[a2])) : "equal" === t3 && a2++;
            a2 = 0;
            for (const t3 of s2)
              "insert" === t3 ? (Yo(n2, a2, r2[a2]), a2++) : "equal" === t3 && (this._markDescendantTextToSync(this.domConverter.domToView(r2[a2])), a2++);
            for (const t3 of c2)
              t3.parentNode || this.domConverter.unbindDomElement(t3);
          }
          _diffNodeLists(t2, e2) {
            return Wo(t2 = function(t3, e3) {
              const n2 = Array.from(t3);
              if (0 == n2.length || !e3)
                return n2;
              n2[n2.length - 1] == e3 && n2.pop();
              return n2;
            }(t2, this._fakeSelectionContainer), e2, Zo.bind(null, this.domConverter));
          }
          _findReplaceActions(t2, e2, n2) {
            if (-1 === t2.indexOf("insert") || -1 === t2.indexOf("delete"))
              return t2;
            let i2 = [], o2 = [], r2 = [];
            const s2 = { equal: 0, insert: 0, delete: 0 };
            for (const a2 of t2)
              "insert" === a2 ? r2.push(n2[s2.equal + s2.insert]) : "delete" === a2 ? o2.push(e2[s2.equal + s2.delete]) : (i2 = i2.concat(Wo(o2, r2, Jo).map((t3) => "equal" === t3 ? "replace" : t3)), i2.push("equal"), o2 = [], r2 = []), s2[a2]++;
            return i2.concat(Wo(o2, r2, Jo).map((t3) => "equal" === t3 ? "replace" : t3));
          }
          _markDescendantTextToSync(t2) {
            if (t2) {
              if (t2.is("text"))
                this.markedTexts.add(t2);
              else if (t2.is("element"))
                for (const e2 of t2.getChildren())
                  this._markDescendantTextToSync(e2);
            }
          }
          _updateSelection() {
            if (0 === this.selection.rangeCount)
              return this._removeDomSelection(), void this._removeFakeSelection();
            const t2 = this.domConverter.mapViewToDom(this.selection.editableElement);
            this.isFocused && t2 && (this.selection.isFake ? this._updateFakeSelection(t2) : (this._removeFakeSelection(), this._updateDomSelection(t2)));
          }
          _updateFakeSelection(t2) {
            const e2 = t2.ownerDocument;
            this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t3) {
              const e3 = t3.createElement("div");
              return Object.assign(e3.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), e3.textContent = "\xA0", e3;
            }(e2));
            const n2 = this._fakeSelectionContainer;
            if (this.domConverter.bindFakeSelection(n2, this.selection), !this._fakeSelectionNeedsUpdate(t2))
              return;
            n2.parentElement && n2.parentElement == t2 || t2.appendChild(n2), n2.textContent = this.selection.fakeSelectionLabel || "\xA0";
            const i2 = e2.getSelection(), o2 = e2.createRange();
            i2.removeAllRanges(), o2.selectNodeContents(n2), i2.addRange(o2);
          }
          _updateDomSelection(t2) {
            const e2 = t2.ownerDocument.defaultView.getSelection();
            if (!this._domSelectionNeedsUpdate(e2))
              return;
            const n2 = this.domConverter.viewPositionToDom(this.selection.anchor), i2 = this.domConverter.viewPositionToDom(this.selection.focus);
            t2.focus(), e2.collapse(n2.parent, n2.offset), e2.extend(i2.parent, i2.offset), ho.isGecko && function(t3, e3) {
              const n3 = t3.parent;
              if (n3.nodeType != Node.ELEMENT_NODE || t3.offset != n3.childNodes.length - 1)
                return;
              const i3 = n3.childNodes[t3.offset];
              i3 && "BR" == i3.tagName && e3.addRange(e3.getRangeAt(0));
            }(i2, e2);
          }
          _domSelectionNeedsUpdate(t2) {
            if (!this.domConverter.isDomSelectionCorrect(t2))
              return true;
            const e2 = t2 && this.domConverter.domSelectionToView(t2);
            return (!e2 || !this.selection.isEqual(e2)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e2));
          }
          _fakeSelectionNeedsUpdate(t2) {
            const e2 = this._fakeSelectionContainer, n2 = t2.ownerDocument.getSelection();
            return !e2 || e2.parentElement !== t2 || (n2.anchorNode !== e2 && !e2.contains(n2.anchorNode) || e2.textContent !== this.selection.fakeSelectionLabel);
          }
          _removeDomSelection() {
            for (const t2 of this.domDocuments) {
              if (t2.getSelection().rangeCount) {
                const e2 = t2.activeElement, n2 = this.domConverter.mapDomToView(e2);
                e2 && n2 && t2.getSelection().removeAllRanges();
              }
            }
          }
          _removeFakeSelection() {
            const t2 = this._fakeSelectionContainer;
            t2 && t2.remove();
          }
          _updateFocus() {
            if (this.isFocused) {
              const t2 = this.selection.editableElement;
              t2 && this.domConverter.focus(t2);
            }
          }
        }
        function Ko(t2, e2, n2) {
          const i2 = e2 instanceof Array ? e2 : e2.childNodes, o2 = i2[n2];
          if (Ro(o2))
            return o2.data = jo + o2.data, o2;
          {
            const o3 = t2.createTextNode(jo);
            return Array.isArray(e2) ? i2.splice(n2, 0, o3) : Yo(e2, n2, o3), o3;
          }
        }
        function Jo(t2, e2) {
          return $o(t2) && $o(e2) && !Ro(t2) && !Ro(e2) && t2.tagName.toLowerCase() === e2.tagName.toLowerCase();
        }
        function Zo(t2, e2, n2) {
          return e2 === n2 || (Ro(e2) && Ro(n2) ? e2.data === n2.data : !(!t2.isBlockFiller(e2) || !t2.isBlockFiller(n2)));
        }
        xn(Qo, Ui);
        var Xo = { window, document };
        function tr(t2) {
          let e2 = 0;
          for (; t2.previousSibling; )
            t2 = t2.previousSibling, e2++;
          return e2;
        }
        function er(t2) {
          const e2 = [];
          for (; t2 && t2.nodeType != Node.DOCUMENT_NODE; )
            e2.unshift(t2), t2 = t2.parentNode;
          return e2;
        }
        const nr = Lo(document);
        class ir {
          constructor(t2, e2 = {}) {
            this.document = t2, this.blockFillerMode = e2.blockFillerMode || "br", this.preElements = ["pre"], this.blockElements = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "li", "dd", "dt", "figcaption"], this._blockFiller = "br" == this.blockFillerMode ? Lo : Do, this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap();
          }
          bindFakeSelection(t2, e2) {
            this._fakeSelectionMapping.set(t2, new no(e2));
          }
          fakeSelectionToView(t2) {
            return this._fakeSelectionMapping.get(t2);
          }
          bindElements(t2, e2) {
            this._domToViewMapping.set(t2, e2), this._viewToDomMapping.set(e2, t2);
          }
          unbindDomElement(t2) {
            const e2 = this._domToViewMapping.get(t2);
            if (e2) {
              this._domToViewMapping.delete(t2), this._viewToDomMapping.delete(e2);
              for (const e3 of t2.childNodes)
                this.unbindDomElement(e3);
            }
          }
          bindDocumentFragments(t2, e2) {
            this._domToViewMapping.set(t2, e2), this._viewToDomMapping.set(e2, t2);
          }
          viewToDom(t2, e2, n2 = {}) {
            if (t2.is("text")) {
              const n3 = this._processDataFromViewText(t2);
              return e2.createTextNode(n3);
            }
            {
              if (this.mapViewToDom(t2))
                return this.mapViewToDom(t2);
              let i2;
              if (t2.is("documentFragment"))
                i2 = e2.createDocumentFragment(), n2.bind && this.bindDocumentFragments(i2, t2);
              else {
                if (t2.is("uiElement"))
                  return i2 = t2.render(e2), n2.bind && this.bindElements(i2, t2), i2;
                i2 = t2.hasAttribute("xmlns") ? e2.createElementNS(t2.getAttribute("xmlns"), t2.name) : e2.createElement(t2.name), n2.bind && this.bindElements(i2, t2);
                for (const e3 of t2.getAttributeKeys())
                  i2.setAttribute(e3, t2.getAttribute(e3));
              }
              if (n2.withChildren || void 0 === n2.withChildren)
                for (const o2 of this.viewChildrenToDom(t2, e2, n2))
                  i2.appendChild(o2);
              return i2;
            }
          }
          *viewChildrenToDom(t2, e2, n2 = {}) {
            const i2 = t2.getFillerOffset && t2.getFillerOffset();
            let o2 = 0;
            for (const r2 of t2.getChildren())
              i2 === o2 && (yield this._blockFiller(e2)), yield this.viewToDom(r2, e2, n2), o2++;
            i2 === o2 && (yield this._blockFiller(e2));
          }
          viewRangeToDom(t2) {
            const e2 = this.viewPositionToDom(t2.start), n2 = this.viewPositionToDom(t2.end), i2 = document.createRange();
            return i2.setStart(e2.parent, e2.offset), i2.setEnd(n2.parent, n2.offset), i2;
          }
          viewPositionToDom(t2) {
            const e2 = t2.parent;
            if (e2.is("text")) {
              const n2 = this.findCorrespondingDomText(e2);
              if (!n2)
                return null;
              let i2 = t2.offset;
              return Vo(n2) && (i2 += 7), { parent: n2, offset: i2 };
            }
            {
              let n2, i2, o2;
              if (0 === t2.offset) {
                if (n2 = this.mapViewToDom(e2), !n2)
                  return null;
                o2 = n2.childNodes[0];
              } else {
                const e3 = t2.nodeBefore;
                if (i2 = e3.is("text") ? this.findCorrespondingDomText(e3) : this.mapViewToDom(t2.nodeBefore), !i2)
                  return null;
                n2 = i2.parentNode, o2 = i2.nextSibling;
              }
              if (Ro(o2) && Vo(o2))
                return { parent: o2, offset: 7 };
              return { parent: n2, offset: i2 ? tr(i2) + 1 : 0 };
            }
          }
          domToView(t2, e2 = {}) {
            if (this.isBlockFiller(t2, this.blockFillerMode))
              return null;
            const n2 = this.getParentUIElement(t2, this._domToViewMapping);
            if (n2)
              return n2;
            if (Ro(t2)) {
              if (zo(t2))
                return null;
              {
                const e3 = this._processDataFromDomText(t2);
                return "" === e3 ? null : new Rn(this.document, e3);
              }
            }
            if (this.isComment(t2))
              return null;
            {
              if (this.mapDomToView(t2))
                return this.mapDomToView(t2);
              let n3;
              if (this.isDocumentFragment(t2))
                n3 = new xo(this.document), e2.bind && this.bindDocumentFragments(t2, n3);
              else {
                const i2 = e2.keepOriginalCase ? t2.tagName : t2.tagName.toLowerCase();
                n3 = new Oi(this.document, i2), e2.bind && this.bindElements(t2, n3);
                const o2 = t2.attributes;
                for (let t3 = o2.length - 1; t3 >= 0; t3--)
                  n3._setAttribute(o2[t3].name, o2[t3].value);
              }
              if (e2.withChildren || void 0 === e2.withChildren)
                for (const i2 of this.domChildrenToView(t2, e2))
                  n3._appendChild(i2);
              return n3;
            }
          }
          *domChildrenToView(t2, e2 = {}) {
            for (let n2 = 0; n2 < t2.childNodes.length; n2++) {
              const i2 = t2.childNodes[n2], o2 = this.domToView(i2, e2);
              null !== o2 && (yield o2);
            }
          }
          domSelectionToView(t2) {
            if (1 === t2.rangeCount) {
              let e3 = t2.getRangeAt(0).startContainer;
              Ro(e3) && (e3 = e3.parentNode);
              const n3 = this.fakeSelectionToView(e3);
              if (n3)
                return n3;
            }
            const e2 = this.isDomSelectionBackward(t2), n2 = [];
            for (let e3 = 0; e3 < t2.rangeCount; e3++) {
              const i2 = t2.getRangeAt(e3), o2 = this.domRangeToView(i2);
              o2 && n2.push(o2);
            }
            return new no(n2, { backward: e2 });
          }
          domRangeToView(t2) {
            const e2 = this.domPositionToView(t2.startContainer, t2.startOffset), n2 = this.domPositionToView(t2.endContainer, t2.endOffset);
            return e2 && n2 ? new Xi(e2, n2) : null;
          }
          domPositionToView(t2, e2) {
            if (this.isBlockFiller(t2, this.blockFillerMode))
              return this.domPositionToView(t2.parentNode, tr(t2));
            const n2 = this.mapDomToView(t2);
            if (n2 && n2.is("uiElement"))
              return Zi._createBefore(n2);
            if (Ro(t2)) {
              if (zo(t2))
                return this.domPositionToView(t2.parentNode, tr(t2));
              const n3 = this.findCorrespondingViewText(t2);
              let i2 = e2;
              return n3 ? (Vo(t2) && (i2 -= 7, i2 = i2 < 0 ? 0 : i2), new Zi(n3, i2)) : null;
            }
            if (0 === e2) {
              const e3 = this.mapDomToView(t2);
              if (e3)
                return new Zi(e3, 0);
            } else {
              const n3 = t2.childNodes[e2 - 1], i2 = Ro(n3) ? this.findCorrespondingViewText(n3) : this.mapDomToView(n3);
              if (i2 && i2.parent)
                return new Zi(i2.parent, i2.index + 1);
            }
            return null;
          }
          mapDomToView(t2) {
            return this.getParentUIElement(t2) || this._domToViewMapping.get(t2);
          }
          findCorrespondingViewText(t2) {
            if (zo(t2))
              return null;
            const e2 = this.getParentUIElement(t2);
            if (e2)
              return e2;
            const n2 = t2.previousSibling;
            if (n2) {
              if (!this.isElement(n2))
                return null;
              const t3 = this.mapDomToView(n2);
              if (t3) {
                return t3.nextSibling instanceof Rn ? t3.nextSibling : null;
              }
            } else {
              const e3 = this.mapDomToView(t2.parentNode);
              if (e3) {
                const t3 = e3.getChild(0);
                return t3 instanceof Rn ? t3 : null;
              }
            }
            return null;
          }
          mapViewToDom(t2) {
            return this._viewToDomMapping.get(t2);
          }
          findCorrespondingDomText(t2) {
            const e2 = t2.previousSibling;
            return e2 && this.mapViewToDom(e2) ? this.mapViewToDom(e2).nextSibling : !e2 && t2.parent && this.mapViewToDom(t2.parent) ? this.mapViewToDom(t2.parent).childNodes[0] : null;
          }
          focus(t2) {
            const e2 = this.mapViewToDom(t2);
            if (e2 && e2.ownerDocument.activeElement !== e2) {
              const { scrollX: t3, scrollY: n2 } = Xo.window, i2 = [];
              rr(e2, (t4) => {
                const { scrollLeft: e3, scrollTop: n3 } = t4;
                i2.push([e3, n3]);
              }), e2.focus(), rr(e2, (t4) => {
                const [e3, n3] = i2.shift();
                t4.scrollLeft = e3, t4.scrollTop = n3;
              }), Xo.window.scrollTo(t3, n2);
            }
          }
          isElement(t2) {
            return t2 && t2.nodeType == Node.ELEMENT_NODE;
          }
          isDocumentFragment(t2) {
            return t2 && t2.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
          }
          isComment(t2) {
            return t2 && t2.nodeType == Node.COMMENT_NODE;
          }
          isBlockFiller(t2) {
            return "br" == this.blockFillerMode ? t2.isEqualNode(nr) : !("BR" !== t2.tagName || !sr(t2, this.blockElements) || 1 !== t2.parentNode.childNodes.length) || function(t3, e2) {
              return Ro(t3) && "\xA0" == t3.data && sr(t3, e2) && 1 === t3.parentNode.childNodes.length;
            }(t2, this.blockElements);
          }
          isDomSelectionBackward(t2) {
            if (t2.isCollapsed)
              return false;
            const e2 = document.createRange();
            e2.setStart(t2.anchorNode, t2.anchorOffset), e2.setEnd(t2.focusNode, t2.focusOffset);
            const n2 = e2.collapsed;
            return e2.detach(), n2;
          }
          getParentUIElement(t2) {
            const e2 = er(t2);
            for (e2.pop(); e2.length; ) {
              const t3 = e2.pop(), n2 = this._domToViewMapping.get(t3);
              if (n2 && n2.is("uiElement"))
                return n2;
            }
            return null;
          }
          isDomSelectionCorrect(t2) {
            return this._isDomSelectionPositionCorrect(t2.anchorNode, t2.anchorOffset) && this._isDomSelectionPositionCorrect(t2.focusNode, t2.focusOffset);
          }
          _isDomSelectionPositionCorrect(t2, e2) {
            if (Ro(t2) && Vo(t2) && e2 < 7)
              return false;
            if (this.isElement(t2) && Vo(t2.childNodes[e2]))
              return false;
            const n2 = this.mapDomToView(t2);
            return !n2 || !n2.is("uiElement");
          }
          _processDataFromViewText(t2) {
            let e2 = t2.data;
            if (t2.getAncestors().some((t3) => this.preElements.includes(t3.name)))
              return e2;
            if (" " == e2.charAt(0)) {
              const n2 = this._getTouchingViewTextNode(t2, false);
              !(n2 && this._nodeEndsWithSpace(n2)) && n2 || (e2 = "\xA0" + e2.substr(1));
            }
            if (" " == e2.charAt(e2.length - 1)) {
              const n2 = this._getTouchingViewTextNode(t2, true);
              " " != e2.charAt(e2.length - 2) && n2 && " " != n2.data.charAt(0) || (e2 = e2.substr(0, e2.length - 1) + "\xA0");
            }
            return e2.replace(/ {2}/g, " \xA0");
          }
          _nodeEndsWithSpace(t2) {
            if (t2.getAncestors().some((t3) => this.preElements.includes(t3.name)))
              return false;
            const e2 = this._processDataFromViewText(t2);
            return " " == e2.charAt(e2.length - 1);
          }
          _processDataFromDomText(t2) {
            let e2 = t2.data;
            if (or(t2, this.preElements))
              return Bo(t2);
            e2 = e2.replace(/[ \n\t\r]{1,}/g, " ");
            const n2 = this._getTouchingInlineDomNode(t2, false), i2 = this._getTouchingInlineDomNode(t2, true), o2 = this._checkShouldLeftTrimDomText(n2), r2 = this._checkShouldRightTrimDomText(t2, i2);
            return o2 && (e2 = e2.replace(/^ /, "")), r2 && (e2 = e2.replace(/ $/, "")), e2 = Bo(new Text(e2)), e2 = e2.replace(/ \u00A0/g, "  "), (/( |\u00A0)\u00A0$/.test(e2) || !i2 || i2.data && " " == i2.data.charAt(0)) && (e2 = e2.replace(/\u00A0$/, " ")), o2 && (e2 = e2.replace(/^\u00A0/, " ")), e2;
          }
          _checkShouldLeftTrimDomText(t2) {
            return !t2 || (!!nn(t2) || /[^\S\u00A0]/.test(t2.data.charAt(t2.data.length - 1)));
          }
          _checkShouldRightTrimDomText(t2, e2) {
            return !e2 && !Vo(t2);
          }
          _getTouchingViewTextNode(t2, e2) {
            const n2 = new Ji({ startPosition: e2 ? Zi._createAfter(t2) : Zi._createBefore(t2), direction: e2 ? "forward" : "backward" });
            for (const t3 of n2) {
              if (t3.item.is("containerElement"))
                return null;
              if (t3.item.is("br"))
                return null;
              if (t3.item.is("textProxy"))
                return t3.item;
            }
            return null;
          }
          _getTouchingInlineDomNode(t2, e2) {
            if (!t2.parentNode)
              return null;
            const n2 = e2 ? "nextNode" : "previousNode", i2 = t2.ownerDocument, o2 = er(t2)[0], r2 = i2.createTreeWalker(o2, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, { acceptNode: (t3) => Ro(t3) || "BR" == t3.tagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
            r2.currentNode = t2;
            const s2 = r2[n2]();
            if (null !== s2) {
              const e3 = function(t3, e4) {
                const n3 = er(t3), i3 = er(e4);
                let o3 = 0;
                for (; n3[o3] == i3[o3] && n3[o3]; )
                  o3++;
                return 0 === o3 ? null : n3[o3 - 1];
              }(t2, s2);
              if (e3 && !or(t2, this.blockElements, e3) && !or(s2, this.blockElements, e3))
                return s2;
            }
            return null;
          }
        }
        function or(t2, e2, n2) {
          let i2 = er(t2);
          return n2 && (i2 = i2.slice(i2.indexOf(n2) + 1)), i2.some((t3) => t3.tagName && e2.includes(t3.tagName.toLowerCase()));
        }
        function rr(t2, e2) {
          for (; t2 && t2 != Xo.document; )
            e2(t2), t2 = t2.parentNode;
        }
        function sr(t2, e2) {
          const n2 = t2.parentNode;
          return n2 && n2.tagName && e2.includes(n2.tagName.toLowerCase());
        }
        function ar(t2) {
          const e2 = Object.prototype.toString.apply(t2);
          return "[object Window]" == e2 || "[object global]" == e2;
        }
        var cr = ji({}, gn, { listenTo(t2, ...e2) {
          if ($o(t2) || ar(t2)) {
            const n2 = this._getProxyEmitter(t2) || new lr(t2);
            n2.attach(...e2), t2 = n2;
          }
          gn.listenTo.call(this, t2, ...e2);
        }, stopListening(t2, e2, n2) {
          if ($o(t2) || ar(t2)) {
            const e3 = this._getProxyEmitter(t2);
            if (!e3)
              return;
            t2 = e3;
          }
          gn.stopListening.call(this, t2, e2, n2), t2 instanceof lr && t2.detach(e2);
        }, _getProxyEmitter(t2) {
          return e2 = this, n2 = dr(t2), e2[fn] && e2[fn][n2] ? e2[fn][n2].emitter : null;
          var e2, n2;
        } });
        class lr {
          constructor(t2) {
            pn(this, dr(t2)), this._domNode = t2;
          }
        }
        function dr(t2) {
          return t2["data-ck-expando"] || (t2["data-ck-expando"] = dn());
        }
        ji(lr.prototype, gn, { attach(t2, e2, n2 = {}) {
          if (this._domListeners && this._domListeners[t2])
            return;
          const i2 = this._createDomListener(t2, !!n2.useCapture);
          this._domNode.addEventListener(t2, i2, !!n2.useCapture), this._domListeners || (this._domListeners = {}), this._domListeners[t2] = i2;
        }, detach(t2) {
          let e2;
          !this._domListeners[t2] || (e2 = this._events[t2]) && e2.callbacks.length || this._domListeners[t2].removeListener();
        }, _createDomListener(t2, e2) {
          const n2 = (e3) => {
            this.fire(t2, e3);
          };
          return n2.removeListener = () => {
            this._domNode.removeEventListener(t2, n2, e2), delete this._domListeners[t2];
          }, n2;
        } });
        class ur {
          constructor(t2) {
            this.view = t2, this.document = t2.document, this.isEnabled = false;
          }
          enable() {
            this.isEnabled = true;
          }
          disable() {
            this.isEnabled = false;
          }
          destroy() {
            this.disable(), this.stopListening();
          }
        }
        xn(ur, cr);
        var hr = function(t2) {
          return this.__data__.set(t2, "__lodash_hash_undefined__"), this;
        };
        var fr = function(t2) {
          return this.__data__.has(t2);
        };
        function mr(t2) {
          var e2 = -1, n2 = null == t2 ? 0 : t2.length;
          for (this.__data__ = new kt(); ++e2 < n2; )
            this.add(t2[e2]);
        }
        mr.prototype.add = mr.prototype.push = hr, mr.prototype.has = fr;
        var gr = mr;
        var pr = function(t2, e2) {
          for (var n2 = -1, i2 = null == t2 ? 0 : t2.length; ++n2 < i2; )
            if (e2(t2[n2], n2, t2))
              return true;
          return false;
        };
        var br = function(t2, e2) {
          return t2.has(e2);
        };
        var wr = function(t2, e2, n2, i2, o2, r2) {
          var s2 = 1 & n2, a2 = t2.length, c2 = e2.length;
          if (a2 != c2 && !(s2 && c2 > a2))
            return false;
          var l2 = r2.get(t2);
          if (l2 && r2.get(e2))
            return l2 == e2;
          var d2 = -1, u2 = true, h2 = 2 & n2 ? new gr() : void 0;
          for (r2.set(t2, e2), r2.set(e2, t2); ++d2 < a2; ) {
            var f2 = t2[d2], m2 = e2[d2];
            if (i2)
              var g2 = s2 ? i2(m2, f2, d2, e2, t2, r2) : i2(f2, m2, d2, t2, e2, r2);
            if (void 0 !== g2) {
              if (g2)
                continue;
              u2 = false;
              break;
            }
            if (h2) {
              if (!pr(e2, function(t3, e3) {
                if (!br(h2, e3) && (f2 === t3 || o2(f2, t3, n2, i2, r2)))
                  return h2.push(e3);
              })) {
                u2 = false;
                break;
              }
            } else if (f2 !== m2 && !o2(f2, m2, n2, i2, r2)) {
              u2 = false;
              break;
            }
          }
          return r2.delete(t2), r2.delete(e2), u2;
        };
        var kr = function(t2) {
          var e2 = -1, n2 = Array(t2.size);
          return t2.forEach(function(t3, i2) {
            n2[++e2] = [i2, t3];
          }), n2;
        };
        var _r = function(t2) {
          var e2 = -1, n2 = Array(t2.size);
          return t2.forEach(function(t3) {
            n2[++e2] = t3;
          }), n2;
        }, vr = o ? o.prototype : void 0, yr = vr ? vr.valueOf : void 0;
        var xr = function(t2, e2, n2, i2, o2, r2, s2) {
          switch (n2) {
            case "[object DataView]":
              if (t2.byteLength != e2.byteLength || t2.byteOffset != e2.byteOffset)
                return false;
              t2 = t2.buffer, e2 = e2.buffer;
            case "[object ArrayBuffer]":
              return !(t2.byteLength != e2.byteLength || !r2(new Re(t2), new Re(e2)));
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
              return A(+t2, +e2);
            case "[object Error]":
              return t2.name == e2.name && t2.message == e2.message;
            case "[object RegExp]":
            case "[object String]":
              return t2 == e2 + "";
            case "[object Map]":
              var a2 = kr;
            case "[object Set]":
              var c2 = 1 & i2;
              if (a2 || (a2 = _r), t2.size != e2.size && !c2)
                return false;
              var l2 = s2.get(t2);
              if (l2)
                return l2 == e2;
              i2 |= 2, s2.set(t2, e2);
              var d2 = wr(a2(t2), a2(e2), i2, o2, r2, s2);
              return s2.delete(t2), d2;
            case "[object Symbol]":
              if (yr)
                return yr.call(t2) == yr.call(e2);
          }
          return false;
        }, Ar = Object.prototype.hasOwnProperty;
        var Tr = function(t2, e2, n2, i2, o2, r2) {
          var s2 = 1 & n2, a2 = ke(t2), c2 = a2.length;
          if (c2 != ke(e2).length && !s2)
            return false;
          for (var l2 = c2; l2--; ) {
            var d2 = a2[l2];
            if (!(s2 ? d2 in e2 : Ar.call(e2, d2)))
              return false;
          }
          var u2 = r2.get(t2);
          if (u2 && r2.get(e2))
            return u2 == e2;
          var h2 = true;
          r2.set(t2, e2), r2.set(e2, t2);
          for (var f2 = s2; ++l2 < c2; ) {
            var m2 = t2[d2 = a2[l2]], g2 = e2[d2];
            if (i2)
              var p2 = s2 ? i2(g2, m2, d2, e2, t2, r2) : i2(m2, g2, d2, t2, e2, r2);
            if (!(void 0 === p2 ? m2 === g2 || o2(m2, g2, n2, i2, r2) : p2)) {
              h2 = false;
              break;
            }
            f2 || (f2 = "constructor" == d2);
          }
          if (h2 && !f2) {
            var b2 = t2.constructor, w2 = e2.constructor;
            b2 == w2 || !("constructor" in t2) || !("constructor" in e2) || "function" == typeof b2 && b2 instanceof b2 && "function" == typeof w2 && w2 instanceof w2 || (h2 = false);
          }
          return r2.delete(t2), r2.delete(e2), h2;
        }, Cr = Object.prototype.hasOwnProperty;
        var Pr = function(t2, e2, n2, i2, o2, r2) {
          var s2 = Dt(t2), a2 = Dt(e2), c2 = s2 ? "[object Array]" : Ie(t2), l2 = a2 ? "[object Array]" : Ie(e2), d2 = "[object Object]" == (c2 = "[object Arguments]" == c2 ? "[object Object]" : c2), u2 = "[object Object]" == (l2 = "[object Arguments]" == l2 ? "[object Object]" : l2), h2 = c2 == l2;
          if (h2 && Object(Lt.a)(t2)) {
            if (!Object(Lt.a)(e2))
              return false;
            s2 = true, d2 = false;
          }
          if (h2 && !d2)
            return r2 || (r2 = new yt()), s2 || Wt(t2) ? wr(t2, e2, n2, i2, o2, r2) : xr(t2, e2, c2, n2, i2, o2, r2);
          if (!(1 & n2)) {
            var f2 = d2 && Cr.call(t2, "__wrapped__"), m2 = u2 && Cr.call(e2, "__wrapped__");
            if (f2 || m2) {
              var g2 = f2 ? t2.value() : t2, p2 = m2 ? e2.value() : e2;
              return r2 || (r2 = new yt()), o2(g2, p2, n2, i2, r2);
            }
          }
          return !!h2 && (r2 || (r2 = new yt()), Tr(t2, e2, n2, i2, o2, r2));
        };
        var Sr = function t2(e2, n2, i2, o2, r2) {
          return e2 === n2 || (null == e2 || null == n2 || !p(e2) && !p(n2) ? e2 != e2 && n2 != n2 : Pr(e2, n2, i2, o2, t2, r2));
        };
        var Mr = function(t2, e2, n2) {
          var i2 = (n2 = "function" == typeof n2 ? n2 : void 0) ? n2(t2, e2) : void 0;
          return void 0 === i2 ? Sr(t2, e2, void 0, n2) : !!i2;
        };
        class Er extends ur {
          constructor(t2) {
            super(t2), this._config = { childList: true, characterData: true, characterDataOldValue: true, subtree: true }, this.domConverter = t2.domConverter, this.renderer = t2._renderer, this._domElements = [], this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
          }
          flush() {
            this._onMutations(this._mutationObserver.takeRecords());
          }
          observe(t2) {
            this._domElements.push(t2), this.isEnabled && this._mutationObserver.observe(t2, this._config);
          }
          enable() {
            super.enable();
            for (const t2 of this._domElements)
              this._mutationObserver.observe(t2, this._config);
          }
          disable() {
            super.disable(), this._mutationObserver.disconnect();
          }
          destroy() {
            super.destroy(), this._mutationObserver.disconnect();
          }
          _onMutations(t2) {
            if (0 === t2.length)
              return;
            const e2 = this.domConverter, n2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Set();
            for (const n3 of t2)
              if ("childList" === n3.type) {
                const t3 = e2.mapDomToView(n3.target);
                if (t3 && t3.is("uiElement"))
                  continue;
                t3 && !this._isBogusBrMutation(n3) && i2.add(t3);
              }
            for (const o3 of t2) {
              const t3 = e2.mapDomToView(o3.target);
              if ((!t3 || !t3.is("uiElement")) && "characterData" === o3.type) {
                const t4 = e2.findCorrespondingViewText(o3.target);
                t4 && !i2.has(t4.parent) ? n2.set(t4, { type: "text", oldText: t4.data, newText: Bo(o3.target), node: t4 }) : !t4 && Vo(o3.target) && i2.add(e2.mapDomToView(o3.target.parentNode));
              }
            }
            const o2 = [];
            for (const t3 of n2.values())
              this.renderer.markToSync("text", t3.node), o2.push(t3);
            for (const t3 of i2) {
              const n3 = e2.mapViewToDom(t3), i3 = Array.from(t3.getChildren()), r3 = Array.from(e2.domChildrenToView(n3, { withChildren: false }));
              Mr(i3, r3, a2) || (this.renderer.markToSync("children", t3), o2.push({ type: "children", oldChildren: i3, newChildren: r3, node: t3 }));
            }
            const r2 = t2[0].target.ownerDocument.getSelection();
            let s2 = null;
            if (r2 && r2.anchorNode) {
              const t3 = e2.domPositionToView(r2.anchorNode, r2.anchorOffset), n3 = e2.domPositionToView(r2.focusNode, r2.focusOffset);
              t3 && n3 && (s2 = new no(t3), s2.setFocus(n3));
            }
            function a2(t3, e3) {
              if (!Array.isArray(t3))
                return t3 === e3 || !(!t3.is("text") || !e3.is("text")) && t3.data === e3.data;
            }
            o2.length && (this.document.fire("mutations", o2, s2), this.view.forceRender());
          }
          _isBogusBrMutation(t2) {
            let e2 = null;
            return null === t2.nextSibling && 0 === t2.removedNodes.length && 1 == t2.addedNodes.length && (e2 = this.domConverter.domToView(t2.addedNodes[0], { withChildren: false })), e2 && e2.is("element", "br");
          }
        }
        class Ir {
          constructor(t2, e2, n2) {
            this.view = t2, this.document = t2.document, this.domEvent = e2, this.domTarget = e2.target, ji(this, n2);
          }
          get target() {
            return this.view.domConverter.mapDomToView(this.domTarget);
          }
          preventDefault() {
            this.domEvent.preventDefault();
          }
          stopPropagation() {
            this.domEvent.stopPropagation();
          }
        }
        class Nr extends ur {
          constructor(t2) {
            super(t2), this.useCapture = false;
          }
          observe(t2) {
            ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e2) => {
              this.listenTo(t2, e2, (t3, e3) => {
                this.isEnabled && this.onDomEvent(e3);
              }, { useCapture: this.useCapture });
            });
          }
          fire(t2, e2, n2) {
            this.isEnabled && this.document.fire(t2, new Ir(this.view, e2, n2));
          }
        }
        class Or extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = ["keydown", "keyup"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2, { keyCode: t2.keyCode, altKey: t2.altKey, ctrlKey: t2.ctrlKey || t2.metaKey, shiftKey: t2.shiftKey, get keystroke() {
              return po(this);
            } });
          }
        }
        var Rr = function() {
          return i.a.Date.now();
        }, Dr = /^\s+|\s+$/g, Lr = /^[-+]0x[0-9a-f]+$/i, jr = /^0b[01]+$/i, Vr = /^0o[0-7]+$/i, zr = parseInt;
        var Br = function(t2) {
          if ("number" == typeof t2)
            return t2;
          if (zn(t2))
            return NaN;
          if (j(t2)) {
            var e2 = "function" == typeof t2.valueOf ? t2.valueOf() : t2;
            t2 = j(e2) ? e2 + "" : e2;
          }
          if ("string" != typeof t2)
            return 0 === t2 ? t2 : +t2;
          t2 = t2.replace(Dr, "");
          var n2 = jr.test(t2);
          return n2 || Vr.test(t2) ? zr(t2.slice(2), n2 ? 2 : 8) : Lr.test(t2) ? NaN : +t2;
        }, Fr = Math.max, Ur = Math.min;
        var Hr = function(t2, e2, n2) {
          var i2, o2, r2, s2, a2, c2, l2 = 0, d2 = false, u2 = false, h2 = true;
          if ("function" != typeof t2)
            throw new TypeError("Expected a function");
          function f2(e3) {
            var n3 = i2, r3 = o2;
            return i2 = o2 = void 0, l2 = e3, s2 = t2.apply(r3, n3);
          }
          function m2(t3) {
            return l2 = t3, a2 = setTimeout(p2, e2), d2 ? f2(t3) : s2;
          }
          function g2(t3) {
            var n3 = t3 - c2;
            return void 0 === c2 || n3 >= e2 || n3 < 0 || u2 && t3 - l2 >= r2;
          }
          function p2() {
            var t3 = Rr();
            if (g2(t3))
              return b2(t3);
            a2 = setTimeout(p2, function(t4) {
              var n3 = e2 - (t4 - c2);
              return u2 ? Ur(n3, r2 - (t4 - l2)) : n3;
            }(t3));
          }
          function b2(t3) {
            return a2 = void 0, h2 && i2 ? f2(t3) : (i2 = o2 = void 0, s2);
          }
          function w2() {
            var t3 = Rr(), n3 = g2(t3);
            if (i2 = arguments, o2 = this, c2 = t3, n3) {
              if (void 0 === a2)
                return m2(c2);
              if (u2)
                return clearTimeout(a2), a2 = setTimeout(p2, e2), f2(c2);
            }
            return void 0 === a2 && (a2 = setTimeout(p2, e2)), s2;
          }
          return e2 = Br(e2) || 0, j(n2) && (d2 = !!n2.leading, r2 = (u2 = "maxWait" in n2) ? Fr(Br(n2.maxWait) || 0, e2) : r2, h2 = "trailing" in n2 ? !!n2.trailing : h2), w2.cancel = function() {
            void 0 !== a2 && clearTimeout(a2), l2 = 0, i2 = c2 = o2 = a2 = void 0;
          }, w2.flush = function() {
            return void 0 === a2 ? s2 : b2(Rr());
          }, w2;
        };
        class qr extends ur {
          constructor(t2) {
            super(t2), this._fireSelectionChangeDoneDebounced = Hr((t3) => this.document.fire("selectionChangeDone", t3), 200);
          }
          observe() {
            const t2 = this.document;
            t2.on("keydown", (e2, n2) => {
              var i2;
              t2.selection.isFake && ((i2 = n2.keyCode) == go.arrowright || i2 == go.arrowleft || i2 == go.arrowup || i2 == go.arrowdown) && this.isEnabled && (n2.preventDefault(), this._handleSelectionMove(n2.keyCode));
            }, { priority: "lowest" });
          }
          destroy() {
            super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionMove(t2) {
            const e2 = this.document.selection, n2 = new no(e2.getRanges(), { backward: e2.isBackward, fake: false });
            t2 != go.arrowleft && t2 != go.arrowup || n2.setTo(n2.getFirstPosition()), t2 != go.arrowright && t2 != go.arrowdown || n2.setTo(n2.getLastPosition());
            const i2 = { oldSelection: e2, newSelection: n2, domSelection: null };
            this.document.fire("selectionChange", i2), this._fireSelectionChangeDoneDebounced(i2);
          }
        }
        class Wr extends ur {
          constructor(t2) {
            super(t2), this.mutationObserver = t2.getObserver(Er), this.selection = this.document.selection, this.domConverter = t2.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Hr((t3) => this.document.fire("selectionChangeDone", t3), 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._loopbackCounter = 0;
          }
          observe(t2) {
            const e2 = t2.ownerDocument;
            this._documents.has(e2) || (this.listenTo(e2, "selectionchange", () => {
              this._handleSelectionChange(e2);
            }), this._documents.add(e2));
          }
          destroy() {
            super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionChange(t2) {
            if (!this.isEnabled)
              return;
            this.mutationObserver.flush();
            const e2 = t2.defaultView.getSelection(), n2 = this.domConverter.domSelectionToView(e2);
            if (0 != n2.rangeCount) {
              if (this.view.hasDomSelection = true, !(this.selection.isEqual(n2) && this.domConverter.isDomSelectionCorrect(e2) || ++this._loopbackCounter > 60))
                if (this.selection.isSimilar(n2))
                  this.view.forceRender();
                else {
                  const t3 = { oldSelection: this.selection, newSelection: n2, domSelection: e2 };
                  this.document.fire("selectionChange", t3), this._fireSelectionChangeDoneDebounced(t3);
                }
            } else
              this.view.hasDomSelection = false;
          }
          _clearInfiniteLoop() {
            this._loopbackCounter = 0;
          }
        }
        class Yr extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = ["focus", "blur"], this.useCapture = true;
            const e2 = this.document;
            e2.on("focus", () => {
              e2.isFocused = true, this._renderTimeoutId = setTimeout(() => t2.forceRender(), 50);
            }), e2.on("blur", (n2, i2) => {
              const o2 = e2.selection.editableElement;
              null !== o2 && o2 !== i2.target || (e2.isFocused = false, t2.forceRender());
            });
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
          destroy() {
            this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
          }
        }
        class Gr extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
            const e2 = this.document;
            e2.on("compositionstart", () => {
              e2.isComposing = true;
            }), e2.on("compositionend", () => {
              e2.isComposing = false;
            });
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        class $r extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = ["beforeinput"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        function Qr(t2) {
          return "[object Range]" == Object.prototype.toString.apply(t2);
        }
        function Kr(t2) {
          const e2 = t2.ownerDocument.defaultView.getComputedStyle(t2);
          return { top: parseInt(e2.borderTopWidth, 10), right: parseInt(e2.borderRightWidth, 10), bottom: parseInt(e2.borderBottomWidth, 10), left: parseInt(e2.borderLeftWidth, 10) };
        }
        const Jr = ["top", "right", "bottom", "left", "width", "height"];
        class Zr {
          constructor(t2) {
            const e2 = Qr(t2);
            if (Object.defineProperty(this, "_source", { value: t2._source || t2, writable: true, enumerable: false }), nn(t2) || e2)
              Xr(this, e2 ? Zr.getDomRangeRects(t2)[0] : t2.getBoundingClientRect());
            else if (ar(t2)) {
              const { innerWidth: e3, innerHeight: n2 } = t2;
              Xr(this, { top: 0, right: e3, bottom: n2, left: 0, width: e3, height: n2 });
            } else
              Xr(this, t2);
          }
          clone() {
            return new Zr(this);
          }
          moveTo(t2, e2) {
            return this.top = e2, this.right = t2 + this.width, this.bottom = e2 + this.height, this.left = t2, this;
          }
          moveBy(t2, e2) {
            return this.top += e2, this.right += t2, this.left += t2, this.bottom += e2, this;
          }
          getIntersection(t2) {
            const e2 = { top: Math.max(this.top, t2.top), right: Math.min(this.right, t2.right), bottom: Math.min(this.bottom, t2.bottom), left: Math.max(this.left, t2.left) };
            return e2.width = e2.right - e2.left, e2.height = e2.bottom - e2.top, e2.width < 0 || e2.height < 0 ? null : new Zr(e2);
          }
          getIntersectionArea(t2) {
            const e2 = this.getIntersection(t2);
            return e2 ? e2.getArea() : 0;
          }
          getArea() {
            return this.width * this.height;
          }
          getVisible() {
            const t2 = this._source;
            let e2 = this.clone();
            if (!ts(t2)) {
              let n2 = t2.parentNode || t2.commonAncestorContainer;
              for (; n2 && !ts(n2); ) {
                const t3 = new Zr(n2), i2 = e2.getIntersection(t3);
                if (!i2)
                  return null;
                i2.getArea() < e2.getArea() && (e2 = i2), n2 = n2.parentNode;
              }
            }
            return e2;
          }
          isEqual(t2) {
            for (const e2 of Jr)
              if (this[e2] !== t2[e2])
                return false;
            return true;
          }
          contains(t2) {
            const e2 = this.getIntersection(t2);
            return !(!e2 || !e2.isEqual(t2));
          }
          excludeScrollbarsAndBorders() {
            const t2 = this._source;
            let e2, n2, i2;
            if (ar(t2))
              e2 = t2.innerWidth - t2.document.documentElement.clientWidth, n2 = t2.innerHeight - t2.document.documentElement.clientHeight, i2 = t2.getComputedStyle(t2.document.documentElement).direction;
            else {
              const o2 = Kr(this._source);
              e2 = t2.offsetWidth - t2.clientWidth - o2.left - o2.right, n2 = t2.offsetHeight - t2.clientHeight - o2.top - o2.bottom, i2 = t2.ownerDocument.defaultView.getComputedStyle(t2).direction, this.left += o2.left, this.top += o2.top, this.right -= o2.right, this.bottom -= o2.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
            }
            return this.width -= e2, "ltr" === i2 ? this.right -= e2 : this.left += e2, this.height -= n2, this.bottom -= n2, this;
          }
          static getDomRangeRects(t2) {
            const e2 = [], n2 = Array.from(t2.getClientRects());
            if (n2.length)
              for (const t3 of n2)
                e2.push(new Zr(t3));
            else {
              let n3 = t2.startContainer;
              Ro(n3) && (n3 = n3.parentNode);
              const i2 = new Zr(n3.getBoundingClientRect());
              i2.right = i2.left, i2.width = 0, e2.push(i2);
            }
            return e2;
          }
        }
        function Xr(t2, e2) {
          for (const n2 of Jr)
            t2[n2] = e2[n2];
        }
        function ts(t2) {
          return !!nn(t2) && t2 === t2.ownerDocument.body;
        }
        function es({ target: t2, viewportOffset: e2 = 0 }) {
          const n2 = cs(t2);
          let i2 = n2, o2 = null;
          for (; i2; ) {
            let r2;
            r2 = ls(i2 == n2 ? t2 : o2), is(r2, () => ds(t2, i2));
            const s2 = ds(t2, i2);
            if (ns(i2, s2, e2), i2.parent != i2) {
              if (o2 = i2.frameElement, i2 = i2.parent, !o2)
                return;
            } else
              i2 = null;
          }
        }
        function ns(t2, e2, n2) {
          const i2 = e2.clone().moveBy(0, n2), o2 = e2.clone().moveBy(0, -n2), r2 = new Zr(t2).excludeScrollbarsAndBorders();
          if (![o2, i2].every((t3) => r2.contains(t3))) {
            let { scrollX: s2, scrollY: a2 } = t2;
            rs(o2, r2) ? a2 -= r2.top - e2.top + n2 : os(i2, r2) && (a2 += e2.bottom - r2.bottom + n2), ss(e2, r2) ? s2 -= r2.left - e2.left + n2 : as(e2, r2) && (s2 += e2.right - r2.right + n2), t2.scrollTo(s2, a2);
          }
        }
        function is(t2, e2) {
          const n2 = cs(t2);
          let i2, o2;
          for (; t2 != n2.document.body; )
            o2 = e2(), i2 = new Zr(t2).excludeScrollbarsAndBorders(), i2.contains(o2) || (rs(o2, i2) ? t2.scrollTop -= i2.top - o2.top : os(o2, i2) && (t2.scrollTop += o2.bottom - i2.bottom), ss(o2, i2) ? t2.scrollLeft -= i2.left - o2.left : as(o2, i2) && (t2.scrollLeft += o2.right - i2.right)), t2 = t2.parentNode;
        }
        function os(t2, e2) {
          return t2.bottom > e2.bottom;
        }
        function rs(t2, e2) {
          return t2.top < e2.top;
        }
        function ss(t2, e2) {
          return t2.left < e2.left;
        }
        function as(t2, e2) {
          return t2.right > e2.right;
        }
        function cs(t2) {
          return Qr(t2) ? t2.startContainer.ownerDocument.defaultView : t2.ownerDocument.defaultView;
        }
        function ls(t2) {
          if (Qr(t2)) {
            let e2 = t2.commonAncestorContainer;
            return Ro(e2) && (e2 = e2.parentNode), e2;
          }
          return t2.parentNode;
        }
        function ds(t2, e2) {
          const n2 = cs(t2), i2 = new Zr(t2);
          if (n2 === e2)
            return i2;
          {
            let t3 = n2;
            for (; t3 != e2; ) {
              const e3 = t3.frameElement, n3 = new Zr(e3).excludeScrollbarsAndBorders();
              i2.moveBy(n3.left, n3.top), t3 = t3.parent;
            }
          }
          return i2;
        }
        Object.assign({}, { scrollViewportToShowTarget: es, scrollAncestorsToShowTarget: function(t2) {
          is(ls(t2), () => new Zr(t2));
        } });
        class us {
          constructor(t2) {
            this.document = new oo(t2), this.domConverter = new ir(this.document), this.domRoots = /* @__PURE__ */ new Map(), this.set("isRenderingInProgress", false), this.set("hasDomSelection", false), this._renderer = new Qo(this.domConverter, this.document.selection), this._renderer.bind("isFocused").to(this.document), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = false, this._postFixersInProgress = false, this._renderingDisabled = false, this._hasChangedSinceTheLastRendering = false, this._writer = new Ao(this.document), this.addObserver(Er), this.addObserver(Wr), this.addObserver(Yr), this.addObserver(Or), this.addObserver(qr), this.addObserver(Gr), ho.isAndroid && this.addObserver($r), this.document.on("keydown", Fo), vo(this), this.on("render", () => {
              this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = false;
            }), this.listenTo(this.document.selection, "change", () => {
              this._hasChangedSinceTheLastRendering = true;
            });
          }
          attachDomRoot(t2, e2 = "main") {
            const n2 = this.document.getRoot(e2);
            n2._name = t2.tagName.toLowerCase();
            const i2 = {};
            for (const { name: e3, value: o3 } of Array.from(t2.attributes))
              i2[e3] = o3, "class" === e3 ? this._writer.addClass(o3.split(" "), n2) : this._writer.setAttribute(e3, o3, n2);
            this._initialDomRootAttributes.set(t2, i2);
            const o2 = () => {
              this._writer.setAttribute("contenteditable", !n2.isReadOnly, n2), n2.isReadOnly ? this._writer.addClass("ck-read-only", n2) : this._writer.removeClass("ck-read-only", n2);
            };
            o2(), this.domRoots.set(e2, t2), this.domConverter.bindElements(t2, n2), this._renderer.markToSync("children", n2), this._renderer.markToSync("attributes", n2), this._renderer.domDocuments.add(t2.ownerDocument), n2.on("change:children", (t3, e3) => this._renderer.markToSync("children", e3)), n2.on("change:attributes", (t3, e3) => this._renderer.markToSync("attributes", e3)), n2.on("change:text", (t3, e3) => this._renderer.markToSync("text", e3)), n2.on("change:isReadOnly", () => this.change(o2)), n2.on("change", () => {
              this._hasChangedSinceTheLastRendering = true;
            });
            for (const n3 of this._observers.values())
              n3.observe(t2, e2);
          }
          detachDomRoot(t2) {
            const e2 = this.domRoots.get(t2);
            Array.from(e2.attributes).forEach(({ name: t3 }) => e2.removeAttribute(t3));
            const n2 = this._initialDomRootAttributes.get(e2);
            for (const t3 in n2)
              e2.setAttribute(t3, n2[t3]);
            this.domRoots.delete(t2), this.domConverter.unbindDomElement(e2);
          }
          getDomRoot(t2 = "main") {
            return this.domRoots.get(t2);
          }
          addObserver(t2) {
            let e2 = this._observers.get(t2);
            if (e2)
              return e2;
            e2 = new t2(this), this._observers.set(t2, e2);
            for (const [t3, n2] of this.domRoots)
              e2.observe(n2, t3);
            return e2.enable(), e2;
          }
          getObserver(t2) {
            return this._observers.get(t2);
          }
          disableObservers() {
            for (const t2 of this._observers.values())
              t2.disable();
          }
          enableObservers() {
            for (const t2 of this._observers.values())
              t2.enable();
          }
          scrollToTheSelection() {
            const t2 = this.document.selection.getFirstRange();
            t2 && es({ target: this.domConverter.viewRangeToDom(t2), viewportOffset: 20 });
          }
          focus() {
            if (!this.document.isFocused) {
              const t2 = this.document.selection.editableElement;
              t2 && (this.domConverter.focus(t2), this.forceRender());
            }
          }
          change(t2) {
            if (this.isRenderingInProgress || this._postFixersInProgress)
              throw new hn.b("cannot-change-view-tree: Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. This may cause some unexpected behavior and inconsistency between the DOM and the view.", this);
            try {
              if (this._ongoingChange)
                return t2(this._writer);
              this._ongoingChange = true;
              const e2 = t2(this._writer);
              return this._ongoingChange = false, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = true, this.document._callPostFixers(this._writer), this._postFixersInProgress = false, this.fire("render")), e2;
            } catch (t3) {
              hn.b.rethrowUnexpectedError(t3, this);
            }
          }
          forceRender() {
            this._hasChangedSinceTheLastRendering = true, this.change(() => {
            });
          }
          destroy() {
            for (const t2 of this._observers.values())
              t2.destroy();
            this.document.destroy(), this.stopListening();
          }
          createPositionAt(t2, e2) {
            return Zi._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return Zi._createAfter(t2);
          }
          createPositionBefore(t2) {
            return Zi._createBefore(t2);
          }
          createRange(t2, e2) {
            return new Xi(t2, e2);
          }
          createRangeOn(t2) {
            return Xi._createOn(t2);
          }
          createRangeIn(t2) {
            return Xi._createIn(t2);
          }
          createSelection(t2, e2, n2) {
            return new no(t2, e2, n2);
          }
          _disableRendering(t2) {
            this._renderingDisabled = t2, 0 == t2 && this.change(() => {
            });
          }
          _render() {
            this.isRenderingInProgress = true, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = false;
          }
        }
        xn(us, Ui);
        class hs {
          constructor(t2) {
            this.parent = null, this._attrs = Ln(t2);
          }
          get index() {
            let t2;
            if (!this.parent)
              return null;
            if (null === (t2 = this.parent.getChildIndex(this)))
              throw new hn.b("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t2;
          }
          get startOffset() {
            let t2;
            if (!this.parent)
              return null;
            if (null === (t2 = this.parent.getChildStartOffset(this)))
              throw new hn.b("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t2;
          }
          get offsetSize() {
            return 1;
          }
          get endOffset() {
            return this.parent ? this.startOffset + this.offsetSize : null;
          }
          get nextSibling() {
            const t2 = this.index;
            return null !== t2 && this.parent.getChild(t2 + 1) || null;
          }
          get previousSibling() {
            const t2 = this.index;
            return null !== t2 && this.parent.getChild(t2 - 1) || null;
          }
          get root() {
            let t2 = this;
            for (; t2.parent; )
              t2 = t2.parent;
            return t2;
          }
          isAttached() {
            return this.root.is("rootElement");
          }
          getPath() {
            const t2 = [];
            let e2 = this;
            for (; e2.parent; )
              t2.unshift(e2.startOffset), e2 = e2.parent;
            return t2;
          }
          getAncestors(t2 = { includeSelf: false, parentFirst: false }) {
            const e2 = [];
            let n2 = t2.includeSelf ? this : this.parent;
            for (; n2; )
              e2[t2.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
            return e2;
          }
          getCommonAncestor(t2, e2 = {}) {
            const n2 = this.getAncestors(e2), i2 = t2.getAncestors(e2);
            let o2 = 0;
            for (; n2[o2] == i2[o2] && n2[o2]; )
              o2++;
            return 0 === o2 ? null : n2[o2 - 1];
          }
          isBefore(t2) {
            if (this == t2)
              return false;
            if (this.root !== t2.root)
              return false;
            const e2 = this.getPath(), n2 = t2.getPath(), i2 = In(e2, n2);
            switch (i2) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e2[i2] < n2[i2];
            }
          }
          isAfter(t2) {
            return this != t2 && (this.root === t2.root && !this.isBefore(t2));
          }
          hasAttribute(t2) {
            return this._attrs.has(t2);
          }
          getAttribute(t2) {
            return this._attrs.get(t2);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          toJSON() {
            const t2 = {};
            return this._attrs.size && (t2.attributes = Array.from(this._attrs).reduce((t3, e2) => (t3[e2[0]] = e2[1], t3), {})), t2;
          }
          is(t2) {
            return "node" === t2 || "model:node" === t2;
          }
          _clone() {
            return new hs(this._attrs);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _setAttribute(t2, e2) {
            this._attrs.set(t2, e2);
          }
          _setAttributesTo(t2) {
            this._attrs = Ln(t2);
          }
          _removeAttribute(t2) {
            return this._attrs.delete(t2);
          }
          _clearAttributes() {
            this._attrs.clear();
          }
        }
        class fs extends hs {
          constructor(t2, e2) {
            super(e2), this._data = t2 || "";
          }
          get offsetSize() {
            return this.data.length;
          }
          get data() {
            return this._data;
          }
          is(t2) {
            return "text" === t2 || "model:text" === t2 || "node" === t2 || "model:node" === t2;
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.data = this.data, t2;
          }
          _clone() {
            return new fs(this.data, this.getAttributes());
          }
          static fromJSON(t2) {
            return new fs(t2.data, t2.attributes);
          }
        }
        class ms {
          constructor(t2, e2, n2) {
            if (this.textNode = t2, e2 < 0 || e2 > t2.offsetSize)
              throw new hn.b("model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this);
            if (n2 < 0 || e2 + n2 > t2.offsetSize)
              throw new hn.b("model-textproxy-wrong-length: Given length value is incorrect.", this);
            this.data = t2.data.substring(e2, e2 + n2), this.offsetInText = e2;
          }
          get startOffset() {
            return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
          }
          get offsetSize() {
            return this.data.length;
          }
          get endOffset() {
            return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
          }
          get isPartial() {
            return this.offsetSize !== this.textNode.offsetSize;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          is(t2) {
            return "textProxy" === t2 || "model:textProxy" === t2;
          }
          getPath() {
            const t2 = this.textNode.getPath();
            return t2.length > 0 && (t2[t2.length - 1] += this.offsetInText), t2;
          }
          getAncestors(t2 = { includeSelf: false, parentFirst: false }) {
            const e2 = [];
            let n2 = t2.includeSelf ? this : this.parent;
            for (; n2; )
              e2[t2.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
            return e2;
          }
          hasAttribute(t2) {
            return this.textNode.hasAttribute(t2);
          }
          getAttribute(t2) {
            return this.textNode.getAttribute(t2);
          }
          getAttributes() {
            return this.textNode.getAttributes();
          }
          getAttributeKeys() {
            return this.textNode.getAttributeKeys();
          }
        }
        class gs {
          constructor(t2) {
            this._nodes = [], t2 && this._insertNodes(0, t2);
          }
          [Symbol.iterator]() {
            return this._nodes[Symbol.iterator]();
          }
          get length() {
            return this._nodes.length;
          }
          get maxOffset() {
            return this._nodes.reduce((t2, e2) => t2 + e2.offsetSize, 0);
          }
          getNode(t2) {
            return this._nodes[t2] || null;
          }
          getNodeIndex(t2) {
            const e2 = this._nodes.indexOf(t2);
            return -1 == e2 ? null : e2;
          }
          getNodeStartOffset(t2) {
            const e2 = this.getNodeIndex(t2);
            return null === e2 ? null : this._nodes.slice(0, e2).reduce((t3, e3) => t3 + e3.offsetSize, 0);
          }
          indexToOffset(t2) {
            if (t2 == this._nodes.length)
              return this.maxOffset;
            const e2 = this._nodes[t2];
            if (!e2)
              throw new hn.b("model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.", this);
            return this.getNodeStartOffset(e2);
          }
          offsetToIndex(t2) {
            let e2 = 0;
            for (const n2 of this._nodes) {
              if (t2 >= e2 && t2 < e2 + n2.offsetSize)
                return this.getNodeIndex(n2);
              e2 += n2.offsetSize;
            }
            if (e2 != t2)
              throw new hn.b("model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.", this, { offset: t2, nodeList: this });
            return this.length;
          }
          _insertNodes(t2, e2) {
            for (const t3 of e2)
              if (!(t3 instanceof hs))
                throw new hn.b("model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.", this);
            this._nodes.splice(t2, 0, ...e2);
          }
          _removeNodes(t2, e2 = 1) {
            return this._nodes.splice(t2, e2);
          }
          toJSON() {
            return this._nodes.map((t2) => t2.toJSON());
          }
        }
        class ps extends hs {
          constructor(t2, e2, n2) {
            super(e2), this.name = t2, this._children = new gs(), n2 && this._insertChild(0, n2);
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          is(t2, e2 = null) {
            return e2 ? e2 === this.name && ("element" === t2 || "model:element" === t2) : "element" === t2 || "model:element" === t2 || t2 === this.name || t2 === "model:" + this.name || "node" === t2 || "model:node" === t2;
          }
          getChild(t2) {
            return this._children.getNode(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t2) {
            return this._children.getNodeIndex(t2);
          }
          getChildStartOffset(t2) {
            return this._children.getNodeStartOffset(t2);
          }
          offsetToIndex(t2) {
            return this._children.offsetToIndex(t2);
          }
          getNodeByPath(t2) {
            let e2 = this;
            for (const n2 of t2)
              e2 = e2.getChild(e2.offsetToIndex(n2));
            return e2;
          }
          toJSON() {
            const t2 = super.toJSON();
            if (t2.name = this.name, this._children.length > 0) {
              t2.children = [];
              for (const e2 of this._children)
                t2.children.push(e2.toJSON());
            }
            return t2;
          }
          _clone(t2 = false) {
            const e2 = t2 ? Array.from(this._children).map((t3) => t3._clone(true)) : null;
            return new ps(this.name, this.getAttributes(), e2);
          }
          _appendChild(t2) {
            this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            const n2 = function(t3) {
              if ("string" == typeof t3)
                return [new fs(t3)];
              yn(t3) || (t3 = [t3]);
              return Array.from(t3).map((t4) => "string" == typeof t4 ? new fs(t4) : t4 instanceof ms ? new fs(t4.data, t4.getAttributes()) : t4);
            }(e2);
            for (const t3 of n2)
              null !== t3.parent && t3._remove(), t3.parent = this;
            this._children._insertNodes(t2, n2);
          }
          _removeChildren(t2, e2 = 1) {
            const n2 = this._children._removeNodes(t2, e2);
            for (const t3 of n2)
              t3.parent = null;
            return n2;
          }
          static fromJSON(t2) {
            let e2 = null;
            if (t2.children) {
              e2 = [];
              for (const n2 of t2.children)
                n2.name ? e2.push(ps.fromJSON(n2)) : e2.push(fs.fromJSON(n2));
            }
            return new ps(t2.name, t2.attributes, e2);
          }
        }
        class bs {
          constructor(t2 = {}) {
            if (!t2.boundaries && !t2.startPosition)
              throw new hn.b("model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null);
            const e2 = t2.direction || "forward";
            if ("forward" != e2 && "backward" != e2)
              throw new hn.b("model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t2, { direction: e2 });
            this.direction = e2, this.boundaries = t2.boundaries || null, t2.startPosition ? this.position = t2.startPosition.clone() : this.position = ks._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t2.singleCharacters, this.shallow = !!t2.shallow, this.ignoreElementEnd = !!t2.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t2) {
            let e2, n2, i2, o2;
            do {
              i2 = this.position, o2 = this._visitedParent, { done: e2, value: n2 } = this.next();
            } while (!e2 && t2(n2));
            e2 || (this.position = i2, this._visitedParent = o2);
          }
          next() {
            return "forward" == this.direction ? this._next() : this._previous();
          }
          _next() {
            const t2 = this.position, e2 = this.position.clone(), n2 = this._visitedParent;
            if (null === n2.parent && e2.offset === n2.maxOffset)
              return { done: true };
            if (n2 === this._boundaryEndParent && e2.offset == this.boundaries.end.offset)
              return { done: true };
            const i2 = e2.parent, o2 = _s(e2, i2), r2 = o2 || vs(e2, i2, o2);
            if (r2 instanceof ps)
              return this.shallow ? e2.offset++ : (e2.path.push(0), this._visitedParent = r2), this.position = e2, ws("elementStart", r2, t2, e2, 1);
            if (r2 instanceof fs) {
              let i3;
              if (this.singleCharacters)
                i3 = 1;
              else {
                let t3 = r2.endOffset;
                this._boundaryEndParent == n2 && this.boundaries.end.offset < t3 && (t3 = this.boundaries.end.offset), i3 = t3 - e2.offset;
              }
              const o3 = e2.offset - r2.startOffset, s2 = new ms(r2, o3, i3);
              return e2.offset += i3, this.position = e2, ws("text", s2, t2, e2, i3);
            }
            return e2.path.pop(), e2.offset++, this.position = e2, this._visitedParent = n2.parent, this.ignoreElementEnd ? this._next() : ws("elementEnd", n2, t2, e2);
          }
          _previous() {
            const t2 = this.position, e2 = this.position.clone(), n2 = this._visitedParent;
            if (null === n2.parent && 0 === e2.offset)
              return { done: true };
            if (n2 == this._boundaryStartParent && e2.offset == this.boundaries.start.offset)
              return { done: true };
            const i2 = e2.parent, o2 = _s(e2, i2), r2 = o2 || ys(e2, i2, o2);
            if (r2 instanceof ps)
              return e2.offset--, this.shallow ? (this.position = e2, ws("elementStart", r2, t2, e2, 1)) : (e2.path.push(r2.maxOffset), this.position = e2, this._visitedParent = r2, this.ignoreElementEnd ? this._previous() : ws("elementEnd", r2, t2, e2));
            if (r2 instanceof fs) {
              let i3;
              if (this.singleCharacters)
                i3 = 1;
              else {
                let t3 = r2.startOffset;
                this._boundaryStartParent == n2 && this.boundaries.start.offset > t3 && (t3 = this.boundaries.start.offset), i3 = e2.offset - t3;
              }
              const o3 = e2.offset - r2.startOffset, s2 = new ms(r2, o3 - i3, i3);
              return e2.offset -= i3, this.position = e2, ws("text", s2, t2, e2, i3);
            }
            return e2.path.pop(), this.position = e2, this._visitedParent = n2.parent, ws("elementStart", n2, t2, e2, 1);
          }
        }
        function ws(t2, e2, n2, i2, o2) {
          return { done: false, value: { type: t2, item: e2, previousPosition: n2, nextPosition: i2, length: o2 } };
        }
        class ks {
          constructor(t2, e2, n2 = "toNone") {
            if (!t2.is("element") && !t2.is("documentFragment"))
              throw new hn.b("model-position-root-invalid: Position root invalid.", t2);
            if (!(e2 instanceof Array) || 0 === e2.length)
              throw new hn.b("model-position-path-incorrect-format: Position path must be an array with at least one item.", t2, { path: e2 });
            t2.is("rootElement") ? e2 = e2.slice() : (e2 = [...t2.getPath(), ...e2], t2 = t2.root), this.root = t2, this.path = e2, this.stickiness = n2;
          }
          get offset() {
            return this.path[this.path.length - 1];
          }
          set offset(t2) {
            this.path[this.path.length - 1] = t2;
          }
          get parent() {
            let t2 = this.root;
            for (let e2 = 0; e2 < this.path.length - 1; e2++)
              if (t2 = t2.getChild(t2.offsetToIndex(this.path[e2])), !t2)
                throw new hn.b("model-position-path-incorrect: The position's path is incorrect.", this, { position: this });
            if (t2.is("text"))
              throw new hn.b("model-position-path-incorrect: The position's path is incorrect.", this, { position: this });
            return t2;
          }
          get index() {
            return this.parent.offsetToIndex(this.offset);
          }
          get textNode() {
            return _s(this, this.parent);
          }
          get nodeAfter() {
            const t2 = this.parent;
            return vs(this, t2, _s(this, t2));
          }
          get nodeBefore() {
            const t2 = this.parent;
            return ys(this, t2, _s(this, t2));
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            return this.offset == this.parent.maxOffset;
          }
          compareWith(t2) {
            if (this.root != t2.root)
              return "different";
            const e2 = In(this.path, t2.path);
            switch (e2) {
              case "same":
                return "same";
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return this.path[e2] < t2.path[e2] ? "before" : "after";
            }
          }
          getLastMatchingPosition(t2, e2 = {}) {
            e2.startPosition = this;
            const n2 = new bs(e2);
            return n2.skip(t2), n2.position;
          }
          getParentPath() {
            return this.path.slice(0, -1);
          }
          getAncestors() {
            const t2 = this.parent;
            return t2.is("documentFragment") ? [t2] : t2.getAncestors({ includeSelf: true });
          }
          getCommonPath(t2) {
            if (this.root != t2.root)
              return [];
            const e2 = In(this.path, t2.path), n2 = "string" == typeof e2 ? Math.min(this.path.length, t2.path.length) : e2;
            return this.path.slice(0, n2);
          }
          getCommonAncestor(t2) {
            const e2 = this.getAncestors(), n2 = t2.getAncestors();
            let i2 = 0;
            for (; e2[i2] == n2[i2] && e2[i2]; )
              i2++;
            return 0 === i2 ? null : e2[i2 - 1];
          }
          getShiftedBy(t2) {
            const e2 = this.clone(), n2 = e2.offset + t2;
            return e2.offset = n2 < 0 ? 0 : n2, e2;
          }
          isAfter(t2) {
            return "after" == this.compareWith(t2);
          }
          isBefore(t2) {
            return "before" == this.compareWith(t2);
          }
          isEqual(t2) {
            return "same" == this.compareWith(t2);
          }
          isTouching(t2) {
            let e2 = null, n2 = null;
            switch (this.compareWith(t2)) {
              case "same":
                return true;
              case "before":
                e2 = ks._createAt(this), n2 = ks._createAt(t2);
                break;
              case "after":
                e2 = ks._createAt(t2), n2 = ks._createAt(this);
                break;
              default:
                return false;
            }
            let i2 = e2.parent;
            for (; e2.path.length + n2.path.length; ) {
              if (e2.isEqual(n2))
                return true;
              if (e2.path.length > n2.path.length) {
                if (e2.offset !== i2.maxOffset)
                  return false;
                e2.path = e2.path.slice(0, -1), i2 = i2.parent, e2.offset++;
              } else {
                if (0 !== n2.offset)
                  return false;
                n2.path = n2.path.slice(0, -1);
              }
            }
          }
          is(t2) {
            return "position" === t2 || "model:position" === t2;
          }
          hasSameParentAs(t2) {
            if (this.root !== t2.root)
              return false;
            return "same" == In(this.getParentPath(), t2.getParentPath());
          }
          getTransformedByOperation(t2) {
            let e2;
            switch (t2.type) {
              case "insert":
                e2 = this._getTransformedByInsertOperation(t2);
                break;
              case "move":
              case "remove":
              case "reinsert":
                e2 = this._getTransformedByMoveOperation(t2);
                break;
              case "split":
                e2 = this._getTransformedBySplitOperation(t2);
                break;
              case "merge":
                e2 = this._getTransformedByMergeOperation(t2);
                break;
              default:
                e2 = ks._createAt(this);
            }
            return e2;
          }
          _getTransformedByInsertOperation(t2) {
            return this._getTransformedByInsertion(t2.position, t2.howMany);
          }
          _getTransformedByMoveOperation(t2) {
            return this._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany);
          }
          _getTransformedBySplitOperation(t2) {
            const e2 = t2.movedRange;
            return e2.containsPosition(this) || e2.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t2.splitPosition, t2.moveTargetPosition) : t2.graveyardPosition ? this._getTransformedByMove(t2.graveyardPosition, t2.insertionPosition, 1) : this._getTransformedByInsertion(t2.insertionPosition, 1);
          }
          _getTransformedByMergeOperation(t2) {
            const e2 = t2.movedRange;
            let n2;
            return e2.containsPosition(this) || e2.start.isEqual(this) ? (n2 = this._getCombined(t2.sourcePosition, t2.targetPosition), t2.sourcePosition.isBefore(t2.targetPosition) && (n2 = n2._getTransformedByDeletion(t2.deletionPosition, 1))) : n2 = this.isEqual(t2.deletionPosition) ? ks._createAt(t2.deletionPosition) : this._getTransformedByMove(t2.deletionPosition, t2.graveyardPosition, 1), n2;
          }
          _getTransformedByDeletion(t2, e2) {
            const n2 = ks._createAt(this);
            if (this.root != t2.root)
              return n2;
            if ("same" == In(t2.getParentPath(), this.getParentPath())) {
              if (t2.offset < this.offset) {
                if (t2.offset + e2 > this.offset)
                  return null;
                n2.offset -= e2;
              }
            } else if ("prefix" == In(t2.getParentPath(), this.getParentPath())) {
              const i2 = t2.path.length - 1;
              if (t2.offset <= this.path[i2]) {
                if (t2.offset + e2 > this.path[i2])
                  return null;
                n2.path[i2] -= e2;
              }
            }
            return n2;
          }
          _getTransformedByInsertion(t2, e2) {
            const n2 = ks._createAt(this);
            if (this.root != t2.root)
              return n2;
            if ("same" == In(t2.getParentPath(), this.getParentPath()))
              (t2.offset < this.offset || t2.offset == this.offset && "toPrevious" != this.stickiness) && (n2.offset += e2);
            else if ("prefix" == In(t2.getParentPath(), this.getParentPath())) {
              const i2 = t2.path.length - 1;
              t2.offset <= this.path[i2] && (n2.path[i2] += e2);
            }
            return n2;
          }
          _getTransformedByMove(t2, e2, n2) {
            if (e2 = e2._getTransformedByDeletion(t2, n2), t2.isEqual(e2))
              return ks._createAt(this);
            const i2 = this._getTransformedByDeletion(t2, n2);
            return null === i2 || t2.isEqual(this) && "toNext" == this.stickiness || t2.getShiftedBy(n2).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t2, e2) : i2._getTransformedByInsertion(e2, n2);
          }
          _getCombined(t2, e2) {
            const n2 = t2.path.length - 1, i2 = ks._createAt(e2);
            return i2.stickiness = this.stickiness, i2.offset = i2.offset + this.path[n2] - t2.offset, i2.path = [...i2.path, ...this.path.slice(n2 + 1)], i2;
          }
          toJSON() {
            return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
          }
          clone() {
            return new this.constructor(this.root, this.path, this.stickiness);
          }
          static _createAt(t2, e2, n2 = "toNone") {
            if (t2 instanceof ks)
              return new ks(t2.root, t2.path, t2.stickiness);
            {
              const i2 = t2;
              if ("end" == e2)
                e2 = i2.maxOffset;
              else {
                if ("before" == e2)
                  return this._createBefore(i2, n2);
                if ("after" == e2)
                  return this._createAfter(i2, n2);
                if (0 !== e2 && !e2)
                  throw new hn.b("model-createPositionAt-offset-required: Model#createPositionAt() requires the offset when the first parameter is a model item.", [this, t2]);
              }
              if (!i2.is("element") && !i2.is("documentFragment"))
                throw new hn.b("model-position-parent-incorrect: Position parent have to be a element or document fragment.", [this, t2]);
              const o2 = i2.getPath();
              return o2.push(e2), new this(i2.root, o2, n2);
            }
          }
          static _createAfter(t2, e2) {
            if (!t2.parent)
              throw new hn.b("model-position-after-root: You cannot make a position after root.", [this, t2], { root: t2 });
            return this._createAt(t2.parent, t2.endOffset, e2);
          }
          static _createBefore(t2, e2) {
            if (!t2.parent)
              throw new hn.b("model-position-before-root: You cannot make a position before root.", t2, { root: t2 });
            return this._createAt(t2.parent, t2.startOffset, e2);
          }
          static fromJSON(t2, e2) {
            if ("$graveyard" === t2.root) {
              const n2 = new ks(e2.graveyard, t2.path);
              return n2.stickiness = t2.stickiness, n2;
            }
            if (!e2.getRoot(t2.root))
              throw new hn.b("model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.", e2, { rootName: t2.root });
            return new ks(e2.getRoot(t2.root), t2.path, t2.stickiness);
          }
        }
        function _s(t2, e2) {
          const n2 = e2.getChild(e2.offsetToIndex(t2.offset));
          return n2 && n2.is("text") && n2.startOffset < t2.offset ? n2 : null;
        }
        function vs(t2, e2, n2) {
          return null !== n2 ? null : e2.getChild(e2.offsetToIndex(t2.offset));
        }
        function ys(t2, e2, n2) {
          return null !== n2 ? null : e2.getChild(e2.offsetToIndex(t2.offset) - 1);
        }
        class xs {
          constructor(t2, e2 = null) {
            this.start = ks._createAt(t2), this.end = e2 ? ks._createAt(e2) : ks._createAt(t2), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
          }
          *[Symbol.iterator]() {
            yield* new bs({ boundaries: this, ignoreElementEnd: true });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return "same" == In(this.start.getParentPath(), this.end.getParentPath());
          }
          get root() {
            return this.start.root;
          }
          containsPosition(t2) {
            return t2.isAfter(this.start) && t2.isBefore(this.end);
          }
          containsRange(t2, e2 = false) {
            t2.isCollapsed && (e2 = false);
            const n2 = this.containsPosition(t2.start) || e2 && this.start.isEqual(t2.start), i2 = this.containsPosition(t2.end) || e2 && this.end.isEqual(t2.end);
            return n2 && i2;
          }
          containsItem(t2) {
            const e2 = ks._createBefore(t2);
            return this.containsPosition(e2) || this.start.isEqual(e2);
          }
          is(t2) {
            return "range" === t2 || "model:range" === t2;
          }
          isEqual(t2) {
            return this.start.isEqual(t2.start) && this.end.isEqual(t2.end);
          }
          isIntersecting(t2) {
            return this.start.isBefore(t2.end) && this.end.isAfter(t2.start);
          }
          getDifference(t2) {
            const e2 = [];
            return this.isIntersecting(t2) ? (this.containsPosition(t2.start) && e2.push(new xs(this.start, t2.start)), this.containsPosition(t2.end) && e2.push(new xs(t2.end, this.end))) : e2.push(new xs(this.start, this.end)), e2;
          }
          getIntersection(t2) {
            if (this.isIntersecting(t2)) {
              let e2 = this.start, n2 = this.end;
              return this.containsPosition(t2.start) && (e2 = t2.start), this.containsPosition(t2.end) && (n2 = t2.end), new xs(e2, n2);
            }
            return null;
          }
          getMinimalFlatRanges() {
            const t2 = [], e2 = this.start.getCommonPath(this.end).length, n2 = ks._createAt(this.start);
            let i2 = n2.parent;
            for (; n2.path.length > e2 + 1; ) {
              const e3 = i2.maxOffset - n2.offset;
              0 !== e3 && t2.push(new xs(n2, n2.getShiftedBy(e3))), n2.path = n2.path.slice(0, -1), n2.offset++, i2 = i2.parent;
            }
            for (; n2.path.length <= this.end.path.length; ) {
              const e3 = this.end.path[n2.path.length - 1], i3 = e3 - n2.offset;
              0 !== i3 && t2.push(new xs(n2, n2.getShiftedBy(i3))), n2.offset = e3, n2.path.push(0);
            }
            return t2;
          }
          getWalker(t2 = {}) {
            return t2.boundaries = this, new bs(t2);
          }
          *getItems(t2 = {}) {
            t2.boundaries = this, t2.ignoreElementEnd = true;
            const e2 = new bs(t2);
            for (const t3 of e2)
              yield t3.item;
          }
          *getPositions(t2 = {}) {
            t2.boundaries = this;
            const e2 = new bs(t2);
            yield e2.position;
            for (const t3 of e2)
              yield t3.nextPosition;
          }
          getTransformedByOperation(t2) {
            switch (t2.type) {
              case "insert":
                return this._getTransformedByInsertOperation(t2);
              case "move":
              case "remove":
              case "reinsert":
                return this._getTransformedByMoveOperation(t2);
              case "split":
                return [this._getTransformedBySplitOperation(t2)];
              case "merge":
                return [this._getTransformedByMergeOperation(t2)];
            }
            return [new xs(this.start, this.end)];
          }
          getTransformedByOperations(t2) {
            const e2 = [new xs(this.start, this.end)];
            for (const n2 of t2)
              for (let t3 = 0; t3 < e2.length; t3++) {
                const i2 = e2[t3].getTransformedByOperation(n2);
                e2.splice(t3, 1, ...i2), t3 += i2.length - 1;
              }
            for (let t3 = 0; t3 < e2.length; t3++) {
              const n2 = e2[t3];
              for (let i2 = t3 + 1; i2 < e2.length; i2++) {
                const t4 = e2[i2];
                (n2.containsRange(t4) || t4.containsRange(n2) || n2.isEqual(t4)) && e2.splice(i2, 1);
              }
            }
            return e2;
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed)
              return null;
            const t2 = this.start.nodeAfter, e2 = this.end.nodeBefore;
            return t2 && t2.is("element") && t2 === e2 ? t2 : null;
          }
          toJSON() {
            return { start: this.start.toJSON(), end: this.end.toJSON() };
          }
          clone() {
            return new this.constructor(this.start, this.end);
          }
          _getTransformedByInsertOperation(t2, e2 = false) {
            return this._getTransformedByInsertion(t2.position, t2.howMany, e2);
          }
          _getTransformedByMoveOperation(t2, e2 = false) {
            const n2 = t2.sourcePosition, i2 = t2.howMany, o2 = t2.targetPosition;
            return this._getTransformedByMove(n2, o2, i2, e2);
          }
          _getTransformedBySplitOperation(t2) {
            const e2 = this.start._getTransformedBySplitOperation(t2);
            let n2 = this.end._getTransformedBySplitOperation(t2);
            return this.end.isEqual(t2.insertionPosition) && (n2 = this.end.getShiftedBy(1)), e2.root != n2.root && (n2 = this.end.getShiftedBy(-1)), new xs(e2, n2);
          }
          _getTransformedByMergeOperation(t2) {
            if (this.start.isEqual(t2.targetPosition) && this.end.isEqual(t2.deletionPosition))
              return new xs(this.start);
            let e2 = this.start._getTransformedByMergeOperation(t2), n2 = this.end._getTransformedByMergeOperation(t2);
            return e2.root != n2.root && (n2 = this.end.getShiftedBy(-1)), e2.isAfter(n2) ? (t2.sourcePosition.isBefore(t2.targetPosition) ? (e2 = ks._createAt(n2), e2.offset = 0) : (t2.deletionPosition.isEqual(e2) || (n2 = t2.deletionPosition), e2 = t2.targetPosition), new xs(e2, n2)) : new xs(e2, n2);
          }
          _getTransformedByInsertion(t2, e2, n2 = false) {
            if (n2 && this.containsPosition(t2))
              return [new xs(this.start, t2), new xs(t2.getShiftedBy(e2), this.end._getTransformedByInsertion(t2, e2))];
            {
              const n3 = new xs(this.start, this.end);
              return n3.start = n3.start._getTransformedByInsertion(t2, e2), n3.end = n3.end._getTransformedByInsertion(t2, e2), [n3];
            }
          }
          _getTransformedByMove(t2, e2, n2, i2 = false) {
            if (this.isCollapsed) {
              const i3 = this.start._getTransformedByMove(t2, e2, n2);
              return [new xs(i3)];
            }
            const o2 = xs._createFromPositionAndShift(t2, n2), r2 = e2._getTransformedByDeletion(t2, n2);
            if (this.containsPosition(e2) && !i2 && (o2.containsPosition(this.start) || o2.containsPosition(this.end))) {
              const i3 = this.start._getTransformedByMove(t2, e2, n2), o3 = this.end._getTransformedByMove(t2, e2, n2);
              return [new xs(i3, o3)];
            }
            let s2;
            const a2 = this.getDifference(o2);
            let c2 = null;
            const l2 = this.getIntersection(o2);
            if (1 == a2.length ? c2 = new xs(a2[0].start._getTransformedByDeletion(t2, n2), a2[0].end._getTransformedByDeletion(t2, n2)) : 2 == a2.length && (c2 = new xs(this.start, this.end._getTransformedByDeletion(t2, n2))), s2 = c2 ? c2._getTransformedByInsertion(r2, n2, null !== l2 || i2) : [], l2) {
              const t3 = new xs(l2.start._getCombined(o2.start, r2), l2.end._getCombined(o2.start, r2));
              2 == s2.length ? s2.splice(1, 0, t3) : s2.push(t3);
            }
            return s2;
          }
          _getTransformedByDeletion(t2, e2) {
            let n2 = this.start._getTransformedByDeletion(t2, e2), i2 = this.end._getTransformedByDeletion(t2, e2);
            return null == n2 && null == i2 ? null : (null == n2 && (n2 = t2), null == i2 && (i2 = t2), new xs(n2, i2));
          }
          static _createFromPositionAndShift(t2, e2) {
            const n2 = t2, i2 = t2.getShiftedBy(e2);
            return e2 > 0 ? new this(n2, i2) : new this(i2, n2);
          }
          static _createIn(t2) {
            return new this(ks._createAt(t2, 0), ks._createAt(t2, t2.maxOffset));
          }
          static _createOn(t2) {
            return this._createFromPositionAndShift(ks._createBefore(t2), t2.offsetSize);
          }
          static _createFromRanges(t2) {
            if (0 === t2.length)
              throw new hn.b("range-create-from-ranges-empty-array: At least one range has to be passed.", null);
            if (1 == t2.length)
              return t2[0].clone();
            const e2 = t2[0];
            t2.sort((t3, e3) => t3.start.isAfter(e3.start) ? 1 : -1);
            const n2 = t2.indexOf(e2), i2 = new this(e2.start, e2.end);
            if (n2 > 0)
              for (let e3 = n2 - 1; t2[e3].end.isEqual(i2.start); e3++)
                i2.start = ks._createAt(t2[e3].start);
            for (let e3 = n2 + 1; e3 < t2.length && t2[e3].start.isEqual(i2.end); e3++)
              i2.end = ks._createAt(t2[e3].end);
            return i2;
          }
          static fromJSON(t2, e2) {
            return new this(ks.fromJSON(t2.start, e2), ks.fromJSON(t2.end, e2));
          }
        }
        class As {
          constructor() {
            this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (t2, e2) => {
              if (e2.viewPosition)
                return;
              const n2 = this._modelToViewMapping.get(e2.modelPosition.parent);
              e2.viewPosition = this._findPositionIn(n2, e2.modelPosition.offset);
            }, { priority: "low" }), this.on("viewToModelPosition", (t2, e2) => {
              if (e2.modelPosition)
                return;
              const n2 = this.findMappedViewAncestor(e2.viewPosition), i2 = this._viewToModelMapping.get(n2), o2 = this._toModelOffset(e2.viewPosition.parent, e2.viewPosition.offset, n2);
              e2.modelPosition = ks._createAt(i2, o2);
            }, { priority: "low" });
          }
          bindElements(t2, e2) {
            this._modelToViewMapping.set(t2, e2), this._viewToModelMapping.set(e2, t2);
          }
          unbindViewElement(t2) {
            const e2 = this.toModelElement(t2);
            if (this._viewToModelMapping.delete(t2), this._elementToMarkerNames.has(t2))
              for (const e3 of this._elementToMarkerNames.get(t2))
                this._unboundMarkerNames.add(e3);
            this._modelToViewMapping.get(e2) == t2 && this._modelToViewMapping.delete(e2);
          }
          unbindModelElement(t2) {
            const e2 = this.toViewElement(t2);
            this._modelToViewMapping.delete(t2), this._viewToModelMapping.get(e2) == t2 && this._viewToModelMapping.delete(e2);
          }
          bindElementToMarker(t2, e2) {
            const n2 = this._markerNameToElements.get(e2) || /* @__PURE__ */ new Set();
            n2.add(t2);
            const i2 = this._elementToMarkerNames.get(t2) || /* @__PURE__ */ new Set();
            i2.add(e2), this._markerNameToElements.set(e2, n2), this._elementToMarkerNames.set(t2, i2);
          }
          unbindElementFromMarkerName(t2, e2) {
            const n2 = this._markerNameToElements.get(e2);
            n2 && (n2.delete(t2), 0 == n2.size && this._markerNameToElements.delete(e2));
            const i2 = this._elementToMarkerNames.get(t2);
            i2 && (i2.delete(e2), 0 == i2.size && this._elementToMarkerNames.delete(t2));
          }
          flushUnboundMarkerNames() {
            const t2 = Array.from(this._unboundMarkerNames);
            return this._unboundMarkerNames.clear(), t2;
          }
          clearBindings() {
            this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set();
          }
          toModelElement(t2) {
            return this._viewToModelMapping.get(t2);
          }
          toViewElement(t2) {
            return this._modelToViewMapping.get(t2);
          }
          toModelRange(t2) {
            return new xs(this.toModelPosition(t2.start), this.toModelPosition(t2.end));
          }
          toViewRange(t2) {
            return new Xi(this.toViewPosition(t2.start), this.toViewPosition(t2.end));
          }
          toModelPosition(t2) {
            const e2 = { viewPosition: t2, mapper: this };
            return this.fire("viewToModelPosition", e2), e2.modelPosition;
          }
          toViewPosition(t2, e2 = { isPhantom: false }) {
            const n2 = { modelPosition: t2, mapper: this, isPhantom: e2.isPhantom };
            return this.fire("modelToViewPosition", n2), n2.viewPosition;
          }
          markerNameToElements(t2) {
            const e2 = this._markerNameToElements.get(t2);
            if (!e2)
              return null;
            const n2 = /* @__PURE__ */ new Set();
            for (const t3 of e2)
              if (t3.is("attributeElement"))
                for (const e3 of t3.getElementsWithSameId())
                  n2.add(e3);
              else
                n2.add(t3);
            return n2;
          }
          registerViewToModelLength(t2, e2) {
            this._viewToModelLengthCallbacks.set(t2, e2);
          }
          findMappedViewAncestor(t2) {
            let e2 = t2.parent;
            for (; !this._viewToModelMapping.has(e2); )
              e2 = e2.parent;
            return e2;
          }
          _toModelOffset(t2, e2, n2) {
            if (n2 != t2) {
              return this._toModelOffset(t2.parent, t2.index, n2) + this._toModelOffset(t2, e2, t2);
            }
            if (t2.is("text"))
              return e2;
            let i2 = 0;
            for (let n3 = 0; n3 < e2; n3++)
              i2 += this.getModelLength(t2.getChild(n3));
            return i2;
          }
          getModelLength(t2) {
            if (this._viewToModelLengthCallbacks.get(t2.name)) {
              return this._viewToModelLengthCallbacks.get(t2.name)(t2);
            }
            if (this._viewToModelMapping.has(t2))
              return 1;
            if (t2.is("text"))
              return t2.data.length;
            if (t2.is("uiElement"))
              return 0;
            {
              let e2 = 0;
              for (const n2 of t2.getChildren())
                e2 += this.getModelLength(n2);
              return e2;
            }
          }
          _findPositionIn(t2, e2) {
            let n2, i2 = 0, o2 = 0, r2 = 0;
            if (t2.is("text"))
              return new Zi(t2, e2);
            for (; o2 < e2; )
              n2 = t2.getChild(r2), i2 = this.getModelLength(n2), o2 += i2, r2++;
            return o2 == e2 ? this._moveViewPositionToTextNode(new Zi(t2, r2)) : this._findPositionIn(n2, e2 - (o2 - i2));
          }
          _moveViewPositionToTextNode(t2) {
            const e2 = t2.nodeBefore, n2 = t2.nodeAfter;
            return e2 instanceof Rn ? new Zi(e2, e2.data.length) : n2 instanceof Rn ? new Zi(n2, 0) : t2;
          }
        }
        xn(As, gn);
        class Ts {
          constructor() {
            this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
          }
          add(t2, e2) {
            e2 = Cs(e2), t2 instanceof ms && (t2 = this._getSymbolForTextProxy(t2)), this._consumable.has(t2) || this._consumable.set(t2, /* @__PURE__ */ new Map()), this._consumable.get(t2).set(e2, true);
          }
          consume(t2, e2) {
            return e2 = Cs(e2), t2 instanceof ms && (t2 = this._getSymbolForTextProxy(t2)), !!this.test(t2, e2) && (this._consumable.get(t2).set(e2, false), true);
          }
          test(t2, e2) {
            e2 = Cs(e2), t2 instanceof ms && (t2 = this._getSymbolForTextProxy(t2));
            const n2 = this._consumable.get(t2);
            if (void 0 === n2)
              return null;
            const i2 = n2.get(e2);
            return void 0 === i2 ? null : i2;
          }
          revert(t2, e2) {
            e2 = Cs(e2), t2 instanceof ms && (t2 = this._getSymbolForTextProxy(t2));
            const n2 = this.test(t2, e2);
            return false === n2 ? (this._consumable.get(t2).set(e2, true), true) : true !== n2 && null;
          }
          _getSymbolForTextProxy(t2) {
            let e2 = null;
            const n2 = this._textProxyRegistry.get(t2.startOffset);
            if (n2) {
              const i2 = n2.get(t2.endOffset);
              i2 && (e2 = i2.get(t2.parent));
            }
            return e2 || (e2 = this._addSymbolForTextProxy(t2.startOffset, t2.endOffset, t2.parent)), e2;
          }
          _addSymbolForTextProxy(t2, e2, n2) {
            const i2 = Symbol("textProxySymbol");
            let o2, r2;
            return o2 = this._textProxyRegistry.get(t2), o2 || (o2 = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t2, o2)), r2 = o2.get(e2), r2 || (r2 = /* @__PURE__ */ new Map(), o2.set(e2, r2)), r2.set(n2, i2), i2;
          }
        }
        function Cs(t2) {
          const e2 = t2.split(":");
          return e2.length > 1 ? e2[0] + ":" + e2[1] : e2[0];
        }
        class Ps {
          constructor(t2) {
            this.conversionApi = ji({ dispatcher: this }, t2);
          }
          convertChanges(t2, e2, n2) {
            for (const e3 of t2.getMarkersToRemove())
              this.convertMarkerRemove(e3.name, e3.range, n2);
            for (const e3 of t2.getChanges())
              "insert" == e3.type ? this.convertInsert(xs._createFromPositionAndShift(e3.position, e3.length), n2) : "remove" == e3.type ? this.convertRemove(e3.position, e3.length, e3.name, n2) : this.convertAttribute(e3.range, e3.attributeKey, e3.attributeOldValue, e3.attributeNewValue, n2);
            for (const t3 of this.conversionApi.mapper.flushUnboundMarkerNames()) {
              const i2 = e2.get(t3).getRange();
              this.convertMarkerRemove(t3, i2, n2), this.convertMarkerAdd(t3, i2, n2);
            }
            for (const e3 of t2.getMarkersToAdd())
              this.convertMarkerAdd(e3.name, e3.range, n2);
          }
          convertInsert(t2, e2) {
            this.conversionApi.writer = e2, this.conversionApi.consumable = this._createInsertConsumable(t2);
            for (const e3 of t2) {
              const t3 = e3.item, n2 = { item: t3, range: xs._createFromPositionAndShift(e3.previousPosition, e3.length) };
              this._testAndFire("insert", n2);
              for (const e4 of t3.getAttributeKeys())
                n2.attributeKey = e4, n2.attributeOldValue = null, n2.attributeNewValue = t3.getAttribute(e4), this._testAndFire("attribute:" + e4, n2);
            }
            this._clearConversionApi();
          }
          convertRemove(t2, e2, n2, i2) {
            this.conversionApi.writer = i2, this.fire("remove:" + n2, { position: t2, length: e2 }, this.conversionApi), this._clearConversionApi();
          }
          convertAttribute(t2, e2, n2, i2, o2) {
            this.conversionApi.writer = o2, this.conversionApi.consumable = this._createConsumableForRange(t2, "attribute:" + e2);
            for (const o3 of t2) {
              const t3 = { item: o3.item, range: xs._createFromPositionAndShift(o3.previousPosition, o3.length), attributeKey: e2, attributeOldValue: n2, attributeNewValue: i2 };
              this._testAndFire("attribute:" + e2, t3);
            }
            this._clearConversionApi();
          }
          convertSelection(t2, e2, n2) {
            const i2 = Array.from(e2.getMarkersAtPosition(t2.getFirstPosition()));
            if (this.conversionApi.writer = n2, this.conversionApi.consumable = this._createSelectionConsumable(t2, i2), this.fire("selection", { selection: t2 }, this.conversionApi), t2.isCollapsed) {
              for (const e3 of i2) {
                const n3 = e3.getRange();
                if (!Ss(t2.getFirstPosition(), e3, this.conversionApi.mapper))
                  continue;
                const i3 = { item: t2, markerName: e3.name, markerRange: n3 };
                this.conversionApi.consumable.test(t2, "addMarker:" + e3.name) && this.fire("addMarker:" + e3.name, i3, this.conversionApi);
              }
              for (const e3 of t2.getAttributeKeys()) {
                const n3 = { item: t2, range: t2.getFirstRange(), attributeKey: e3, attributeOldValue: null, attributeNewValue: t2.getAttribute(e3) };
                this.conversionApi.consumable.test(t2, "attribute:" + n3.attributeKey) && this.fire("attribute:" + n3.attributeKey + ":$text", n3, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerAdd(t2, e2, n2) {
            if (!e2.root.document || "$graveyard" == e2.root.rootName)
              return;
            this.conversionApi.writer = n2;
            const i2 = "addMarker:" + t2, o2 = new Ts();
            if (o2.add(e2, i2), this.conversionApi.consumable = o2, this.fire(i2, { markerName: t2, markerRange: e2 }, this.conversionApi), o2.test(e2, i2)) {
              this.conversionApi.consumable = this._createConsumableForRange(e2, i2);
              for (const n3 of e2.getItems()) {
                if (!this.conversionApi.consumable.test(n3, i2))
                  continue;
                const o3 = { item: n3, range: xs._createOn(n3), markerName: t2, markerRange: e2 };
                this.fire(i2, o3, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerRemove(t2, e2, n2) {
            e2.root.document && "$graveyard" != e2.root.rootName && (this.conversionApi.writer = n2, this.fire("removeMarker:" + t2, { markerName: t2, markerRange: e2 }, this.conversionApi), this._clearConversionApi());
          }
          _createInsertConsumable(t2) {
            const e2 = new Ts();
            for (const n2 of t2) {
              const t3 = n2.item;
              e2.add(t3, "insert");
              for (const n3 of t3.getAttributeKeys())
                e2.add(t3, "attribute:" + n3);
            }
            return e2;
          }
          _createConsumableForRange(t2, e2) {
            const n2 = new Ts();
            for (const i2 of t2.getItems())
              n2.add(i2, e2);
            return n2;
          }
          _createSelectionConsumable(t2, e2) {
            const n2 = new Ts();
            n2.add(t2, "selection");
            for (const i2 of e2)
              n2.add(t2, "addMarker:" + i2.name);
            for (const e3 of t2.getAttributeKeys())
              n2.add(t2, "attribute:" + e3);
            return n2;
          }
          _testAndFire(t2, e2) {
            if (!this.conversionApi.consumable.test(e2.item, t2))
              return;
            const n2 = e2.item.name || "$text";
            this.fire(t2 + ":" + n2, e2, this.conversionApi);
          }
          _clearConversionApi() {
            delete this.conversionApi.writer, delete this.conversionApi.consumable;
          }
        }
        function Ss(t2, e2, n2) {
          const i2 = e2.getRange(), o2 = Array.from(t2.getAncestors());
          return o2.shift(), o2.reverse(), !o2.some((t3) => {
            if (i2.containsItem(t3)) {
              return !!n2.toViewElement(t3).getCustomProperty("addHighlight");
            }
          });
        }
        xn(Ps, gn);
        class Ms {
          constructor(t2, e2, n2) {
            this._lastRangeBackward = false, this._ranges = [], this._attrs = /* @__PURE__ */ new Map(), t2 && this.setTo(t2, e2, n2);
          }
          get anchor() {
            if (this._ranges.length > 0) {
              const t2 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t2.end : t2.start;
            }
            return null;
          }
          get focus() {
            if (this._ranges.length > 0) {
              const t2 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t2.start : t2.end;
            }
            return null;
          }
          get isCollapsed() {
            return 1 === this._ranges.length && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          isEqual(t2) {
            if (this.rangeCount != t2.rangeCount)
              return false;
            if (0 === this.rangeCount)
              return true;
            if (!this.anchor.isEqual(t2.anchor) || !this.focus.isEqual(t2.focus))
              return false;
            for (const e2 of this._ranges) {
              let n2 = false;
              for (const i2 of t2._ranges)
                if (e2.isEqual(i2)) {
                  n2 = true;
                  break;
                }
              if (!n2)
                return false;
            }
            return true;
          }
          *getRanges() {
            for (const t2 of this._ranges)
              yield new xs(t2.start, t2.end);
          }
          getFirstRange() {
            let t2 = null;
            for (const e2 of this._ranges)
              t2 && !e2.start.isBefore(t2.start) || (t2 = e2);
            return t2 ? new xs(t2.start, t2.end) : null;
          }
          getLastRange() {
            let t2 = null;
            for (const e2 of this._ranges)
              t2 && !e2.end.isAfter(t2.end) || (t2 = e2);
            return t2 ? new xs(t2.start, t2.end) : null;
          }
          getFirstPosition() {
            const t2 = this.getFirstRange();
            return t2 ? t2.start.clone() : null;
          }
          getLastPosition() {
            const t2 = this.getLastRange();
            return t2 ? t2.end.clone() : null;
          }
          setTo(t2, e2, n2) {
            if (null === t2)
              this._setRanges([]);
            else if (t2 instanceof Ms)
              this._setRanges(t2.getRanges(), t2.isBackward);
            else if (t2 && "function" == typeof t2.getRanges)
              this._setRanges(t2.getRanges(), t2.isBackward);
            else if (t2 instanceof xs)
              this._setRanges([t2], !!e2 && !!e2.backward);
            else if (t2 instanceof ks)
              this._setRanges([new xs(t2)]);
            else if (t2 instanceof hs) {
              const i2 = !!n2 && !!n2.backward;
              let o2;
              if ("in" == e2)
                o2 = xs._createIn(t2);
              else if ("on" == e2)
                o2 = xs._createOn(t2);
              else {
                if (void 0 === e2)
                  throw new hn.b("model-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.", [this, t2]);
                o2 = new xs(ks._createAt(t2, e2));
              }
              this._setRanges([o2], i2);
            } else {
              if (!yn(t2))
                throw new hn.b("model-selection-setTo-not-selectable: Cannot set the selection to the given place.", [this, t2]);
              this._setRanges(t2, e2 && !!e2.backward);
            }
          }
          _setRanges(t2, e2 = false) {
            const n2 = (t2 = Array.from(t2)).some((e3) => {
              if (!(e3 instanceof xs))
                throw new hn.b("model-selection-set-ranges-not-range: Selection range set to an object that is not an instance of model.Range.", [this, t2]);
              return this._ranges.every((t3) => !t3.isEqual(e3));
            });
            if (t2.length !== this._ranges.length || n2) {
              this._removeAllRanges();
              for (const e3 of t2)
                this._pushRange(e3);
              this._lastRangeBackward = !!e2, this.fire("change:range", { directChange: true });
            }
          }
          setFocus(t2, e2) {
            if (null === this.anchor)
              throw new hn.b("model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", [this, t2]);
            const n2 = ks._createAt(t2, e2);
            if ("same" == n2.compareWith(this.focus))
              return;
            const i2 = this.anchor;
            this._ranges.length && this._popRange(), "before" == n2.compareWith(i2) ? (this._pushRange(new xs(n2, i2)), this._lastRangeBackward = true) : (this._pushRange(new xs(i2, n2)), this._lastRangeBackward = false), this.fire("change:range", { directChange: true });
          }
          getAttribute(t2) {
            return this._attrs.get(t2);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          hasAttribute(t2) {
            return this._attrs.has(t2);
          }
          removeAttribute(t2) {
            this.hasAttribute(t2) && (this._attrs.delete(t2), this.fire("change:attribute", { attributeKeys: [t2], directChange: true }));
          }
          setAttribute(t2, e2) {
            this.getAttribute(t2) !== e2 && (this._attrs.set(t2, e2), this.fire("change:attribute", { attributeKeys: [t2], directChange: true }));
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          is(t2) {
            return "selection" === t2 || "model:selection" === t2;
          }
          *getSelectedBlocks() {
            const t2 = /* @__PURE__ */ new WeakSet();
            for (const e2 of this.getRanges()) {
              const n2 = Ns(e2.start, t2);
              n2 && Os(n2, e2) && (yield n2);
              for (const n3 of e2.getWalker()) {
                const i3 = n3.item;
                "elementEnd" == n3.type && Is(i3, t2, e2) && (yield i3);
              }
              const i2 = Ns(e2.end, t2);
              i2 && !e2.end.isTouching(ks._createAt(i2, 0)) && Os(i2, e2) && (yield i2);
            }
          }
          containsEntireContent(t2 = this.anchor.root) {
            const e2 = ks._createAt(t2, 0), n2 = ks._createAt(t2, "end");
            return e2.isTouching(this.getFirstPosition()) && n2.isTouching(this.getLastPosition());
          }
          _pushRange(t2) {
            this._checkRange(t2), this._ranges.push(new xs(t2.start, t2.end));
          }
          _checkRange(t2) {
            for (let e2 = 0; e2 < this._ranges.length; e2++)
              if (t2.isIntersecting(this._ranges[e2]))
                throw new hn.b("model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.", [this, t2], { addedRange: t2, intersectingRange: this._ranges[e2] });
          }
          _removeAllRanges() {
            for (; this._ranges.length > 0; )
              this._popRange();
          }
          _popRange() {
            this._ranges.pop();
          }
        }
        function Es(t2, e2) {
          return !e2.has(t2) && (e2.add(t2), t2.root.document.model.schema.isBlock(t2) && t2.parent);
        }
        function Is(t2, e2, n2) {
          return Es(t2, e2) && Os(t2, n2);
        }
        function Ns(t2, e2) {
          const n2 = t2.parent.root.document.model.schema, i2 = t2.parent.getAncestors({ parentFirst: true, includeSelf: true });
          let o2 = false;
          const r2 = i2.find((t3) => !o2 && (o2 = n2.isLimit(t3), !o2 && Es(t3, e2)));
          return i2.forEach((t3) => e2.add(t3)), r2;
        }
        function Os(t2, e2) {
          const n2 = function(t3) {
            const e3 = t3.root.document.model.schema;
            let n3 = t3.parent;
            for (; n3; ) {
              if (e3.isBlock(n3))
                return n3;
              n3 = n3.parent;
            }
          }(t2);
          return !n2 || !e2.containsRange(xs._createOn(n2), true);
        }
        xn(Ms, gn);
        class Rs extends xs {
          constructor(t2, e2) {
            super(t2, e2), Ds.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t2) {
            return "liveRange" === t2 || "model:liveRange" === t2 || "range" == t2 || "model:range" === t2;
          }
          toRange() {
            return new xs(this.start, this.end);
          }
          static fromRange(t2) {
            return new Rs(t2.start, t2.end);
          }
        }
        function Ds() {
          this.listenTo(this.root.document.model, "applyOperation", (t2, e2) => {
            const n2 = e2[0];
            n2.isDocumentOperation && Ls.call(this, n2);
          }, { priority: "low" });
        }
        function Ls(t2) {
          const e2 = this.getTransformedByOperation(t2), n2 = xs._createFromRanges(e2), i2 = !n2.isEqual(this), o2 = function(t3, e3) {
            switch (e3.type) {
              case "insert":
                return t3.containsPosition(e3.position);
              case "move":
              case "remove":
              case "reinsert":
              case "merge":
                return t3.containsPosition(e3.sourcePosition) || t3.start.isEqual(e3.sourcePosition) || t3.containsPosition(e3.targetPosition);
              case "split":
                return t3.containsPosition(e3.splitPosition) || t3.containsPosition(e3.insertionPosition);
            }
            return false;
          }(this, t2);
          let r2 = null;
          if (i2) {
            "$graveyard" == n2.root.rootName && (r2 = "remove" == t2.type ? t2.sourcePosition : t2.deletionPosition);
            const e3 = this.toRange();
            this.start = n2.start, this.end = n2.end, this.fire("change:range", e3, { deletionPosition: r2 });
          } else
            o2 && this.fire("change:content", this.toRange(), { deletionPosition: r2 });
        }
        xn(Rs, gn);
        class js {
          constructor(t2) {
            this._selection = new Vs(t2), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get hasOwnRange() {
            return this._selection.hasOwnRange;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get isGravityOverridden() {
            return this._selection.isGravityOverridden;
          }
          get markers() {
            return this._selection.markers;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          getRanges() {
            return this._selection.getRanges();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getSelectedBlocks() {
            return this._selection.getSelectedBlocks();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          containsEntireContent(t2) {
            return this._selection.containsEntireContent(t2);
          }
          destroy() {
            this._selection.destroy();
          }
          getAttributeKeys() {
            return this._selection.getAttributeKeys();
          }
          getAttributes() {
            return this._selection.getAttributes();
          }
          getAttribute(t2) {
            return this._selection.getAttribute(t2);
          }
          hasAttribute(t2) {
            return this._selection.hasAttribute(t2);
          }
          refresh() {
            this._selection._updateMarkers(), this._selection._updateAttributes(false);
          }
          is(t2) {
            return "selection" === t2 || "model:selection" == t2 || "documentSelection" == t2 || "model:documentSelection" == t2;
          }
          _setFocus(t2, e2) {
            this._selection.setFocus(t2, e2);
          }
          _setTo(t2, e2, n2) {
            this._selection.setTo(t2, e2, n2);
          }
          _setAttribute(t2, e2) {
            this._selection.setAttribute(t2, e2);
          }
          _removeAttribute(t2) {
            this._selection.removeAttribute(t2);
          }
          _getStoredAttributes() {
            return this._selection._getStoredAttributes();
          }
          _overrideGravity() {
            return this._selection.overrideGravity();
          }
          _restoreGravity(t2) {
            this._selection.restoreGravity(t2);
          }
          static _getStoreAttributeKey(t2) {
            return "selection:" + t2;
          }
          static _isStoreAttributeKey(t2) {
            return t2.startsWith("selection:");
          }
        }
        xn(js, gn);
        class Vs extends Ms {
          constructor(t2) {
            super(), this.markers = new An({ idProperty: "name" }), this._model = t2.model, this._document = t2, this._attributePriority = /* @__PURE__ */ new Map(), this._fixGraveyardRangesData = [], this._hasChangedRange = false, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this.listenTo(this._model, "applyOperation", (t3, e2) => {
              const n2 = e2[0];
              if (n2.isDocumentOperation && "marker" != n2.type && "rename" != n2.type && "noop" != n2.type) {
                for (; this._fixGraveyardRangesData.length; ) {
                  const { liveRange: t4, sourcePosition: e3 } = this._fixGraveyardRangesData.shift();
                  this._fixGraveyardSelection(t4, e3);
                }
                this._hasChangedRange && (this._hasChangedRange = false, this.fire("change:range", { directChange: false }));
              }
            }, { priority: "lowest" }), this.on("change:range", () => {
              for (const t3 of this.getRanges())
                if (!this._document._validateSelectionRange(t3))
                  throw new hn.b("document-selection-wrong-position: Range from document selection starts or ends at incorrect position.", this, { range: t3 });
            }), this.listenTo(this._model.markers, "update", () => this._updateMarkers()), this.listenTo(this._document, "change", (t3, e2) => {
              !function(t4, e3) {
                const n2 = t4.document.differ;
                for (const i2 of n2.getChanges()) {
                  if ("insert" != i2.type)
                    continue;
                  const n3 = i2.position.parent;
                  i2.length === n3.maxOffset && t4.enqueueChange(e3, (t5) => {
                    const e4 = Array.from(n3.getAttributeKeys()).filter((t6) => t6.startsWith("selection:"));
                    for (const i3 of e4)
                      t5.removeAttribute(i3, n3);
                  });
                }
              }(this._model, e2);
            });
          }
          get isCollapsed() {
            return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
          }
          get anchor() {
            return super.anchor || this._document._getDefaultRange().start;
          }
          get focus() {
            return super.focus || this._document._getDefaultRange().end;
          }
          get rangeCount() {
            return this._ranges.length ? this._ranges.length : 1;
          }
          get hasOwnRange() {
            return this._ranges.length > 0;
          }
          get isGravityOverridden() {
            return !!this._overriddenGravityRegister.size;
          }
          destroy() {
            for (let t2 = 0; t2 < this._ranges.length; t2++)
              this._ranges[t2].detach();
            this.stopListening();
          }
          *getRanges() {
            this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
          }
          getFirstRange() {
            return super.getFirstRange() || this._document._getDefaultRange();
          }
          getLastRange() {
            return super.getLastRange() || this._document._getDefaultRange();
          }
          setTo(t2, e2, n2) {
            super.setTo(t2, e2, n2), this._updateAttributes(true), this._updateMarkers();
          }
          setFocus(t2, e2) {
            super.setFocus(t2, e2), this._updateAttributes(true), this._updateMarkers();
          }
          setAttribute(t2, e2) {
            if (this._setAttribute(t2, e2)) {
              const e3 = [t2];
              this.fire("change:attribute", { attributeKeys: e3, directChange: true });
            }
          }
          removeAttribute(t2) {
            if (this._removeAttribute(t2)) {
              const e2 = [t2];
              this.fire("change:attribute", { attributeKeys: e2, directChange: true });
            }
          }
          overrideGravity() {
            const t2 = dn();
            return this._overriddenGravityRegister.add(t2), 1 === this._overriddenGravityRegister.size && this._updateAttributes(true), t2;
          }
          restoreGravity(t2) {
            if (!this._overriddenGravityRegister.has(t2))
              throw new hn.b("document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.", this, { uid: t2 });
            this._overriddenGravityRegister.delete(t2), this.isGravityOverridden || this._updateAttributes(true);
          }
          _popRange() {
            this._ranges.pop().detach();
          }
          _pushRange(t2) {
            const e2 = this._prepareRange(t2);
            e2 && this._ranges.push(e2);
          }
          _prepareRange(t2) {
            if (this._checkRange(t2), t2.root == this._document.graveyard)
              return;
            const e2 = Rs.fromRange(t2);
            return e2.on("change:range", (t3, n2, i2) => {
              this._hasChangedRange = true, e2.root == this._document.graveyard && this._fixGraveyardRangesData.push({ liveRange: e2, sourcePosition: i2.deletionPosition });
            }), e2;
          }
          _updateMarkers() {
            const t2 = [];
            let e2 = false;
            for (const e3 of this._model.markers) {
              const n3 = e3.getRange();
              for (const i2 of this.getRanges())
                n3.containsRange(i2, !i2.isCollapsed) && t2.push(e3);
            }
            const n2 = Array.from(this.markers);
            for (const n3 of t2)
              this.markers.has(n3) || (this.markers.add(n3), e2 = true);
            for (const n3 of Array.from(this.markers))
              t2.includes(n3) || (this.markers.remove(n3), e2 = true);
            e2 && this.fire("change:marker", { oldMarkers: n2, directChange: false });
          }
          _updateAttributes(t2) {
            const e2 = Ln(this._getSurroundingAttributes()), n2 = Ln(this.getAttributes());
            if (t2)
              this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
            else
              for (const [t3, e3] of this._attributePriority)
                "low" == e3 && (this._attrs.delete(t3), this._attributePriority.delete(t3));
            this._setAttributesTo(e2);
            const i2 = [];
            for (const [t3, e3] of this.getAttributes())
              n2.has(t3) && n2.get(t3) === e3 || i2.push(t3);
            for (const [t3] of n2)
              this.hasAttribute(t3) || i2.push(t3);
            i2.length > 0 && this.fire("change:attribute", { attributeKeys: i2, directChange: false });
          }
          _setAttribute(t2, e2, n2 = true) {
            const i2 = n2 ? "normal" : "low";
            return ("low" != i2 || "normal" != this._attributePriority.get(t2)) && (super.getAttribute(t2) !== e2 && (this._attrs.set(t2, e2), this._attributePriority.set(t2, i2), true));
          }
          _removeAttribute(t2, e2 = true) {
            const n2 = e2 ? "normal" : "low";
            return ("low" != n2 || "normal" != this._attributePriority.get(t2)) && (this._attributePriority.set(t2, n2), !!super.hasAttribute(t2) && (this._attrs.delete(t2), true));
          }
          _setAttributesTo(t2) {
            const e2 = /* @__PURE__ */ new Set();
            for (const [e3, n2] of this.getAttributes())
              t2.get(e3) !== n2 && this._removeAttribute(e3, false);
            for (const [n2, i2] of t2) {
              this._setAttribute(n2, i2, false) && e2.add(n2);
            }
            return e2;
          }
          *_getStoredAttributes() {
            const t2 = this.getFirstPosition().parent;
            if (this.isCollapsed && t2.isEmpty) {
              for (const e2 of t2.getAttributeKeys())
                if (e2.startsWith("selection:")) {
                  const n2 = e2.substr("selection:".length);
                  yield [n2, t2.getAttribute(e2)];
                }
            }
          }
          _getSurroundingAttributes() {
            const t2 = this.getFirstPosition(), e2 = this._model.schema;
            let n2 = null;
            if (this.isCollapsed) {
              const e3 = t2.textNode ? t2.textNode : t2.nodeBefore, i2 = t2.textNode ? t2.textNode : t2.nodeAfter;
              if (this.isGravityOverridden || (n2 = zs(e3)), n2 || (n2 = zs(i2)), !this.isGravityOverridden && !n2) {
                let t3 = e3;
                for (; t3 && !n2; )
                  t3 = t3.previousSibling, n2 = zs(t3);
              }
              if (!n2) {
                let t3 = i2;
                for (; t3 && !n2; )
                  t3 = t3.nextSibling, n2 = zs(t3);
              }
              n2 || (n2 = this._getStoredAttributes());
            } else {
              const t3 = this.getFirstRange();
              for (const i2 of t3) {
                if (i2.item.is("element") && e2.isObject(i2.item))
                  break;
                if ("text" == i2.type) {
                  n2 = i2.item.getAttributes();
                  break;
                }
              }
            }
            return n2;
          }
          _fixGraveyardSelection(t2, e2) {
            const n2 = e2.clone(), i2 = this._model.schema.getNearestSelectionRange(n2), o2 = this._ranges.indexOf(t2);
            if (this._ranges.splice(o2, 1), t2.detach(), i2 && (r2 = i2, this._ranges.every((t3) => !r2.isEqual(t3)))) {
              const t3 = this._prepareRange(i2);
              this._ranges.splice(o2, 0, t3);
            }
            var r2;
          }
        }
        function zs(t2) {
          return t2 instanceof ms || t2 instanceof fs ? t2.getAttributes() : null;
        }
        class Bs {
          constructor(t2) {
            this._dispatchers = t2;
          }
          add(t2) {
            for (const e2 of this._dispatchers)
              t2(e2);
            return this;
          }
        }
        var Fs = function(t2) {
          return tn(t2, 5);
        };
        class Us extends Bs {
          elementToElement(t2) {
            return this.add(function(t3) {
              return (t3 = Fs(t3)).view = qs(t3.view, "container"), (e2) => {
                var n2;
                e2.on("insert:" + t3.model, (n2 = t3.view, (t4, e3, i2) => {
                  const o2 = n2(e3.item, i2.writer);
                  if (!o2)
                    return;
                  if (!i2.consumable.consume(e3.item, "insert"))
                    return;
                  const r2 = i2.mapper.toViewPosition(e3.range.start);
                  i2.mapper.bindElements(e3.item, o2), i2.writer.insert(r2, o2);
                }), { priority: t3.converterPriority || "normal" });
              };
            }(t2));
          }
          attributeToElement(t2) {
            return this.add(function(t3) {
              let e2 = "attribute:" + ((t3 = Fs(t3)).model.key ? t3.model.key : t3.model);
              t3.model.name && (e2 += ":" + t3.model.name);
              if (t3.model.values)
                for (const e3 of t3.model.values)
                  t3.view[e3] = qs(t3.view[e3], "attribute");
              else
                t3.view = qs(t3.view, "attribute");
              const n2 = Ws(t3);
              return (i2) => {
                i2.on(e2, function(t4) {
                  return (e3, n3, i3) => {
                    const o2 = t4(n3.attributeOldValue, i3.writer), r2 = t4(n3.attributeNewValue, i3.writer);
                    if (!o2 && !r2)
                      return;
                    if (!i3.consumable.consume(n3.item, e3.name))
                      return;
                    const s2 = i3.writer, a2 = s2.document.selection;
                    if (n3.item instanceof Ms || n3.item instanceof js)
                      s2.wrap(a2.getFirstRange(), r2);
                    else {
                      let t5 = i3.mapper.toViewRange(n3.range);
                      null !== n3.attributeOldValue && o2 && (t5 = s2.unwrap(t5, o2)), null !== n3.attributeNewValue && r2 && s2.wrap(t5, r2);
                    }
                  };
                }(n2), { priority: t3.converterPriority || "normal" });
              };
            }(t2));
          }
          attributeToAttribute(t2) {
            return this.add(function(t3) {
              let e2 = "attribute:" + ((t3 = Fs(t3)).model.key ? t3.model.key : t3.model);
              t3.model.name && (e2 += ":" + t3.model.name);
              if (t3.model.values)
                for (const e3 of t3.model.values)
                  t3.view[e3] = Ys(t3.view[e3]);
              else
                t3.view = Ys(t3.view);
              const n2 = Ws(t3);
              return (i2) => {
                var o2;
                i2.on(e2, (o2 = n2, (t4, e3, n3) => {
                  const i3 = o2(e3.attributeOldValue, e3), r2 = o2(e3.attributeNewValue, e3);
                  if (!i3 && !r2)
                    return;
                  if (!n3.consumable.consume(e3.item, t4.name))
                    return;
                  const s2 = n3.mapper.toViewElement(e3.item), a2 = n3.writer;
                  if (!s2)
                    throw new hn.b("conversion-attribute-to-attribute-on-text: Trying to convert text node's attribute with attribute-to-attribute converter.", [e3, n3]);
                  if (null !== e3.attributeOldValue && i3)
                    if ("class" == i3.key) {
                      const t5 = Array.isArray(i3.value) ? i3.value : [i3.value];
                      for (const e4 of t5)
                        a2.removeClass(e4, s2);
                    } else if ("style" == i3.key) {
                      const t5 = Object.keys(i3.value);
                      for (const e4 of t5)
                        a2.removeStyle(e4, s2);
                    } else
                      a2.removeAttribute(i3.key, s2);
                  if (null !== e3.attributeNewValue && r2)
                    if ("class" == r2.key) {
                      const t5 = Array.isArray(r2.value) ? r2.value : [r2.value];
                      for (const e4 of t5)
                        a2.addClass(e4, s2);
                    } else if ("style" == r2.key) {
                      const t5 = Object.keys(r2.value);
                      for (const e4 of t5)
                        a2.setStyle(e4, r2.value[e4], s2);
                    } else
                      a2.setAttribute(r2.key, r2.value, s2);
                }), { priority: t3.converterPriority || "normal" });
              };
            }(t2));
          }
          markerToElement(t2) {
            return this.add(function(t3) {
              return (t3 = Fs(t3)).view = qs(t3.view, "ui"), (e2) => {
                var n2;
                e2.on("addMarker:" + t3.model, (n2 = t3.view, (t4, e3, i2) => {
                  e3.isOpening = true;
                  const o2 = n2(e3, i2.writer);
                  e3.isOpening = false;
                  const r2 = n2(e3, i2.writer);
                  if (!o2 || !r2)
                    return;
                  const s2 = e3.markerRange;
                  if (s2.isCollapsed && !i2.consumable.consume(s2, t4.name))
                    return;
                  for (const e4 of s2)
                    if (!i2.consumable.consume(e4.item, t4.name))
                      return;
                  const a2 = i2.mapper, c2 = i2.writer;
                  c2.insert(a2.toViewPosition(s2.start), o2), i2.mapper.bindElementToMarker(o2, e3.markerName), s2.isCollapsed || (c2.insert(a2.toViewPosition(s2.end), r2), i2.mapper.bindElementToMarker(r2, e3.markerName)), t4.stop();
                }), { priority: t3.converterPriority || "normal" }), e2.on("removeMarker:" + t3.model, (t3.view, (t4, e3, n3) => {
                  const i2 = n3.mapper.markerNameToElements(e3.markerName);
                  if (i2) {
                    for (const t5 of i2)
                      n3.mapper.unbindElementFromMarkerName(t5, e3.markerName), n3.writer.clear(n3.writer.createRangeOn(t5), t5);
                    n3.writer.clearClonedElementsGroup(e3.markerName), t4.stop();
                  }
                }), { priority: t3.converterPriority || "normal" });
              };
            }(t2));
          }
          markerToHighlight(t2) {
            return this.add(function(t3) {
              return (e2) => {
                var n2;
                e2.on("addMarker:" + t3.model, (n2 = t3.view, (t4, e3, i2) => {
                  if (!e3.item)
                    return;
                  if (!(e3.item instanceof Ms || e3.item instanceof js || e3.item.is("textProxy")))
                    return;
                  const o2 = Gs(n2, e3, i2);
                  if (!o2)
                    return;
                  if (!i2.consumable.consume(e3.item, t4.name))
                    return;
                  const r2 = i2.writer, s2 = Hs(r2, o2), a2 = r2.document.selection;
                  if (e3.item instanceof Ms || e3.item instanceof js)
                    r2.wrap(a2.getFirstRange(), s2, a2);
                  else {
                    const t5 = i2.mapper.toViewRange(e3.range), n3 = r2.wrap(t5, s2);
                    for (const t6 of n3.getItems())
                      if (t6.is("attributeElement") && t6.isSimilar(s2)) {
                        i2.mapper.bindElementToMarker(t6, e3.markerName);
                        break;
                      }
                  }
                }), { priority: t3.converterPriority || "normal" }), e2.on("addMarker:" + t3.model, function(t4) {
                  return (e3, n3, i2) => {
                    if (!n3.item)
                      return;
                    if (!(n3.item instanceof ps))
                      return;
                    const o2 = Gs(t4, n3, i2);
                    if (!o2)
                      return;
                    if (!i2.consumable.test(n3.item, e3.name))
                      return;
                    const r2 = i2.mapper.toViewElement(n3.item);
                    if (r2 && r2.getCustomProperty("addHighlight")) {
                      i2.consumable.consume(n3.item, e3.name);
                      for (const t5 of xs._createIn(n3.item))
                        i2.consumable.consume(t5.item, e3.name);
                      r2.getCustomProperty("addHighlight")(r2, o2, i2.writer), i2.mapper.bindElementToMarker(r2, n3.markerName);
                    }
                  };
                }(t3.view), { priority: t3.converterPriority || "normal" }), e2.on("removeMarker:" + t3.model, function(t4) {
                  return (e3, n3, i2) => {
                    if (n3.markerRange.isCollapsed)
                      return;
                    const o2 = Gs(t4, n3, i2);
                    if (!o2)
                      return;
                    const r2 = Hs(i2.writer, o2), s2 = i2.mapper.markerNameToElements(n3.markerName);
                    if (s2) {
                      for (const t5 of s2)
                        i2.mapper.unbindElementFromMarkerName(t5, n3.markerName), t5.is("attributeElement") ? i2.writer.unwrap(i2.writer.createRangeOn(t5), r2) : t5.getCustomProperty("removeHighlight")(t5, o2.id, i2.writer);
                      i2.writer.clearClonedElementsGroup(n3.markerName), e3.stop();
                    }
                  };
                }(t3.view), { priority: t3.converterPriority || "normal" });
              };
            }(t2));
          }
        }
        function Hs(t2, e2) {
          const n2 = t2.createAttributeElement("span", e2.attributes);
          return e2.classes && n2._addClass(e2.classes), e2.priority && (n2._priority = e2.priority), n2._id = e2.id, n2;
        }
        function qs(t2, e2) {
          return "function" == typeof t2 ? t2 : (n2, i2) => function(t3, e3, n3) {
            "string" == typeof t3 && (t3 = { name: t3 });
            let i3;
            const o2 = Object.assign({}, t3.attributes);
            if ("container" == n3)
              i3 = e3.createContainerElement(t3.name, o2);
            else if ("attribute" == n3) {
              const n4 = { priority: t3.priority || ro.DEFAULT_PRIORITY };
              i3 = e3.createAttributeElement(t3.name, o2, n4);
            } else
              i3 = e3.createUIElement(t3.name, o2);
            if (t3.styles) {
              const n4 = Object.keys(t3.styles);
              for (const o3 of n4)
                e3.setStyle(o3, t3.styles[o3], i3);
            }
            if (t3.classes) {
              const n4 = t3.classes;
              if ("string" == typeof n4)
                e3.addClass(n4, i3);
              else
                for (const t4 of n4)
                  e3.addClass(t4, i3);
            }
            return i3;
          }(t2, i2, e2);
        }
        function Ws(t2) {
          return t2.model.values ? (e2, n2) => {
            const i2 = t2.view[e2];
            return i2 ? i2(e2, n2) : null;
          } : t2.view;
        }
        function Ys(t2) {
          return "string" == typeof t2 ? (e2) => ({ key: t2, value: e2 }) : "object" == typeof t2 ? t2.value ? () => t2 : (e2) => ({ key: t2.key, value: e2 }) : t2;
        }
        function Gs(t2, e2, n2) {
          const i2 = "function" == typeof t2 ? t2(e2, n2) : t2;
          return i2 ? (i2.priority || (i2.priority = 10), i2.id || (i2.id = e2.markerName), i2) : null;
        }
        class $s extends Bs {
          elementToElement(t2) {
            return this.add(Qs(t2));
          }
          elementToAttribute(t2) {
            return this.add(function(t3) {
              Js(t3 = Fs(t3));
              const e2 = Zs(t3, false), n2 = Ks(t3.view), i2 = n2 ? "element:" + n2 : "element";
              return (n3) => {
                n3.on(i2, e2, { priority: t3.converterPriority || "low" });
              };
            }(t2));
          }
          attributeToAttribute(t2) {
            return this.add(function(t3) {
              t3 = Fs(t3);
              let e2 = null;
              ("string" == typeof t3.view || t3.view.key) && (e2 = function(t4) {
                "string" == typeof t4.view && (t4.view = { key: t4.view });
                const e3 = t4.view.key;
                let n3;
                if ("class" == e3 || "style" == e3) {
                  n3 = { ["class" == e3 ? "classes" : "styles"]: t4.view.value };
                } else {
                  const i2 = void 0 === t4.view.value ? /[\s\S]*/ : t4.view.value;
                  n3 = { attributes: { [e3]: i2 } };
                }
                t4.view.name && (n3.name = t4.view.name);
                return t4.view = n3, e3;
              }(t3));
              Js(t3, e2);
              const n2 = Zs(t3, true);
              return (e3) => {
                e3.on("element", n2, { priority: t3.converterPriority || "low" });
              };
            }(t2));
          }
          elementToMarker(t2) {
            return this.add(function(t3) {
              return function(t4) {
                const e2 = t4.model;
                t4.model = (t5, n2) => {
                  const i2 = "string" == typeof e2 ? e2 : e2(t5);
                  return n2.createElement("$marker", { "data-name": i2 });
                };
              }(t3 = Fs(t3)), Qs(t3);
            }(t2));
          }
        }
        function Qs(t2) {
          const e2 = function(t3) {
            const e3 = t3.view ? new jn(t3.view) : null;
            return (n3, i3, o2) => {
              let r2 = {};
              if (e3) {
                const t4 = e3.match(i3.viewItem);
                if (!t4)
                  return;
                r2 = t4.match;
              }
              r2.name = true;
              const s2 = (a2 = t3.model, c2 = i3.viewItem, l2 = o2.writer, a2 instanceof Function ? a2(c2, l2) : l2.createElement(a2));
              var a2, c2, l2;
              if (!s2)
                return;
              if (!o2.consumable.test(i3.viewItem, r2))
                return;
              const d2 = o2.splitToAllowedParent(s2, i3.modelCursor);
              if (!d2)
                return;
              o2.writer.insert(s2, d2.position), o2.convertChildren(i3.viewItem, o2.writer.createPositionAt(s2, 0)), o2.consumable.consume(i3.viewItem, r2);
              const u2 = o2.getSplitParts(s2);
              i3.modelRange = new xs(o2.writer.createPositionBefore(s2), o2.writer.createPositionAfter(u2[u2.length - 1])), d2.cursorParent ? i3.modelCursor = o2.writer.createPositionAt(d2.cursorParent, 0) : i3.modelCursor = i3.modelRange.end;
            };
          }(t2 = Fs(t2)), n2 = Ks(t2.view), i2 = n2 ? "element:" + n2 : "element";
          return (n3) => {
            n3.on(i2, e2, { priority: t2.converterPriority || "normal" });
          };
        }
        function Ks(t2) {
          return "string" == typeof t2 ? t2 : "object" == typeof t2 && "string" == typeof t2.name ? t2.name : null;
        }
        function Js(t2, e2 = null) {
          const n2 = null === e2 || ((t3) => t3.getAttribute(e2)), i2 = "object" != typeof t2.model ? t2.model : t2.model.key, o2 = "object" != typeof t2.model || void 0 === t2.model.value ? n2 : t2.model.value;
          t2.model = { key: i2, value: o2 };
        }
        function Zs(t2, e2) {
          const n2 = new jn(t2.view);
          return (i2, o2, r2) => {
            const s2 = n2.match(o2.viewItem);
            if (!s2)
              return;
            const a2 = t2.model.key, c2 = "function" == typeof t2.model.value ? t2.model.value(o2.viewItem) : t2.model.value;
            null !== c2 && (!function(t3, e3) {
              const n3 = "function" == typeof t3 ? t3(e3) : t3;
              if ("object" == typeof n3 && !Ks(n3))
                return false;
              return !n3.classes && !n3.attributes && !n3.styles;
            }(t2.view, o2.viewItem) ? delete s2.match.name : s2.match.name = true, r2.consumable.test(o2.viewItem, s2.match) && (o2.modelRange || (o2 = Object.assign(o2, r2.convertChildren(o2.viewItem, o2.modelCursor))), function(t3, e3, n3, i3) {
              let o3 = false;
              for (const r3 of Array.from(t3.getItems({ shallow: n3 })))
                i3.schema.checkAttribute(r3, e3.key) && (i3.writer.setAttribute(e3.key, e3.value, r3), o3 = true);
              return o3;
            }(o2.modelRange, { key: a2, value: c2 }, e2, r2) && r2.consumable.consume(o2.viewItem, s2.match)));
          };
        }
        class Xs {
          constructor(t2, e2) {
            this.model = t2, this.view = new us(e2), this.mapper = new As(), this.downcastDispatcher = new Ps({ mapper: this.mapper });
            const n2 = this.model.document, i2 = n2.selection, o2 = this.model.markers;
            this.listenTo(this.model, "_beforeChanges", () => {
              this.view._disableRendering(true);
            }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
              this.view._disableRendering(false);
            }, { priority: "lowest" }), this.listenTo(n2, "change", () => {
              this.view.change((t3) => {
                this.downcastDispatcher.convertChanges(n2.differ, o2, t3), this.downcastDispatcher.convertSelection(i2, o2, t3);
              });
            }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", function(t3, e3) {
              return (n3, i3) => {
                const o3 = i3.newSelection, r2 = new Ms(), s2 = [];
                for (const t4 of o3.getRanges())
                  s2.push(e3.toModelRange(t4));
                r2.setTo(s2, { backward: o3.isBackward }), r2.isEqual(t3.document.selection) || t3.change((t4) => {
                  t4.setSelection(r2);
                });
              };
            }(this.model, this.mapper)), this.downcastDispatcher.on("insert:$text", (t3, e3, n3) => {
              if (!n3.consumable.consume(e3.item, "insert"))
                return;
              const i3 = n3.writer, o3 = n3.mapper.toViewPosition(e3.range.start), r2 = i3.createText(e3.item.data);
              i3.insert(o3, r2);
            }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (t3, e3, n3) => {
              const i3 = n3.mapper.toViewPosition(e3.position), o3 = e3.position.getShiftedBy(e3.length), r2 = n3.mapper.toViewPosition(o3, { isPhantom: true }), s2 = n3.writer.createRange(i3, r2), a2 = n3.writer.remove(s2.getTrimmed());
              for (const t4 of n3.writer.createRangeIn(a2).getItems())
                n3.mapper.unbindViewElement(t4);
            }, { priority: "low" }), this.downcastDispatcher.on("selection", (t3, e3, n3) => {
              const i3 = n3.writer, o3 = i3.document.selection;
              for (const t4 of o3.getRanges())
                t4.isCollapsed && t4.end.parent.isAttached() && n3.writer.mergeAttributes(t4.start);
              i3.setSelection(null);
            }, { priority: "low" }), this.downcastDispatcher.on("selection", (t3, e3, n3) => {
              const i3 = e3.selection;
              if (i3.isCollapsed)
                return;
              if (!n3.consumable.consume(i3, "selection"))
                return;
              const o3 = [];
              for (const t4 of i3.getRanges()) {
                const e4 = n3.mapper.toViewRange(t4);
                o3.push(e4);
              }
              n3.writer.setSelection(o3, { backward: i3.isBackward });
            }, { priority: "low" }), this.downcastDispatcher.on("selection", (t3, e3, n3) => {
              const i3 = e3.selection;
              if (!i3.isCollapsed)
                return;
              if (!n3.consumable.consume(i3, "selection"))
                return;
              const o3 = n3.writer, r2 = i3.getFirstPosition(), s2 = n3.mapper.toViewPosition(r2), a2 = o3.breakAttributes(s2);
              o3.setSelection(a2);
            }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((t3) => {
              if ("$graveyard" == t3.rootName)
                return null;
              const e3 = new Ki(this.view.document, t3.name);
              return e3.rootName = t3.rootName, this.mapper.bindElements(t3, e3), e3;
            });
          }
          destroy() {
            this.view.destroy(), this.stopListening();
          }
        }
        xn(Xs, Ui);
        class ta {
          constructor() {
            this._commands = /* @__PURE__ */ new Map();
          }
          add(t2, e2) {
            this._commands.set(t2, e2);
          }
          get(t2) {
            return this._commands.get(t2);
          }
          execute(t2, ...e2) {
            const n2 = this.get(t2);
            if (!n2)
              throw new hn.b("commandcollection-command-not-found: Command does not exist.", this, { commandName: t2 });
            n2.execute(...e2);
          }
          *names() {
            yield* this._commands.keys();
          }
          *commands() {
            yield* this._commands.values();
          }
          [Symbol.iterator]() {
            return this._commands[Symbol.iterator]();
          }
          destroy() {
            for (const t2 of this.commands())
              t2.destroy();
          }
        }
        class ea {
          constructor() {
            this._consumables = /* @__PURE__ */ new Map();
          }
          add(t2, e2) {
            let n2;
            t2.is("text") || t2.is("documentFragment") ? this._consumables.set(t2, true) : (this._consumables.has(t2) ? n2 = this._consumables.get(t2) : (n2 = new na(t2), this._consumables.set(t2, n2)), n2.add(e2));
          }
          test(t2, e2) {
            const n2 = this._consumables.get(t2);
            return void 0 === n2 ? null : t2.is("text") || t2.is("documentFragment") ? n2 : n2.test(e2);
          }
          consume(t2, e2) {
            return !!this.test(t2, e2) && (t2.is("text") || t2.is("documentFragment") ? this._consumables.set(t2, false) : this._consumables.get(t2).consume(e2), true);
          }
          revert(t2, e2) {
            const n2 = this._consumables.get(t2);
            void 0 !== n2 && (t2.is("text") || t2.is("documentFragment") ? this._consumables.set(t2, true) : n2.revert(e2));
          }
          static consumablesFromElement(t2) {
            const e2 = { element: t2, name: true, attributes: [], classes: [], styles: [] }, n2 = t2.getAttributeKeys();
            for (const t3 of n2)
              "style" != t3 && "class" != t3 && e2.attributes.push(t3);
            const i2 = t2.getClassNames();
            for (const t3 of i2)
              e2.classes.push(t3);
            const o2 = t2.getStyleNames();
            for (const t3 of o2)
              e2.styles.push(t3);
            return e2;
          }
          static createFrom(t2, e2) {
            if (e2 || (e2 = new ea(t2)), t2.is("text"))
              return e2.add(t2), e2;
            t2.is("element") && e2.add(t2, ea.consumablesFromElement(t2)), t2.is("documentFragment") && e2.add(t2);
            for (const n2 of t2.getChildren())
              e2 = ea.createFrom(n2, e2);
            return e2;
          }
        }
        class na {
          constructor(t2) {
            this.element = t2, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
          }
          add(t2) {
            t2.name && (this._canConsumeName = true);
            for (const e2 in this._consumables)
              e2 in t2 && this._add(e2, t2[e2]);
          }
          test(t2) {
            if (t2.name && !this._canConsumeName)
              return this._canConsumeName;
            for (const e2 in this._consumables)
              if (e2 in t2) {
                const n2 = this._test(e2, t2[e2]);
                if (true !== n2)
                  return n2;
              }
            return true;
          }
          consume(t2) {
            t2.name && (this._canConsumeName = false);
            for (const e2 in this._consumables)
              e2 in t2 && this._consume(e2, t2[e2]);
          }
          revert(t2) {
            t2.name && (this._canConsumeName = true);
            for (const e2 in this._consumables)
              e2 in t2 && this._revert(e2, t2[e2]);
          }
          _add(t2, e2) {
            const n2 = Dt(e2) ? e2 : [e2], i2 = this._consumables[t2];
            for (const e3 of n2) {
              if ("attributes" === t2 && ("class" === e3 || "style" === e3))
                throw new hn.b("viewconsumable-invalid-attribute: Classes and styles should be handled separately.", this);
              if (i2.set(e3, true), "styles" === t2)
                for (const t3 of this.element.document.stylesProcessor.getRelatedStyles(e3))
                  i2.set(t3, true);
            }
          }
          _test(t2, e2) {
            const n2 = Dt(e2) ? e2 : [e2], i2 = this._consumables[t2];
            for (const e3 of n2)
              if ("attributes" !== t2 || "class" !== e3 && "style" !== e3) {
                const t3 = i2.get(e3);
                if (void 0 === t3)
                  return null;
                if (!t3)
                  return false;
              } else {
                const t3 = "class" == e3 ? "classes" : "styles", n3 = this._test(t3, [...this._consumables[t3].keys()]);
                if (true !== n3)
                  return n3;
              }
            return true;
          }
          _consume(t2, e2) {
            const n2 = Dt(e2) ? e2 : [e2], i2 = this._consumables[t2];
            for (const e3 of n2)
              if ("attributes" !== t2 || "class" !== e3 && "style" !== e3) {
                if (i2.set(e3, false), "styles" == t2)
                  for (const t3 of this.element.document.stylesProcessor.getRelatedStyles(e3))
                    i2.set(t3, false);
              } else {
                const t3 = "class" == e3 ? "classes" : "styles";
                this._consume(t3, [...this._consumables[t3].keys()]);
              }
          }
          _revert(t2, e2) {
            const n2 = Dt(e2) ? e2 : [e2], i2 = this._consumables[t2];
            for (const e3 of n2)
              if ("attributes" !== t2 || "class" !== e3 && "style" !== e3) {
                false === i2.get(e3) && i2.set(e3, true);
              } else {
                const t3 = "class" == e3 ? "classes" : "styles";
                this._revert(t3, [...this._consumables[t3].keys()]);
              }
          }
        }
        class ia {
          constructor() {
            this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (t2, e2) => {
              e2[0] = new oa(e2[0]);
            }, { priority: "highest" }), this.on("checkChild", (t2, e2) => {
              e2[0] = new oa(e2[0]), e2[1] = this.getDefinition(e2[1]);
            }, { priority: "highest" });
          }
          register(t2, e2) {
            if (this._sourceDefinitions[t2])
              throw new hn.b("schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.", this, { itemName: t2 });
            this._sourceDefinitions[t2] = [Object.assign({}, e2)], this._clearCache();
          }
          extend(t2, e2) {
            if (!this._sourceDefinitions[t2])
              throw new hn.b("schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.", this, { itemName: t2 });
            this._sourceDefinitions[t2].push(Object.assign({}, e2)), this._clearCache();
          }
          getDefinitions() {
            return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
          }
          getDefinition(t2) {
            let e2;
            return e2 = "string" == typeof t2 ? t2 : t2.is && (t2.is("text") || t2.is("textProxy")) ? "$text" : t2.name, this.getDefinitions()[e2];
          }
          isRegistered(t2) {
            return !!this.getDefinition(t2);
          }
          isBlock(t2) {
            const e2 = this.getDefinition(t2);
            return !(!e2 || !e2.isBlock);
          }
          isLimit(t2) {
            const e2 = this.getDefinition(t2);
            return !!e2 && !(!e2.isLimit && !e2.isObject);
          }
          isObject(t2) {
            const e2 = this.getDefinition(t2);
            return !(!e2 || !e2.isObject);
          }
          isInline(t2) {
            const e2 = this.getDefinition(t2);
            return !(!e2 || !e2.isInline);
          }
          checkChild(t2, e2) {
            return !!e2 && this._checkContextMatch(e2, t2);
          }
          checkAttribute(t2, e2) {
            const n2 = this.getDefinition(t2.last);
            return !!n2 && n2.allowAttributes.includes(e2);
          }
          checkMerge(t2, e2 = null) {
            if (t2 instanceof ks) {
              const e3 = t2.nodeBefore, n2 = t2.nodeAfter;
              if (!(e3 instanceof ps))
                throw new hn.b("schema-check-merge-no-element-before: The node before the merge position must be an element.", this);
              if (!(n2 instanceof ps))
                throw new hn.b("schema-check-merge-no-element-after: The node after the merge position must be an element.", this);
              return this.checkMerge(e3, n2);
            }
            for (const n2 of e2.getChildren())
              if (!this.checkChild(t2, n2))
                return false;
            return true;
          }
          addChildCheck(t2) {
            this.on("checkChild", (e2, [n2, i2]) => {
              if (!i2)
                return;
              const o2 = t2(n2, i2);
              "boolean" == typeof o2 && (e2.stop(), e2.return = o2);
            }, { priority: "high" });
          }
          addAttributeCheck(t2) {
            this.on("checkAttribute", (e2, [n2, i2]) => {
              const o2 = t2(n2, i2);
              "boolean" == typeof o2 && (e2.stop(), e2.return = o2);
            }, { priority: "high" });
          }
          setAttributeProperties(t2, e2) {
            this._attributeProperties[t2] = Object.assign(this.getAttributeProperties(t2), e2);
          }
          getAttributeProperties(t2) {
            return this._attributeProperties[t2] || {};
          }
          getLimitElement(t2) {
            let e2;
            if (t2 instanceof ks)
              e2 = t2.parent;
            else {
              e2 = (t2 instanceof xs ? [t2] : Array.from(t2.getRanges())).reduce((t3, e3) => {
                const n2 = e3.getCommonAncestor();
                return t3 ? t3.getCommonAncestor(n2, { includeSelf: true }) : n2;
              }, null);
            }
            for (; !this.isLimit(e2) && e2.parent; )
              e2 = e2.parent;
            return e2;
          }
          checkAttributeInSelection(t2, e2) {
            if (t2.isCollapsed) {
              const n2 = [...t2.getFirstPosition().getAncestors(), new fs("", t2.getAttributes())];
              return this.checkAttribute(n2, e2);
            }
            {
              const n2 = t2.getRanges();
              for (const t3 of n2)
                for (const n3 of t3)
                  if (this.checkAttribute(n3.item, e2))
                    return true;
            }
            return false;
          }
          *getValidRanges(t2, e2) {
            t2 = function* (t3) {
              for (const e3 of t3)
                yield* e3.getMinimalFlatRanges();
            }(t2);
            for (const n2 of t2)
              yield* this._getValidRangesForRange(n2, e2);
          }
          getNearestSelectionRange(t2, e2 = "both") {
            if (this.checkChild(t2, "$text"))
              return new xs(t2);
            let n2, i2;
            const o2 = t2.getAncestors().reverse().find((t3) => this.isLimit(t3)) || t2.root;
            "both" != e2 && "backward" != e2 || (n2 = new bs({ boundaries: xs._createIn(o2), startPosition: t2, direction: "backward" })), "both" != e2 && "forward" != e2 || (i2 = new bs({ boundaries: xs._createIn(o2), startPosition: t2 }));
            for (const t3 of function* (t4, e3) {
              let n3 = false;
              for (; !n3; ) {
                if (n3 = true, t4) {
                  const e4 = t4.next();
                  e4.done || (n3 = false, yield { walker: t4, value: e4.value });
                }
                if (e3) {
                  const t5 = e3.next();
                  t5.done || (n3 = false, yield { walker: e3, value: t5.value });
                }
              }
            }(n2, i2)) {
              const e3 = t3.walker == n2 ? "elementEnd" : "elementStart", i3 = t3.value;
              if (i3.type == e3 && this.isObject(i3.item))
                return xs._createOn(i3.item);
              if (this.checkChild(i3.nextPosition, "$text"))
                return new xs(i3.nextPosition);
            }
            return null;
          }
          findAllowedParent(t2, e2) {
            let n2 = t2.parent;
            for (; n2; ) {
              if (this.checkChild(n2, e2))
                return n2;
              if (this.isLimit(n2))
                return null;
              n2 = n2.parent;
            }
            return null;
          }
          removeDisallowedAttributes(t2, e2) {
            for (const n2 of t2)
              if (n2.is("text"))
                ga(this, n2, e2);
              else {
                const t3 = xs._createIn(n2).getPositions();
                for (const n3 of t3) {
                  ga(this, n3.nodeBefore || n3.parent, e2);
                }
              }
          }
          createContext(t2) {
            return new oa(t2);
          }
          _clearCache() {
            this._compiledDefinitions = null;
          }
          _compile() {
            const t2 = {}, e2 = this._sourceDefinitions, n2 = Object.keys(e2);
            for (const i2 of n2)
              t2[i2] = ra(e2[i2], i2);
            for (const e3 of n2)
              sa(t2, e3);
            for (const e3 of n2)
              aa(t2, e3);
            for (const e3 of n2)
              ca(t2, e3), la(t2, e3);
            for (const e3 of n2)
              da(t2, e3), ua(t2, e3);
            this._compiledDefinitions = t2;
          }
          _checkContextMatch(t2, e2, n2 = e2.length - 1) {
            const i2 = e2.getItem(n2);
            if (t2.allowIn.includes(i2.name)) {
              if (0 == n2)
                return true;
              {
                const t3 = this.getDefinition(i2);
                return this._checkContextMatch(t3, e2, n2 - 1);
              }
            }
            return false;
          }
          *_getValidRangesForRange(t2, e2) {
            let n2 = t2.start, i2 = t2.start;
            for (const o2 of t2.getItems({ shallow: true }))
              o2.is("element") && (yield* this._getValidRangesForRange(xs._createIn(o2), e2)), this.checkAttribute(o2, e2) || (n2.isEqual(i2) || (yield new xs(n2, i2)), n2 = ks._createAfter(o2)), i2 = ks._createAfter(o2);
            n2.isEqual(i2) || (yield new xs(n2, i2));
          }
        }
        xn(ia, Ui);
        class oa {
          constructor(t2) {
            if (t2 instanceof oa)
              return t2;
            "string" == typeof t2 ? t2 = [t2] : Array.isArray(t2) || (t2 = t2.getAncestors({ includeSelf: true })), t2[0] && "string" != typeof t2[0] && t2[0].is("documentFragment") && t2.shift(), this._items = t2.map(ma);
          }
          get length() {
            return this._items.length;
          }
          get last() {
            return this._items[this._items.length - 1];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
          push(t2) {
            const e2 = new oa([t2]);
            return e2._items = [...this._items, ...e2._items], e2;
          }
          getItem(t2) {
            return this._items[t2];
          }
          *getNames() {
            yield* this._items.map((t2) => t2.name);
          }
          endsWith(t2) {
            return Array.from(this.getNames()).join(" ").endsWith(t2);
          }
          startsWith(t2) {
            return Array.from(this.getNames()).join(" ").startsWith(t2);
          }
        }
        function ra(t2, e2) {
          const n2 = { name: e2, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], inheritTypesFrom: [] };
          return function(t3, e3) {
            for (const n3 of t3) {
              const t4 = Object.keys(n3).filter((t5) => t5.startsWith("is"));
              for (const i2 of t4)
                e3[i2] = n3[i2];
            }
          }(t2, n2), ha(t2, n2, "allowIn"), ha(t2, n2, "allowContentOf"), ha(t2, n2, "allowWhere"), ha(t2, n2, "allowAttributes"), ha(t2, n2, "allowAttributesOf"), ha(t2, n2, "inheritTypesFrom"), function(t3, e3) {
            for (const n3 of t3) {
              const t4 = n3.inheritAllFrom;
              t4 && (e3.allowContentOf.push(t4), e3.allowWhere.push(t4), e3.allowAttributesOf.push(t4), e3.inheritTypesFrom.push(t4));
            }
          }(t2, n2), n2;
        }
        function sa(t2, e2) {
          for (const n2 of t2[e2].allowContentOf)
            if (t2[n2]) {
              fa(t2, n2).forEach((t3) => {
                t3.allowIn.push(e2);
              });
            }
          delete t2[e2].allowContentOf;
        }
        function aa(t2, e2) {
          for (const n2 of t2[e2].allowWhere) {
            const i2 = t2[n2];
            if (i2) {
              const n3 = i2.allowIn;
              t2[e2].allowIn.push(...n3);
            }
          }
          delete t2[e2].allowWhere;
        }
        function ca(t2, e2) {
          for (const n2 of t2[e2].allowAttributesOf) {
            const i2 = t2[n2];
            if (i2) {
              const n3 = i2.allowAttributes;
              t2[e2].allowAttributes.push(...n3);
            }
          }
          delete t2[e2].allowAttributesOf;
        }
        function la(t2, e2) {
          const n2 = t2[e2];
          for (const e3 of n2.inheritTypesFrom) {
            const i2 = t2[e3];
            if (i2) {
              const t3 = Object.keys(i2).filter((t4) => t4.startsWith("is"));
              for (const e4 of t3)
                e4 in n2 || (n2[e4] = i2[e4]);
            }
          }
          delete n2.inheritTypesFrom;
        }
        function da(t2, e2) {
          const n2 = t2[e2], i2 = n2.allowIn.filter((e3) => t2[e3]);
          n2.allowIn = Array.from(new Set(i2));
        }
        function ua(t2, e2) {
          const n2 = t2[e2];
          n2.allowAttributes = Array.from(new Set(n2.allowAttributes));
        }
        function ha(t2, e2, n2) {
          for (const i2 of t2)
            "string" == typeof i2[n2] ? e2[n2].push(i2[n2]) : Array.isArray(i2[n2]) && e2[n2].push(...i2[n2]);
        }
        function fa(t2, e2) {
          const n2 = t2[e2];
          return (i2 = t2, Object.keys(i2).map((t3) => i2[t3])).filter((t3) => t3.allowIn.includes(n2.name));
          var i2;
        }
        function ma(t2) {
          return "string" == typeof t2 ? { name: t2, *getAttributeKeys() {
          }, getAttribute() {
          } } : { name: t2.is("element") ? t2.name : "$text", *getAttributeKeys() {
            yield* t2.getAttributeKeys();
          }, getAttribute: (e2) => t2.getAttribute(e2) };
        }
        function ga(t2, e2, n2) {
          for (const i2 of e2.getAttributeKeys())
            t2.checkAttribute(e2, i2) || n2.removeAttribute(i2, e2);
        }
        class pa {
          constructor(t2 = {}) {
            this._splitParts = /* @__PURE__ */ new Map(), this._modelCursor = null, this.conversionApi = Object.assign({}, t2), this.conversionApi.convertItem = this._convertItem.bind(this), this.conversionApi.convertChildren = this._convertChildren.bind(this), this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this), this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
          }
          convert(t2, e2, n2 = ["$root"]) {
            this.fire("viewCleanup", t2), this._modelCursor = function(t3, e3) {
              let n3;
              for (const i3 of new oa(t3)) {
                const t4 = {};
                for (const e4 of i3.getAttributeKeys())
                  t4[e4] = i3.getAttribute(e4);
                const o3 = e3.createElement(i3.name, t4);
                n3 && e3.append(o3, n3), n3 = ks._createAt(o3, 0);
              }
              return n3;
            }(n2, e2), this.conversionApi.writer = e2, this.conversionApi.consumable = ea.createFrom(t2), this.conversionApi.store = {};
            const { modelRange: i2 } = this._convertItem(t2, this._modelCursor), o2 = e2.createDocumentFragment();
            if (i2) {
              this._removeEmptyElements();
              for (const t3 of Array.from(this._modelCursor.parent.getChildren()))
                e2.append(t3, o2);
              o2.markers = function(t3, e3) {
                const n3 = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Map(), o3 = xs._createIn(t3).getItems();
                for (const t4 of o3)
                  "$marker" == t4.name && n3.add(t4);
                for (const t4 of n3) {
                  const n4 = t4.getAttribute("data-name"), o4 = e3.createPositionBefore(t4);
                  i3.has(n4) ? i3.get(n4).end = o4.clone() : i3.set(n4, new xs(o4.clone())), e3.remove(t4);
                }
                return i3;
              }(o2, e2);
            }
            return this._modelCursor = null, this._splitParts.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o2;
          }
          _convertItem(t2, e2) {
            const n2 = Object.assign({ viewItem: t2, modelCursor: e2, modelRange: null });
            if (t2.is("element") ? this.fire("element:" + t2.name, n2, this.conversionApi) : t2.is("text") ? this.fire("text", n2, this.conversionApi) : this.fire("documentFragment", n2, this.conversionApi), n2.modelRange && !(n2.modelRange instanceof xs))
              throw new hn.b("view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.", this);
            return { modelRange: n2.modelRange, modelCursor: n2.modelCursor };
          }
          _convertChildren(t2, e2) {
            const n2 = new xs(e2);
            let i2 = e2;
            for (const e3 of Array.from(t2.getChildren())) {
              const t3 = this._convertItem(e3, i2);
              t3.modelRange instanceof xs && (n2.end = t3.modelRange.end, i2 = t3.modelCursor);
            }
            return { modelRange: n2, modelCursor: i2 };
          }
          _splitToAllowedParent(t2, e2) {
            const n2 = this.conversionApi.schema.findAllowedParent(e2, t2);
            if (!n2)
              return null;
            if (n2 === e2.parent)
              return { position: e2 };
            if (this._modelCursor.parent.getAncestors().includes(n2))
              return null;
            const i2 = this.conversionApi.writer.split(e2, n2), o2 = [];
            for (const t3 of i2.range.getWalker())
              if ("elementEnd" == t3.type)
                o2.push(t3.item);
              else {
                const e3 = o2.pop(), n3 = t3.item;
                this._registerSplitPair(e3, n3);
              }
            return { position: i2.position, cursorParent: i2.range.end.parent };
          }
          _registerSplitPair(t2, e2) {
            this._splitParts.has(t2) || this._splitParts.set(t2, [t2]);
            const n2 = this._splitParts.get(t2);
            this._splitParts.set(e2, n2), n2.push(e2);
          }
          _getSplitParts(t2) {
            let e2;
            return e2 = this._splitParts.has(t2) ? this._splitParts.get(t2) : [t2], e2;
          }
          _removeEmptyElements() {
            let t2 = false;
            for (const e2 of this._splitParts.keys())
              e2.isEmpty && (this.conversionApi.writer.remove(e2), this._splitParts.delete(e2), t2 = true);
            t2 && this._removeEmptyElements();
          }
        }
        xn(pa, gn);
        class ba {
          constructor(t2, e2) {
            this.model = t2, this.stylesProcessor = e2, this.processor, this.mapper = new As(), this.downcastDispatcher = new Ps({ mapper: this.mapper }), this.downcastDispatcher.on("insert:$text", (t3, e3, n2) => {
              if (!n2.consumable.consume(e3.item, "insert"))
                return;
              const i2 = n2.writer, o2 = n2.mapper.toViewPosition(e3.range.start), r2 = i2.createText(e3.item.data);
              i2.insert(o2, r2);
            }, { priority: "lowest" }), this.upcastDispatcher = new pa({ schema: t2.schema }), this.viewDocument = new oo(e2), this._viewWriter = new Ao(this.viewDocument), this.upcastDispatcher.on("text", (t3, e3, n2) => {
              if (n2.schema.checkChild(e3.modelCursor, "$text") && n2.consumable.consume(e3.viewItem)) {
                const t4 = n2.writer.createText(e3.viewItem.data);
                n2.writer.insert(t4, e3.modelCursor), e3.modelRange = xs._createFromPositionAndShift(e3.modelCursor, t4.offsetSize), e3.modelCursor = e3.modelRange.end;
              }
            }, { priority: "lowest" }), this.upcastDispatcher.on("element", (t3, e3, n2) => {
              if (!e3.modelRange && n2.consumable.consume(e3.viewItem, { name: true })) {
                const { modelRange: t4, modelCursor: i2 } = n2.convertChildren(e3.viewItem, e3.modelCursor);
                e3.modelRange = t4, e3.modelCursor = i2;
              }
            }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (t3, e3, n2) => {
              if (!e3.modelRange && n2.consumable.consume(e3.viewItem, { name: true })) {
                const { modelRange: t4, modelCursor: i2 } = n2.convertChildren(e3.viewItem, e3.modelCursor);
                e3.modelRange = t4, e3.modelCursor = i2;
              }
            }, { priority: "lowest" }), this.decorate("init"), this.on("init", () => {
              this.fire("ready");
            }, { priority: "lowest" });
          }
          get(t2) {
            const { rootName: e2 = "main", trim: n2 = "empty" } = t2 || {};
            if (!this._checkIfRootsExists([e2]))
              throw new hn.b("datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.", this);
            const i2 = this.model.document.getRoot(e2);
            return "empty" !== n2 || this.model.hasContent(i2, { ignoreWhitespaces: true }) ? this.stringify(i2) : "";
          }
          stringify(t2) {
            const e2 = this.toView(t2);
            return this.processor.toData(e2);
          }
          toView(t2) {
            const e2 = this.viewDocument, n2 = this._viewWriter;
            this.mapper.clearBindings();
            const i2 = xs._createIn(t2), o2 = new xo(e2);
            if (this.mapper.bindElements(t2, o2), this.downcastDispatcher.convertInsert(i2, n2), !t2.is("documentFragment")) {
              const e3 = function(t3) {
                const e4 = [], n3 = t3.root.document;
                if (!n3)
                  return [];
                const i3 = xs._createIn(t3);
                for (const t4 of n3.model.markers) {
                  const n4 = i3.getIntersection(t4.getRange());
                  n4 && e4.push([t4.name, n4]);
                }
                return e4;
              }(t2);
              for (const [t3, i3] of e3)
                this.downcastDispatcher.convertMarkerAdd(t3, i3, n2);
            }
            return o2;
          }
          init(t2) {
            if (this.model.document.version)
              throw new hn.b("datacontroller-init-document-not-empty: Trying to set initial data to not empty document.", this);
            let e2 = {};
            if ("string" == typeof t2 ? e2.main = t2 : e2 = t2, !this._checkIfRootsExists(Object.keys(e2)))
              throw new hn.b("datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.", this);
            return this.model.enqueueChange("transparent", (t3) => {
              for (const n2 of Object.keys(e2)) {
                const i2 = this.model.document.getRoot(n2);
                t3.insert(this.parse(e2[n2], i2), i2, 0);
              }
            }), Promise.resolve();
          }
          set(t2) {
            let e2 = {};
            if ("string" == typeof t2 ? e2.main = t2 : e2 = t2, !this._checkIfRootsExists(Object.keys(e2)))
              throw new hn.b("datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.", this);
            this.model.enqueueChange("transparent", (t3) => {
              t3.setSelection(null), t3.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
              for (const n2 of Object.keys(e2)) {
                const i2 = this.model.document.getRoot(n2);
                t3.remove(t3.createRangeIn(i2)), t3.insert(this.parse(e2[n2], i2), i2, 0);
              }
            });
          }
          parse(t2, e2 = "$root") {
            const n2 = this.processor.toView(t2);
            return this.toModel(n2, e2);
          }
          toModel(t2, e2 = "$root") {
            return this.model.change((n2) => this.upcastDispatcher.convert(t2, n2, e2));
          }
          addStyleProcessorRules(t2) {
            t2(this.stylesProcessor);
          }
          destroy() {
            this.stopListening();
          }
          _checkIfRootsExists(t2) {
            for (const e2 of t2)
              if (!this.model.document.getRootNames().includes(e2))
                return false;
            return true;
          }
        }
        xn(ba, Ui);
        class wa {
          constructor(t2, e2) {
            this._helpers = /* @__PURE__ */ new Map(), this._downcast = Array.isArray(t2) ? t2 : [t2], this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }), this._upcast = Array.isArray(e2) ? e2 : [e2], this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
          }
          addAlias(t2, e2) {
            const n2 = this._downcast.includes(e2);
            if (!this._upcast.includes(e2) && !n2)
              throw new hn.b("conversion-add-alias-dispatcher-not-registered: Trying to register and alias for a dispatcher that nas not been registered.", this);
            this._createConversionHelpers({ name: t2, dispatchers: [e2], isDowncast: n2 });
          }
          for(t2) {
            if (!this._helpers.has(t2))
              throw new hn.b("conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.", this);
            return this._helpers.get(t2);
          }
          elementToElement(t2) {
            this.for("downcast").elementToElement(t2);
            for (const { model: e2, view: n2 } of ka(t2))
              this.for("upcast").elementToElement({ model: e2, view: n2, converterPriority: t2.converterPriority });
          }
          attributeToElement(t2) {
            this.for("downcast").attributeToElement(t2);
            for (const { model: e2, view: n2 } of ka(t2))
              this.for("upcast").elementToAttribute({ view: n2, model: e2, converterPriority: t2.converterPriority });
          }
          attributeToAttribute(t2) {
            this.for("downcast").attributeToAttribute(t2);
            for (const { model: e2, view: n2 } of ka(t2))
              this.for("upcast").attributeToAttribute({ view: n2, model: e2 });
          }
          _createConversionHelpers({ name: t2, dispatchers: e2, isDowncast: n2 }) {
            if (this._helpers.has(t2))
              throw new hn.b("conversion-group-exists: Trying to register a group name that has already been registered.", this);
            const i2 = n2 ? new Us(e2) : new $s(e2);
            this._helpers.set(t2, i2);
          }
        }
        function* ka(t2) {
          if (t2.model.values)
            for (const e2 of t2.model.values) {
              const n2 = { key: t2.model.key, value: e2 }, i2 = t2.view[e2], o2 = t2.upcastAlso ? t2.upcastAlso[e2] : void 0;
              yield* _a(n2, i2, o2);
            }
          else
            yield* _a(t2.model, t2.view, t2.upcastAlso);
        }
        function* _a(t2, e2, n2) {
          if (yield { model: t2, view: e2 }, n2) {
            n2 = Array.isArray(n2) ? n2 : [n2];
            for (const e3 of n2)
              yield { model: t2, view: e3 };
          }
        }
        class va {
          constructor(t2 = "default") {
            this.operations = [], this.type = t2;
          }
          get baseVersion() {
            for (const t2 of this.operations)
              if (null !== t2.baseVersion)
                return t2.baseVersion;
            return null;
          }
          addOperation(t2) {
            return t2.batch = this, this.operations.push(t2), t2;
          }
        }
        class ya {
          constructor(t2) {
            this.baseVersion = t2, this.isDocumentOperation = null !== this.baseVersion, this.batch = null;
          }
          _validate() {
          }
          toJSON() {
            const t2 = Object.assign({}, this);
            return t2.__className = this.constructor.className, delete t2.batch, delete t2.isDocumentOperation, t2;
          }
          static get className() {
            return "Operation";
          }
          static fromJSON(t2) {
            return new this(t2.baseVersion);
          }
        }
        class xa {
          constructor(t2) {
            this.markers = /* @__PURE__ */ new Map(), this._children = new gs(), t2 && this._insertChild(0, t2);
          }
          [Symbol.iterator]() {
            return this.getChildren();
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t2) {
            return "documentFragment" === t2 || "model:documentFragment" === t2;
          }
          getChild(t2) {
            return this._children.getNode(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t2) {
            return this._children.getNodeIndex(t2);
          }
          getChildStartOffset(t2) {
            return this._children.getNodeStartOffset(t2);
          }
          getPath() {
            return [];
          }
          getNodeByPath(t2) {
            let e2 = this;
            for (const n2 of t2)
              e2 = e2.getChild(e2.offsetToIndex(n2));
            return e2;
          }
          offsetToIndex(t2) {
            return this._children.offsetToIndex(t2);
          }
          toJSON() {
            const t2 = [];
            for (const e2 of this._children)
              t2.push(e2.toJSON());
            return t2;
          }
          static fromJSON(t2) {
            const e2 = [];
            for (const n2 of t2)
              n2.name ? e2.push(ps.fromJSON(n2)) : e2.push(fs.fromJSON(n2));
            return new xa(e2);
          }
          _appendChild(t2) {
            this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            const n2 = function(t3) {
              if ("string" == typeof t3)
                return [new fs(t3)];
              yn(t3) || (t3 = [t3]);
              return Array.from(t3).map((t4) => "string" == typeof t4 ? new fs(t4) : t4 instanceof ms ? new fs(t4.data, t4.getAttributes()) : t4);
            }(e2);
            for (const t3 of n2)
              null !== t3.parent && t3._remove(), t3.parent = this;
            this._children._insertNodes(t2, n2);
          }
          _removeChildren(t2, e2 = 1) {
            const n2 = this._children._removeNodes(t2, e2);
            for (const t3 of n2)
              t3.parent = null;
            return n2;
          }
        }
        function Aa(t2, e2) {
          const n2 = (e2 = Pa(e2)).reduce((t3, e3) => t3 + e3.offsetSize, 0), i2 = t2.parent;
          Ma(t2);
          const o2 = t2.index;
          return i2._insertChild(o2, e2), Sa(i2, o2 + e2.length), Sa(i2, o2), new xs(t2, t2.getShiftedBy(n2));
        }
        function Ta(t2) {
          if (!t2.isFlat)
            throw new hn.b("operation-utils-remove-range-not-flat: Trying to remove a range which starts and ends in different element.", this);
          const e2 = t2.start.parent;
          Ma(t2.start), Ma(t2.end);
          const n2 = e2._removeChildren(t2.start.index, t2.end.index - t2.start.index);
          return Sa(e2, t2.start.index), n2;
        }
        function Ca(t2, e2) {
          if (!t2.isFlat)
            throw new hn.b("operation-utils-move-range-not-flat: Trying to move a range which starts and ends in different element.", this);
          const n2 = Ta(t2);
          return Aa(e2 = e2._getTransformedByDeletion(t2.start, t2.end.offset - t2.start.offset), n2);
        }
        function Pa(t2) {
          const e2 = [];
          t2 instanceof Array || (t2 = [t2]);
          for (let n2 = 0; n2 < t2.length; n2++)
            if ("string" == typeof t2[n2])
              e2.push(new fs(t2[n2]));
            else if (t2[n2] instanceof ms)
              e2.push(new fs(t2[n2].data, t2[n2].getAttributes()));
            else if (t2[n2] instanceof xa || t2[n2] instanceof gs)
              for (const i2 of t2[n2])
                e2.push(i2);
            else
              t2[n2] instanceof hs && e2.push(t2[n2]);
          for (let t3 = 1; t3 < e2.length; t3++) {
            const n2 = e2[t3], i2 = e2[t3 - 1];
            n2 instanceof fs && i2 instanceof fs && Ea(n2, i2) && (e2.splice(t3 - 1, 2, new fs(i2.data + n2.data, i2.getAttributes())), t3--);
          }
          return e2;
        }
        function Sa(t2, e2) {
          const n2 = t2.getChild(e2 - 1), i2 = t2.getChild(e2);
          if (n2 && i2 && n2.is("text") && i2.is("text") && Ea(n2, i2)) {
            const o2 = new fs(n2.data + i2.data, n2.getAttributes());
            t2._removeChildren(e2 - 1, 2), t2._insertChild(e2 - 1, o2);
          }
        }
        function Ma(t2) {
          const e2 = t2.textNode, n2 = t2.parent;
          if (e2) {
            const i2 = t2.offset - e2.startOffset, o2 = e2.index;
            n2._removeChildren(o2, 1);
            const r2 = new fs(e2.data.substr(0, i2), e2.getAttributes()), s2 = new fs(e2.data.substr(i2), e2.getAttributes());
            n2._insertChild(o2, [r2, s2]);
          }
        }
        function Ea(t2, e2) {
          const n2 = t2.getAttributes(), i2 = e2.getAttributes();
          for (const t3 of n2) {
            if (t3[1] !== e2.getAttribute(t3[0]))
              return false;
            i2.next();
          }
          return i2.next().done;
        }
        var Ia = function(t2, e2) {
          return Sr(t2, e2);
        };
        class Na extends ya {
          constructor(t2, e2, n2, i2, o2) {
            super(o2), this.range = t2.clone(), this.key = e2, this.oldValue = void 0 === n2 ? null : n2, this.newValue = void 0 === i2 ? null : i2;
          }
          get type() {
            return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute";
          }
          clone() {
            return new Na(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Na(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.range = this.range.toJSON(), t2;
          }
          _validate() {
            if (!this.range.isFlat)
              throw new hn.b("attribute-operation-range-not-flat: The range to change is not flat.", this);
            for (const t2 of this.range.getItems({ shallow: true })) {
              if (null !== this.oldValue && !Ia(t2.getAttribute(this.key), this.oldValue))
                throw new hn.b("attribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.", this, { item: t2, key: this.key, value: this.oldValue });
              if (null === this.oldValue && null !== this.newValue && t2.hasAttribute(this.key))
                throw new hn.b("attribute-operation-attribute-exists: The attribute with given key already exists.", this, { node: t2, key: this.key });
            }
          }
          _execute() {
            Ia(this.oldValue, this.newValue) || function(t2, e2, n2) {
              Ma(t2.start), Ma(t2.end);
              for (const i2 of t2.getItems({ shallow: true })) {
                const t3 = i2.is("textProxy") ? i2.textNode : i2;
                null !== n2 ? t3._setAttribute(e2, n2) : t3._removeAttribute(e2), Sa(t3.parent, t3.index);
              }
              Sa(t2.end.parent, t2.end.index);
            }(this.range, this.key, this.newValue);
          }
          static get className() {
            return "AttributeOperation";
          }
          static fromJSON(t2, e2) {
            return new Na(xs.fromJSON(t2.range, e2), t2.key, t2.oldValue, t2.newValue, t2.baseVersion);
          }
        }
        class Oa extends ya {
          constructor(t2, e2) {
            super(null), this.sourcePosition = t2.clone(), this.howMany = e2;
          }
          get type() {
            return "detach";
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.sourcePosition = this.sourcePosition.toJSON(), t2;
          }
          _validate() {
            if (this.sourcePosition.root.document)
              throw new hn.b("detach-operation-on-document-node: Cannot detach document node.", this);
          }
          _execute() {
            Ta(xs._createFromPositionAndShift(this.sourcePosition, this.howMany));
          }
          static get className() {
            return "DetachOperation";
          }
        }
        class Ra extends ya {
          constructor(t2, e2, n2, i2) {
            super(i2), this.sourcePosition = t2.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e2, this.targetPosition = n2.clone(), this.targetPosition.stickiness = "toNone";
          }
          get type() {
            return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move";
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
          }
          getMovedRangeStart() {
            return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
          }
          getReversed() {
            const t2 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
            return new this.constructor(this.getMovedRangeStart(), this.howMany, t2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.sourcePosition.parent, e2 = this.targetPosition.parent, n2 = this.sourcePosition.offset, i2 = this.targetPosition.offset;
            if (n2 + this.howMany > t2.maxOffset)
              throw new hn.b("move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.", this);
            if (t2 === e2 && n2 < i2 && i2 < n2 + this.howMany)
              throw new hn.b("move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.", this);
            if (this.sourcePosition.root == this.targetPosition.root && "prefix" == In(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
              const t3 = this.sourcePosition.path.length - 1;
              if (this.targetPosition.path[t3] >= n2 && this.targetPosition.path[t3] < n2 + this.howMany)
                throw new hn.b("move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.", this);
            }
          }
          _execute() {
            Ca(xs._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.sourcePosition = this.sourcePosition.toJSON(), t2.targetPosition = this.targetPosition.toJSON(), t2;
          }
          static get className() {
            return "MoveOperation";
          }
          static fromJSON(t2, e2) {
            const n2 = ks.fromJSON(t2.sourcePosition, e2), i2 = ks.fromJSON(t2.targetPosition, e2);
            return new this(n2, t2.howMany, i2, t2.baseVersion);
          }
        }
        class Da extends ya {
          constructor(t2, e2, n2) {
            super(n2), this.position = t2.clone(), this.position.stickiness = "toNone", this.nodes = new gs(Pa(e2)), this.shouldReceiveAttributes = false;
          }
          get type() {
            return "insert";
          }
          get howMany() {
            return this.nodes.maxOffset;
          }
          clone() {
            const t2 = new gs([...this.nodes].map((t3) => t3._clone(true))), e2 = new Da(this.position, t2, this.baseVersion);
            return e2.shouldReceiveAttributes = this.shouldReceiveAttributes, e2;
          }
          getReversed() {
            const t2 = this.position.root.document.graveyard, e2 = new ks(t2, [0]);
            return new Ra(this.position, this.nodes.maxOffset, e2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.position.parent;
            if (!t2 || t2.maxOffset < this.position.offset)
              throw new hn.b("insert-operation-position-invalid: Insertion position is invalid.", this);
          }
          _execute() {
            const t2 = this.nodes;
            this.nodes = new gs([...t2].map((t3) => t3._clone(true))), Aa(this.position, t2);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.position = this.position.toJSON(), t2.nodes = this.nodes.toJSON(), t2;
          }
          static get className() {
            return "InsertOperation";
          }
          static fromJSON(t2, e2) {
            const n2 = [];
            for (const e3 of t2.nodes)
              e3.name ? n2.push(ps.fromJSON(e3)) : n2.push(fs.fromJSON(e3));
            const i2 = new Da(ks.fromJSON(t2.position, e2), n2, t2.baseVersion);
            return i2.shouldReceiveAttributes = t2.shouldReceiveAttributes, i2;
          }
        }
        class La extends ya {
          constructor(t2, e2, n2, i2, o2, r2) {
            super(r2), this.name = t2, this.oldRange = e2 ? e2.clone() : null, this.newRange = n2 ? n2.clone() : null, this.affectsData = o2, this._markers = i2;
          }
          get type() {
            return "marker";
          }
          clone() {
            return new La(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
          }
          getReversed() {
            return new La(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
          }
          _execute() {
            const t2 = this.newRange ? "_set" : "_remove";
            this._markers[t2](this.name, this.newRange, true, this.affectsData);
          }
          toJSON() {
            const t2 = super.toJSON();
            return this.oldRange && (t2.oldRange = this.oldRange.toJSON()), this.newRange && (t2.newRange = this.newRange.toJSON()), delete t2._markers, t2;
          }
          static get className() {
            return "MarkerOperation";
          }
          static fromJSON(t2, e2) {
            return new La(t2.name, t2.oldRange ? xs.fromJSON(t2.oldRange, e2) : null, t2.newRange ? xs.fromJSON(t2.newRange, e2) : null, e2.model.markers, t2.affectsData, t2.baseVersion);
          }
        }
        class ja extends ya {
          constructor(t2, e2, n2, i2) {
            super(i2), this.position = t2, this.position.stickiness = "toNext", this.oldName = e2, this.newName = n2;
          }
          get type() {
            return "rename";
          }
          clone() {
            return new ja(this.position.clone(), this.oldName, this.newName, this.baseVersion);
          }
          getReversed() {
            return new ja(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.position.nodeAfter;
            if (!(t2 instanceof ps))
              throw new hn.b("rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.", this);
            if (t2.name !== this.oldName)
              throw new hn.b("rename-operation-wrong-name: Element to change has different name than operation's old name.", this);
          }
          _execute() {
            this.position.nodeAfter.name = this.newName;
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.position = this.position.toJSON(), t2;
          }
          static get className() {
            return "RenameOperation";
          }
          static fromJSON(t2, e2) {
            return new ja(ks.fromJSON(t2.position, e2), t2.oldName, t2.newName, t2.baseVersion);
          }
        }
        class Va extends ya {
          constructor(t2, e2, n2, i2, o2) {
            super(o2), this.root = t2, this.key = e2, this.oldValue = n2, this.newValue = i2;
          }
          get type() {
            return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute";
          }
          clone() {
            return new Va(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Va(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          _validate() {
            if (this.root != this.root.root || this.root.is("documentFragment"))
              throw new hn.b("rootattribute-operation-not-a-root: The element to change is not a root element.", this, { root: this.root, key: this.key });
            if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
              throw new hn.b("rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.", this, { root: this.root, key: this.key });
            if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
              throw new hn.b("rootattribute-operation-attribute-exists: The attribute with given key already exists.", this, { root: this.root, key: this.key });
          }
          _execute() {
            null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.root = this.root.toJSON(), t2;
          }
          static get className() {
            return "RootAttributeOperation";
          }
          static fromJSON(t2, e2) {
            if (!e2.getRoot(t2.root))
              throw new hn.b("rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.", this, { rootName: t2.root });
            return new Va(e2.getRoot(t2.root), t2.key, t2.oldValue, t2.newValue, t2.baseVersion);
          }
        }
        class za extends ya {
          constructor(t2, e2, n2, i2, o2) {
            super(o2), this.sourcePosition = t2.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e2, this.targetPosition = n2.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i2.clone();
          }
          get type() {
            return "merge";
          }
          get deletionPosition() {
            return new ks(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
          }
          get movedRange() {
            const t2 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new xs(this.sourcePosition, t2);
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
          }
          getReversed() {
            const t2 = this.targetPosition._getTransformedByMergeOperation(this), e2 = this.sourcePosition.path.slice(0, -1), n2 = new ks(this.sourcePosition.root, e2)._getTransformedByMergeOperation(this), i2 = new Ba(t2, this.howMany, this.graveyardPosition, this.baseVersion + 1);
            return i2.insertionPosition = n2, i2;
          }
          _validate() {
            const t2 = this.sourcePosition.parent, e2 = this.targetPosition.parent;
            if (!t2.parent)
              throw new hn.b("merge-operation-source-position-invalid: Merge source position is invalid.", this);
            if (!e2.parent)
              throw new hn.b("merge-operation-target-position-invalid: Merge target position is invalid.", this);
            if (this.howMany != t2.maxOffset)
              throw new hn.b("merge-operation-how-many-invalid: Merge operation specifies wrong number of nodes to move.", this);
          }
          _execute() {
            const t2 = this.sourcePosition.parent;
            Ca(xs._createIn(t2), this.targetPosition), Ca(xs._createOn(t2), this.graveyardPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.sourcePosition = t2.sourcePosition.toJSON(), t2.targetPosition = t2.targetPosition.toJSON(), t2.graveyardPosition = t2.graveyardPosition.toJSON(), t2;
          }
          static get className() {
            return "MergeOperation";
          }
          static fromJSON(t2, e2) {
            const n2 = ks.fromJSON(t2.sourcePosition, e2), i2 = ks.fromJSON(t2.targetPosition, e2), o2 = ks.fromJSON(t2.graveyardPosition, e2);
            return new this(n2, t2.howMany, i2, o2, t2.baseVersion);
          }
        }
        class Ba extends ya {
          constructor(t2, e2, n2, i2) {
            super(i2), this.splitPosition = t2.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e2, this.insertionPosition = Ba.getInsertionPosition(t2), this.insertionPosition.stickiness = "toNone", this.graveyardPosition = n2 ? n2.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
          }
          get type() {
            return "split";
          }
          get moveTargetPosition() {
            const t2 = this.insertionPosition.path.slice();
            return t2.push(0), new ks(this.insertionPosition.root, t2);
          }
          get movedRange() {
            const t2 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new xs(this.splitPosition, t2);
          }
          clone() {
            const t2 = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
            return t2.insertionPosition = this.insertionPosition, t2;
          }
          getReversed() {
            const t2 = this.splitPosition.root.document.graveyard, e2 = new ks(t2, [0]);
            return new za(this.moveTargetPosition, this.howMany, this.splitPosition, e2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.splitPosition.parent, e2 = this.splitPosition.offset;
            if (!t2 || t2.maxOffset < e2)
              throw new hn.b("split-operation-position-invalid: Split position is invalid.", this);
            if (!t2.parent)
              throw new hn.b("split-operation-split-in-root: Cannot split root element.", this);
            if (this.howMany != t2.maxOffset - this.splitPosition.offset)
              throw new hn.b("split-operation-how-many-invalid: Split operation specifies wrong number of nodes to move.", this);
            if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
              throw new hn.b("split-operation-graveyard-position-invalid: Graveyard position invalid.", this);
          }
          _execute() {
            const t2 = this.splitPosition.parent;
            if (this.graveyardPosition)
              Ca(xs._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
            else {
              const e2 = t2._clone();
              Aa(this.insertionPosition, e2);
            }
            Ca(new xs(ks._createAt(t2, this.splitPosition.offset), ks._createAt(t2, t2.maxOffset)), this.moveTargetPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.splitPosition = this.splitPosition.toJSON(), t2.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t2.graveyardPosition = this.graveyardPosition.toJSON()), t2;
          }
          static get className() {
            return "SplitOperation";
          }
          static getInsertionPosition(t2) {
            const e2 = t2.path.slice(0, -1);
            return e2[e2.length - 1]++, new ks(t2.root, e2);
          }
          static fromJSON(t2, e2) {
            const n2 = ks.fromJSON(t2.splitPosition, e2), i2 = ks.fromJSON(t2.insertionPosition, e2), o2 = t2.graveyardPosition ? ks.fromJSON(t2.graveyardPosition, e2) : null, r2 = new this(n2, t2.howMany, o2, t2.baseVersion);
            return r2.insertionPosition = i2, r2;
          }
        }
        class Fa extends ps {
          constructor(t2, e2, n2 = "main") {
            super(e2), this._document = t2, this.rootName = n2;
          }
          get document() {
            return this._document;
          }
          is(t2, e2) {
            return e2 ? e2 === this.name && ("rootElement" === t2 || "model:rootElement" === t2 || "element" === t2 || "model:element" === t2) : "rootElement" === t2 || "model:rootElement" === t2 || "element" === t2 || "model:element" === t2 || t2 === this.name || t2 === "model:" + this.name || "node" === t2 || "model:node" === t2;
          }
          toJSON() {
            return this.rootName;
          }
        }
        class Ua {
          constructor(t2, e2) {
            this.model = t2, this.batch = e2;
          }
          createText(t2, e2) {
            return new fs(t2, e2);
          }
          createElement(t2, e2) {
            return new ps(t2, e2);
          }
          createDocumentFragment() {
            return new xa();
          }
          insert(t2, e2, n2 = 0) {
            if (this._assertWriterUsedCorrectly(), t2 instanceof fs && "" == t2.data)
              return;
            const i2 = ks._createAt(e2, n2);
            if (t2.parent) {
              if (Ga(t2.root, i2.root))
                return void this.move(xs._createOn(t2), i2);
              if (t2.root.document)
                throw new hn.b("model-writer-insert-forbidden-move: Cannot move a node from a document to a different tree. It is forbidden to move a node that was already in a document outside of it.", this);
              this.remove(t2);
            }
            const o2 = i2.root.document ? i2.root.document.version : null, r2 = new Da(i2, t2, o2);
            if (t2 instanceof fs && (r2.shouldReceiveAttributes = true), this.batch.addOperation(r2), this.model.applyOperation(r2), t2 instanceof xa)
              for (const [e3, n3] of t2.markers) {
                const t3 = ks._createAt(n3.root, 0), o3 = { range: new xs(n3.start._getCombined(t3, i2), n3.end._getCombined(t3, i2)), usingOperation: true, affectsData: true };
                this.model.markers.has(e3) ? this.updateMarker(e3, o3) : this.addMarker(e3, o3);
              }
          }
          insertText(t2, e2, n2, i2) {
            e2 instanceof xa || e2 instanceof ps || e2 instanceof ks ? this.insert(this.createText(t2), e2, n2) : this.insert(this.createText(t2, e2), n2, i2);
          }
          insertElement(t2, e2, n2, i2) {
            e2 instanceof xa || e2 instanceof ps || e2 instanceof ks ? this.insert(this.createElement(t2), e2, n2) : this.insert(this.createElement(t2, e2), n2, i2);
          }
          append(t2, e2) {
            this.insert(t2, e2, "end");
          }
          appendText(t2, e2, n2) {
            e2 instanceof xa || e2 instanceof ps ? this.insert(this.createText(t2), e2, "end") : this.insert(this.createText(t2, e2), n2, "end");
          }
          appendElement(t2, e2, n2) {
            e2 instanceof xa || e2 instanceof ps ? this.insert(this.createElement(t2), e2, "end") : this.insert(this.createElement(t2, e2), n2, "end");
          }
          setAttribute(t2, e2, n2) {
            if (this._assertWriterUsedCorrectly(), n2 instanceof xs) {
              const i2 = n2.getMinimalFlatRanges();
              for (const n3 of i2)
                Ha(this, t2, e2, n3);
            } else
              qa(this, t2, e2, n2);
          }
          setAttributes(t2, e2) {
            for (const [n2, i2] of Ln(t2))
              this.setAttribute(n2, i2, e2);
          }
          removeAttribute(t2, e2) {
            if (this._assertWriterUsedCorrectly(), e2 instanceof xs) {
              const n2 = e2.getMinimalFlatRanges();
              for (const e3 of n2)
                Ha(this, t2, null, e3);
            } else
              qa(this, t2, null, e2);
          }
          clearAttributes(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = (t3) => {
              for (const e3 of t3.getAttributeKeys())
                this.removeAttribute(e3, t3);
            };
            if (t2 instanceof xs)
              for (const n2 of t2.getItems())
                e2(n2);
            else
              e2(t2);
          }
          move(t2, e2, n2) {
            if (this._assertWriterUsedCorrectly(), !(t2 instanceof xs))
              throw new hn.b("writer-move-invalid-range: Invalid range to move.", this);
            if (!t2.isFlat)
              throw new hn.b("writer-move-range-not-flat: Range to move is not flat.", this);
            const i2 = ks._createAt(e2, n2);
            if (i2.isEqual(t2.start))
              return;
            if (this._addOperationForAffectedMarkers("move", t2), !Ga(t2.root, i2.root))
              throw new hn.b("writer-move-different-document: Range is going to be moved between different documents.", this);
            const o2 = t2.root.document ? t2.root.document.version : null, r2 = new Ra(t2.start, t2.end.offset - t2.start.offset, i2, o2);
            this.batch.addOperation(r2), this.model.applyOperation(r2);
          }
          remove(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = (t2 instanceof xs ? t2 : xs._createOn(t2)).getMinimalFlatRanges().reverse();
            for (const t3 of e2)
              this._addOperationForAffectedMarkers("move", t3), Ya(t3.start, t3.end.offset - t3.start.offset, this.batch, this.model);
          }
          merge(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = t2.nodeBefore, n2 = t2.nodeAfter;
            if (this._addOperationForAffectedMarkers("merge", t2), !(e2 instanceof ps))
              throw new hn.b("writer-merge-no-element-before: Node before merge position must be an element.", this);
            if (!(n2 instanceof ps))
              throw new hn.b("writer-merge-no-element-after: Node after merge position must be an element.", this);
            t2.root.document ? this._merge(t2) : this._mergeDetached(t2);
          }
          createPositionFromPath(t2, e2, n2) {
            return this.model.createPositionFromPath(t2, e2, n2);
          }
          createPositionAt(t2, e2) {
            return this.model.createPositionAt(t2, e2);
          }
          createPositionAfter(t2) {
            return this.model.createPositionAfter(t2);
          }
          createPositionBefore(t2) {
            return this.model.createPositionBefore(t2);
          }
          createRange(t2, e2) {
            return this.model.createRange(t2, e2);
          }
          createRangeIn(t2) {
            return this.model.createRangeIn(t2);
          }
          createRangeOn(t2) {
            return this.model.createRangeOn(t2);
          }
          createSelection(t2, e2, n2) {
            return this.model.createSelection(t2, e2, n2);
          }
          _mergeDetached(t2) {
            const e2 = t2.nodeBefore, n2 = t2.nodeAfter;
            this.move(xs._createIn(n2), ks._createAt(e2, "end")), this.remove(n2);
          }
          _merge(t2) {
            const e2 = ks._createAt(t2.nodeBefore, "end"), n2 = ks._createAt(t2.nodeAfter, 0), i2 = t2.root.document.graveyard, o2 = new ks(i2, [0]), r2 = t2.root.document.version, s2 = new za(n2, t2.nodeAfter.maxOffset, e2, o2, r2);
            this.batch.addOperation(s2), this.model.applyOperation(s2);
          }
          rename(t2, e2) {
            if (this._assertWriterUsedCorrectly(), !(t2 instanceof ps))
              throw new hn.b("writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.", this);
            const n2 = t2.root.document ? t2.root.document.version : null, i2 = new ja(ks._createBefore(t2), t2.name, e2, n2);
            this.batch.addOperation(i2), this.model.applyOperation(i2);
          }
          split(t2, e2) {
            this._assertWriterUsedCorrectly();
            let n2, i2, o2 = t2.parent;
            if (!o2.parent)
              throw new hn.b("writer-split-element-no-parent: Element with no parent can not be split.", this);
            if (e2 || (e2 = o2.parent), !t2.parent.getAncestors({ includeSelf: true }).includes(e2))
              throw new hn.b("writer-split-invalid-limit-element: Limit element is not a position ancestor.", this);
            do {
              const e3 = o2.root.document ? o2.root.document.version : null, r2 = o2.maxOffset - t2.offset, s2 = new Ba(t2, r2, null, e3);
              this.batch.addOperation(s2), this.model.applyOperation(s2), n2 || i2 || (n2 = o2, i2 = t2.parent.nextSibling), o2 = (t2 = this.createPositionAfter(t2.parent)).parent;
            } while (o2 !== e2);
            return { position: t2, range: new xs(ks._createAt(n2, "end"), ks._createAt(i2, 0)) };
          }
          wrap(t2, e2) {
            if (this._assertWriterUsedCorrectly(), !t2.isFlat)
              throw new hn.b("writer-wrap-range-not-flat: Range to wrap is not flat.", this);
            const n2 = e2 instanceof ps ? e2 : new ps(e2);
            if (n2.childCount > 0)
              throw new hn.b("writer-wrap-element-not-empty: Element to wrap with is not empty.", this);
            if (null !== n2.parent)
              throw new hn.b("writer-wrap-element-attached: Element to wrap with is already attached to tree model.", this);
            this.insert(n2, t2.start);
            const i2 = new xs(t2.start.getShiftedBy(1), t2.end.getShiftedBy(1));
            this.move(i2, ks._createAt(n2, 0));
          }
          unwrap(t2) {
            if (this._assertWriterUsedCorrectly(), null === t2.parent)
              throw new hn.b("writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.", this);
            this.move(xs._createIn(t2), this.createPositionAfter(t2)), this.remove(t2);
          }
          addMarker(t2, e2) {
            if (this._assertWriterUsedCorrectly(), !e2 || "boolean" != typeof e2.usingOperation)
              throw new hn.b("writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.", this);
            const n2 = e2.usingOperation, i2 = e2.range, o2 = void 0 !== e2.affectsData && e2.affectsData;
            if (this.model.markers.has(t2))
              throw new hn.b("writer-addMarker-marker-exists: Marker with provided name already exists.", this);
            if (!i2)
              throw new hn.b("writer-addMarker-no-range: Range parameter is required when adding a new marker.", this);
            return n2 ? (Wa(this, t2, null, i2, o2), this.model.markers.get(t2)) : this.model.markers._set(t2, i2, n2, o2);
          }
          updateMarker(t2, e2) {
            this._assertWriterUsedCorrectly();
            const n2 = "string" == typeof t2 ? t2 : t2.name, i2 = this.model.markers.get(n2);
            if (!i2)
              throw new hn.b("writer-updateMarker-marker-not-exists: Marker with provided name does not exists.", this);
            if (!e2)
              return void this.model.markers._refresh(i2);
            const o2 = "boolean" == typeof e2.usingOperation, r2 = "boolean" == typeof e2.affectsData, s2 = r2 ? e2.affectsData : i2.affectsData;
            if (!o2 && !e2.range && !r2)
              throw new hn.b("writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.", this);
            const a2 = i2.getRange(), c2 = e2.range ? e2.range : a2;
            o2 && e2.usingOperation !== i2.managedUsingOperations ? e2.usingOperation ? Wa(this, n2, null, c2, s2) : (Wa(this, n2, a2, null, s2), this.model.markers._set(n2, c2, void 0, s2)) : i2.managedUsingOperations ? Wa(this, n2, a2, c2, s2) : this.model.markers._set(n2, c2, void 0, s2);
          }
          removeMarker(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = "string" == typeof t2 ? t2 : t2.name;
            if (!this.model.markers.has(e2))
              throw new hn.b("writer-removeMarker-no-marker: Trying to remove marker which does not exist.", this);
            const n2 = this.model.markers.get(e2);
            n2.managedUsingOperations ? Wa(this, e2, n2.getRange(), null, n2.affectsData) : this.model.markers._remove(e2);
          }
          setSelection(t2, e2, n2) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(t2, e2, n2);
          }
          setSelectionFocus(t2, e2) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t2, e2);
          }
          setSelectionAttribute(t2, e2) {
            if (this._assertWriterUsedCorrectly(), "string" == typeof t2)
              this._setSelectionAttribute(t2, e2);
            else
              for (const [e3, n2] of Ln(t2))
                this._setSelectionAttribute(e3, n2);
          }
          removeSelectionAttribute(t2) {
            if (this._assertWriterUsedCorrectly(), "string" == typeof t2)
              this._removeSelectionAttribute(t2);
            else
              for (const e2 of t2)
                this._removeSelectionAttribute(e2);
          }
          overrideSelectionGravity() {
            return this.model.document.selection._overrideGravity();
          }
          restoreSelectionGravity(t2) {
            this.model.document.selection._restoreGravity(t2);
          }
          _setSelectionAttribute(t2, e2) {
            const n2 = this.model.document.selection;
            if (n2.isCollapsed && n2.anchor.parent.isEmpty) {
              const i2 = js._getStoreAttributeKey(t2);
              this.setAttribute(i2, e2, n2.anchor.parent);
            }
            n2._setAttribute(t2, e2);
          }
          _removeSelectionAttribute(t2) {
            const e2 = this.model.document.selection;
            if (e2.isCollapsed && e2.anchor.parent.isEmpty) {
              const n2 = js._getStoreAttributeKey(t2);
              this.removeAttribute(n2, e2.anchor.parent);
            }
            e2._removeAttribute(t2);
          }
          _assertWriterUsedCorrectly() {
            if (this.model._currentWriter !== this)
              throw new hn.b("writer-incorrect-use: Trying to use a writer outside the change() block.", this);
          }
          _addOperationForAffectedMarkers(t2, e2) {
            for (const n2 of this.model.markers) {
              if (!n2.managedUsingOperations)
                continue;
              const i2 = n2.getRange();
              let o2 = false;
              if ("move" === t2)
                o2 = e2.containsPosition(i2.start) || e2.start.isEqual(i2.start) || e2.containsPosition(i2.end) || e2.end.isEqual(i2.end);
              else {
                const t3 = e2.nodeBefore, n3 = e2.nodeAfter, r2 = i2.start.parent == t3 && i2.start.isAtEnd, s2 = i2.end.parent == n3 && 0 == i2.end.offset, a2 = i2.end.nodeAfter == n3, c2 = i2.start.nodeAfter == n3;
                o2 = r2 || s2 || a2 || c2;
              }
              o2 && this.updateMarker(n2.name, { range: i2 });
            }
          }
        }
        function Ha(t2, e2, n2, i2) {
          const o2 = t2.model, r2 = o2.document;
          let s2, a2, c2, l2 = i2.start;
          for (const t3 of i2.getWalker({ shallow: true }))
            c2 = t3.item.getAttribute(e2), s2 && a2 != c2 && (a2 != n2 && d2(), l2 = s2), s2 = t3.nextPosition, a2 = c2;
          function d2() {
            const i3 = new xs(l2, s2), c3 = i3.root.document ? r2.version : null, d3 = new Na(i3, e2, a2, n2, c3);
            t2.batch.addOperation(d3), o2.applyOperation(d3);
          }
          s2 instanceof ks && s2 != l2 && a2 != n2 && d2();
        }
        function qa(t2, e2, n2, i2) {
          const o2 = t2.model, r2 = o2.document, s2 = i2.getAttribute(e2);
          let a2, c2;
          if (s2 != n2) {
            if (i2.root === i2) {
              const t3 = i2.document ? r2.version : null;
              c2 = new Va(i2, e2, s2, n2, t3);
            } else {
              a2 = new xs(ks._createBefore(i2), t2.createPositionAfter(i2));
              const o3 = a2.root.document ? r2.version : null;
              c2 = new Na(a2, e2, s2, n2, o3);
            }
            t2.batch.addOperation(c2), o2.applyOperation(c2);
          }
        }
        function Wa(t2, e2, n2, i2, o2) {
          const r2 = t2.model, s2 = r2.document, a2 = new La(e2, n2, i2, r2.markers, o2, s2.version);
          t2.batch.addOperation(a2), r2.applyOperation(a2);
        }
        function Ya(t2, e2, n2, i2) {
          let o2;
          if (t2.root.document) {
            const n3 = i2.document, r2 = new ks(n3.graveyard, [0]);
            o2 = new Ra(t2, e2, r2, n3.version);
          } else
            o2 = new Oa(t2, e2);
          n2.addOperation(o2), i2.applyOperation(o2);
        }
        function Ga(t2, e2) {
          return t2 === e2 || t2 instanceof Fa && e2 instanceof Fa;
        }
        class $a {
          constructor(t2) {
            this._markerCollection = t2, this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null;
          }
          get isEmpty() {
            return 0 == this._changesInElement.size && 0 == this._changedMarkers.size;
          }
          refreshItem(t2) {
            if (this._isInInsertedElement(t2.parent))
              return;
            this._markRemove(t2.parent, t2.startOffset, t2.offsetSize), this._markInsert(t2.parent, t2.startOffset, t2.offsetSize);
            const e2 = xs._createOn(t2);
            for (const t3 of this._markerCollection.getMarkersIntersectingRange(e2)) {
              const e3 = t3.getRange();
              this.bufferMarkerChange(t3.name, e3, e3, t3.affectsData);
            }
            this._cachedChanges = null;
          }
          bufferOperation(t2) {
            switch (t2.type) {
              case "insert":
                if (this._isInInsertedElement(t2.position.parent))
                  return;
                this._markInsert(t2.position.parent, t2.position.offset, t2.nodes.maxOffset);
                break;
              case "addAttribute":
              case "removeAttribute":
              case "changeAttribute":
                for (const e2 of t2.range.getItems({ shallow: true }))
                  this._isInInsertedElement(e2.parent) || this._markAttribute(e2);
                break;
              case "remove":
              case "move":
              case "reinsert": {
                if (t2.sourcePosition.isEqual(t2.targetPosition) || t2.sourcePosition.getShiftedBy(t2.howMany).isEqual(t2.targetPosition))
                  return;
                const e2 = this._isInInsertedElement(t2.sourcePosition.parent), n2 = this._isInInsertedElement(t2.targetPosition.parent);
                e2 || this._markRemove(t2.sourcePosition.parent, t2.sourcePosition.offset, t2.howMany), n2 || this._markInsert(t2.targetPosition.parent, t2.getMovedRangeStart().offset, t2.howMany);
                break;
              }
              case "rename": {
                if (this._isInInsertedElement(t2.position.parent))
                  return;
                this._markRemove(t2.position.parent, t2.position.offset, 1), this._markInsert(t2.position.parent, t2.position.offset, 1);
                const e2 = xs._createFromPositionAndShift(t2.position, 1);
                for (const t3 of this._markerCollection.getMarkersIntersectingRange(e2)) {
                  const e3 = t3.getRange();
                  this.bufferMarkerChange(t3.name, e3, e3, t3.affectsData);
                }
                break;
              }
              case "split": {
                const e2 = t2.splitPosition.parent;
                this._isInInsertedElement(e2) || this._markRemove(e2, t2.splitPosition.offset, t2.howMany), this._isInInsertedElement(t2.insertionPosition.parent) || this._markInsert(t2.insertionPosition.parent, t2.insertionPosition.offset, 1), t2.graveyardPosition && this._markRemove(t2.graveyardPosition.parent, t2.graveyardPosition.offset, 1);
                break;
              }
              case "merge": {
                const e2 = t2.sourcePosition.parent;
                this._isInInsertedElement(e2.parent) || this._markRemove(e2.parent, e2.startOffset, 1);
                const n2 = t2.graveyardPosition.parent;
                this._markInsert(n2, t2.graveyardPosition.offset, 1);
                const i2 = t2.targetPosition.parent;
                this._isInInsertedElement(i2) || this._markInsert(i2, t2.targetPosition.offset, e2.maxOffset);
                break;
              }
            }
            this._cachedChanges = null;
          }
          bufferMarkerChange(t2, e2, n2, i2) {
            const o2 = this._changedMarkers.get(t2);
            o2 ? (o2.newRange = n2, o2.affectsData = i2, null == o2.oldRange && null == o2.newRange && this._changedMarkers.delete(t2)) : this._changedMarkers.set(t2, { oldRange: e2, newRange: n2, affectsData: i2 });
          }
          getMarkersToRemove() {
            const t2 = [];
            for (const [e2, n2] of this._changedMarkers)
              null != n2.oldRange && t2.push({ name: e2, range: n2.oldRange });
            return t2;
          }
          getMarkersToAdd() {
            const t2 = [];
            for (const [e2, n2] of this._changedMarkers)
              null != n2.newRange && t2.push({ name: e2, range: n2.newRange });
            return t2;
          }
          getChangedMarkers() {
            return Array.from(this._changedMarkers).map((t2) => ({ name: t2[0], data: { oldRange: t2[1].oldRange, newRange: t2[1].newRange } }));
          }
          hasDataChanges() {
            for (const [, t2] of this._changedMarkers)
              if (t2.affectsData)
                return true;
            return this._changesInElement.size > 0;
          }
          getChanges(t2 = { includeChangesInGraveyard: false }) {
            if (this._cachedChanges)
              return t2.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
            const e2 = [];
            for (const t3 of this._changesInElement.keys()) {
              const n2 = this._changesInElement.get(t3).sort((t4, e3) => t4.offset === e3.offset ? t4.type != e3.type ? "remove" == t4.type ? -1 : 1 : 0 : t4.offset < e3.offset ? -1 : 1), i2 = this._elementSnapshots.get(t3), o2 = Qa(t3.getChildren()), r2 = Ka(i2.length, n2);
              let s2 = 0, a2 = 0;
              for (const n3 of r2)
                if ("i" === n3)
                  e2.push(this._getInsertDiff(t3, s2, o2[s2].name)), s2++;
                else if ("r" === n3)
                  e2.push(this._getRemoveDiff(t3, s2, i2[a2].name)), a2++;
                else if ("a" === n3) {
                  const n4 = o2[s2].attributes, r3 = i2[a2].attributes;
                  let c2;
                  if ("$text" == o2[s2].name)
                    c2 = new xs(ks._createAt(t3, s2), ks._createAt(t3, s2 + 1));
                  else {
                    const e3 = t3.offsetToIndex(s2);
                    c2 = new xs(ks._createAt(t3, s2), ks._createAt(t3.getChild(e3), 0));
                  }
                  e2.push(...this._getAttributesDiff(c2, r3, n4)), s2++, a2++;
                } else
                  s2++, a2++;
            }
            e2.sort((t3, e3) => t3.position.root != e3.position.root ? t3.position.root.rootName < e3.position.root.rootName ? -1 : 1 : t3.position.isEqual(e3.position) ? t3.changeCount - e3.changeCount : t3.position.isBefore(e3.position) ? -1 : 1);
            for (let t3 = 1; t3 < e2.length; t3++) {
              const n2 = e2[t3 - 1], i2 = e2[t3], o2 = "remove" == n2.type && "remove" == i2.type && "$text" == n2.name && "$text" == i2.name && n2.position.isEqual(i2.position), r2 = "insert" == n2.type && "insert" == i2.type && "$text" == n2.name && "$text" == i2.name && n2.position.parent == i2.position.parent && n2.position.offset + n2.length == i2.position.offset, s2 = "attribute" == n2.type && "attribute" == i2.type && n2.position.parent == i2.position.parent && n2.range.isFlat && i2.range.isFlat && n2.position.offset + n2.length == i2.position.offset && n2.attributeKey == i2.attributeKey && n2.attributeOldValue == i2.attributeOldValue && n2.attributeNewValue == i2.attributeNewValue;
              (o2 || r2 || s2) && (e2[t3 - 1].length++, s2 && (e2[t3 - 1].range.end = e2[t3 - 1].range.end.getShiftedBy(1)), e2.splice(t3, 1), t3--);
            }
            for (const t3 of e2)
              delete t3.changeCount, "attribute" == t3.type && (delete t3.position, delete t3.length);
            return this._changeCount = 0, this._cachedChangesWithGraveyard = e2.slice(), this._cachedChanges = e2.slice().filter(Ja), t2.includeChangesInGraveyard ? this._cachedChangesWithGraveyard : this._cachedChanges;
          }
          reset() {
            this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._cachedChanges = null;
          }
          _markInsert(t2, e2, n2) {
            const i2 = { type: "insert", offset: e2, howMany: n2, count: this._changeCount++ };
            this._markChange(t2, i2);
          }
          _markRemove(t2, e2, n2) {
            const i2 = { type: "remove", offset: e2, howMany: n2, count: this._changeCount++ };
            this._markChange(t2, i2), this._removeAllNestedChanges(t2, e2, n2);
          }
          _markAttribute(t2) {
            const e2 = { type: "attribute", offset: t2.startOffset, howMany: t2.offsetSize, count: this._changeCount++ };
            this._markChange(t2.parent, e2);
          }
          _markChange(t2, e2) {
            this._makeSnapshot(t2);
            const n2 = this._getChangesForElement(t2);
            this._handleChange(e2, n2), n2.push(e2);
            for (let t3 = 0; t3 < n2.length; t3++)
              n2[t3].howMany < 1 && (n2.splice(t3, 1), t3--);
          }
          _getChangesForElement(t2) {
            let e2;
            return this._changesInElement.has(t2) ? e2 = this._changesInElement.get(t2) : (e2 = [], this._changesInElement.set(t2, e2)), e2;
          }
          _makeSnapshot(t2) {
            this._elementSnapshots.has(t2) || this._elementSnapshots.set(t2, Qa(t2.getChildren()));
          }
          _handleChange(t2, e2) {
            t2.nodesToHandle = t2.howMany;
            for (const n2 of e2) {
              const i2 = t2.offset + t2.howMany, o2 = n2.offset + n2.howMany;
              if ("insert" == t2.type && ("insert" == n2.type && (t2.offset <= n2.offset ? n2.offset += t2.howMany : t2.offset < o2 && (n2.howMany += t2.nodesToHandle, t2.nodesToHandle = 0)), "remove" == n2.type && t2.offset < n2.offset && (n2.offset += t2.howMany), "attribute" == n2.type)) {
                if (t2.offset <= n2.offset)
                  n2.offset += t2.howMany;
                else if (t2.offset < o2) {
                  const o3 = n2.howMany;
                  n2.howMany = t2.offset - n2.offset, e2.unshift({ type: "attribute", offset: i2, howMany: o3 - n2.howMany, count: this._changeCount++ });
                }
              }
              if ("remove" == t2.type) {
                if ("insert" == n2.type) {
                  if (i2 <= n2.offset)
                    n2.offset -= t2.howMany;
                  else if (i2 <= o2)
                    if (t2.offset < n2.offset) {
                      const e3 = i2 - n2.offset;
                      n2.offset = t2.offset, n2.howMany -= e3, t2.nodesToHandle -= e3;
                    } else
                      n2.howMany -= t2.nodesToHandle, t2.nodesToHandle = 0;
                  else if (t2.offset <= n2.offset)
                    t2.nodesToHandle -= n2.howMany, n2.howMany = 0;
                  else if (t2.offset < o2) {
                    const e3 = o2 - t2.offset;
                    n2.howMany -= e3, t2.nodesToHandle -= e3;
                  }
                }
                if ("remove" == n2.type && (i2 <= n2.offset ? n2.offset -= t2.howMany : t2.offset < n2.offset && (t2.nodesToHandle += n2.howMany, n2.howMany = 0)), "attribute" == n2.type) {
                  if (i2 <= n2.offset)
                    n2.offset -= t2.howMany;
                  else if (t2.offset < n2.offset) {
                    const e3 = i2 - n2.offset;
                    n2.offset = t2.offset, n2.howMany -= e3;
                  } else if (t2.offset < o2)
                    if (i2 <= o2) {
                      const i3 = n2.howMany;
                      n2.howMany = t2.offset - n2.offset;
                      const o3 = i3 - n2.howMany - t2.nodesToHandle;
                      e2.unshift({ type: "attribute", offset: t2.offset, howMany: o3, count: this._changeCount++ });
                    } else
                      n2.howMany -= o2 - t2.offset;
                }
              }
              if ("attribute" == t2.type) {
                if ("insert" == n2.type)
                  if (t2.offset < n2.offset && i2 > n2.offset) {
                    if (i2 > o2) {
                      const t3 = { type: "attribute", offset: o2, howMany: i2 - o2, count: this._changeCount++ };
                      this._handleChange(t3, e2), e2.push(t3);
                    }
                    t2.nodesToHandle = n2.offset - t2.offset, t2.howMany = t2.nodesToHandle;
                  } else
                    t2.offset >= n2.offset && t2.offset < o2 && (i2 > o2 ? (t2.nodesToHandle = i2 - o2, t2.offset = o2) : t2.nodesToHandle = 0);
                if ("remove" == n2.type && t2.offset < n2.offset && i2 > n2.offset) {
                  const o3 = { type: "attribute", offset: n2.offset, howMany: i2 - n2.offset, count: this._changeCount++ };
                  this._handleChange(o3, e2), e2.push(o3), t2.nodesToHandle = n2.offset - t2.offset, t2.howMany = t2.nodesToHandle;
                }
                "attribute" == n2.type && (t2.offset >= n2.offset && i2 <= o2 ? (t2.nodesToHandle = 0, t2.howMany = 0, t2.offset = 0) : t2.offset <= n2.offset && i2 >= o2 && (n2.howMany = 0));
              }
            }
            t2.howMany = t2.nodesToHandle, delete t2.nodesToHandle;
          }
          _getInsertDiff(t2, e2, n2) {
            return { type: "insert", position: ks._createAt(t2, e2), name: n2, length: 1, changeCount: this._changeCount++ };
          }
          _getRemoveDiff(t2, e2, n2) {
            return { type: "remove", position: ks._createAt(t2, e2), name: n2, length: 1, changeCount: this._changeCount++ };
          }
          _getAttributesDiff(t2, e2, n2) {
            const i2 = [];
            n2 = new Map(n2);
            for (const [o2, r2] of e2) {
              const e3 = n2.has(o2) ? n2.get(o2) : null;
              e3 !== r2 && i2.push({ type: "attribute", position: t2.start, range: t2.clone(), length: 1, attributeKey: o2, attributeOldValue: r2, attributeNewValue: e3, changeCount: this._changeCount++ }), n2.delete(o2);
            }
            for (const [e3, o2] of n2)
              i2.push({ type: "attribute", position: t2.start, range: t2.clone(), length: 1, attributeKey: e3, attributeOldValue: null, attributeNewValue: o2, changeCount: this._changeCount++ });
            return i2;
          }
          _isInInsertedElement(t2) {
            const e2 = t2.parent;
            if (!e2)
              return false;
            const n2 = this._changesInElement.get(e2), i2 = t2.startOffset;
            if (n2) {
              for (const t3 of n2)
                if ("insert" == t3.type && i2 >= t3.offset && i2 < t3.offset + t3.howMany)
                  return true;
            }
            return this._isInInsertedElement(e2);
          }
          _removeAllNestedChanges(t2, e2, n2) {
            const i2 = new xs(ks._createAt(t2, e2), ks._createAt(t2, e2 + n2));
            for (const t3 of i2.getItems({ shallow: true }))
              t3.is("element") && (this._elementSnapshots.delete(t3), this._changesInElement.delete(t3), this._removeAllNestedChanges(t3, 0, t3.maxOffset));
          }
        }
        function Qa(t2) {
          const e2 = [];
          for (const n2 of t2)
            if (n2.is("text"))
              for (let t3 = 0; t3 < n2.data.length; t3++)
                e2.push({ name: "$text", attributes: new Map(n2.getAttributes()) });
            else
              e2.push({ name: n2.name, attributes: new Map(n2.getAttributes()) });
          return e2;
        }
        function Ka(t2, e2) {
          const n2 = [];
          let i2 = 0, o2 = 0;
          for (const t3 of e2) {
            if (t3.offset > i2) {
              for (let e3 = 0; e3 < t3.offset - i2; e3++)
                n2.push("e");
              o2 += t3.offset - i2;
            }
            if ("insert" == t3.type) {
              for (let e3 = 0; e3 < t3.howMany; e3++)
                n2.push("i");
              i2 = t3.offset + t3.howMany;
            } else if ("remove" == t3.type) {
              for (let e3 = 0; e3 < t3.howMany; e3++)
                n2.push("r");
              i2 = t3.offset, o2 += t3.howMany;
            } else
              n2.push(..."a".repeat(t3.howMany).split("")), i2 = t3.offset + t3.howMany, o2 += t3.howMany;
          }
          if (o2 < t2)
            for (let e3 = 0; e3 < t2 - o2 - i2; e3++)
              n2.push("e");
          return n2;
        }
        function Ja(t2) {
          const e2 = t2.position && "$graveyard" == t2.position.root.rootName, n2 = t2.range && "$graveyard" == t2.range.root.rootName;
          return !e2 && !n2;
        }
        class Za {
          constructor() {
            this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set();
          }
          addOperation(t2) {
            this._operations.includes(t2) || this._operations.push(t2);
          }
          getOperations(t2 = 0, e2 = Number.POSITIVE_INFINITY) {
            return t2 < 0 ? [] : this._operations.slice(t2, e2);
          }
          getOperation(t2) {
            return this._operations[t2];
          }
          setOperationAsUndone(t2, e2) {
            this._undoPairs.set(e2, t2), this._undoneOperations.add(t2);
          }
          isUndoingOperation(t2) {
            return this._undoPairs.has(t2);
          }
          isUndoneOperation(t2) {
            return this._undoneOperations.has(t2);
          }
          getUndoneOperation(t2) {
            return this._undoPairs.get(t2);
          }
        }
        function Xa(t2, e2) {
          return !!(n2 = t2.charAt(e2 - 1)) && 1 == n2.length && /[\ud800-\udbff]/.test(n2) && function(t3) {
            return !!t3 && 1 == t3.length && /[\udc00-\udfff]/.test(t3);
          }(t2.charAt(e2));
          var n2;
        }
        function tc(t2, e2) {
          return !!(n2 = t2.charAt(e2)) && 1 == n2.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n2);
          var n2;
        }
        class ec {
          constructor(t2) {
            this.model = t2, this.version = 0, this.history = new Za(this), this.selection = new js(this), this.roots = new An({ idProperty: "rootName" }), this.differ = new $a(t2.markers), this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = false, this.createRoot("$root", "$graveyard"), this.listenTo(t2, "applyOperation", (t3, e2) => {
              const n2 = e2[0];
              if (n2.isDocumentOperation && n2.baseVersion !== this.version)
                throw new hn.b("model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.", this, { operation: n2 });
            }, { priority: "highest" }), this.listenTo(t2, "applyOperation", (t3, e2) => {
              const n2 = e2[0];
              n2.isDocumentOperation && this.differ.bufferOperation(n2);
            }, { priority: "high" }), this.listenTo(t2, "applyOperation", (t3, e2) => {
              const n2 = e2[0];
              n2.isDocumentOperation && (this.version++, this.history.addOperation(n2));
            }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
              this._hasSelectionChangedFromTheLastChangeBlock = true;
            }), this.listenTo(t2.markers, "update", (t3, e2, n2, i2) => {
              this.differ.bufferMarkerChange(e2.name, n2, i2, e2.affectsData), null === n2 && e2.on("change", (t4, n3) => {
                this.differ.bufferMarkerChange(e2.name, n3, e2.getRange(), e2.affectsData);
              });
            });
          }
          get graveyard() {
            return this.getRoot("$graveyard");
          }
          createRoot(t2 = "$root", e2 = "main") {
            if (this.roots.get(e2))
              throw new hn.b("model-document-createRoot-name-exists: Root with specified name already exists.", this, { name: e2 });
            const n2 = new Fa(this, t2, e2);
            return this.roots.add(n2), n2;
          }
          destroy() {
            this.selection.destroy(), this.stopListening();
          }
          getRoot(t2 = "main") {
            return this.roots.get(t2);
          }
          getRootNames() {
            return Array.from(this.roots, (t2) => t2.rootName).filter((t2) => "$graveyard" != t2);
          }
          registerPostFixer(t2) {
            this._postFixers.add(t2);
          }
          toJSON() {
            const t2 = Nn(this);
            return t2.selection = "[engine.model.DocumentSelection]", t2.model = "[engine.model.Model]", t2;
          }
          _handleChangeBlock(t2) {
            this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t2), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t2.batch) : this.fire("change", t2.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = false;
          }
          _hasDocumentChangedFromTheLastChangeBlock() {
            return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
          }
          _getDefaultRoot() {
            for (const t2 of this.roots)
              if (t2 !== this.graveyard)
                return t2;
            return this.graveyard;
          }
          _getDefaultRange() {
            const t2 = this._getDefaultRoot(), e2 = this.model, n2 = e2.schema, i2 = e2.createPositionFromPath(t2, [0]);
            return n2.getNearestSelectionRange(i2) || e2.createRange(i2);
          }
          _validateSelectionRange(t2) {
            return nc(t2.start) && nc(t2.end);
          }
          _callPostFixers(t2) {
            let e2 = false;
            do {
              for (const n2 of this._postFixers)
                if (this.selection.refresh(), e2 = n2(t2), e2)
                  break;
            } while (e2);
          }
        }
        function nc(t2) {
          const e2 = t2.textNode;
          if (e2) {
            const n2 = e2.data, i2 = t2.offset - e2.startOffset;
            return !Xa(n2, i2) && !tc(n2, i2);
          }
          return true;
        }
        xn(ec, gn);
        class ic {
          constructor() {
            this._markers = /* @__PURE__ */ new Map();
          }
          [Symbol.iterator]() {
            return this._markers.values();
          }
          has(t2) {
            return this._markers.has(t2);
          }
          get(t2) {
            return this._markers.get(t2) || null;
          }
          _set(t2, e2, n2 = false, i2 = false) {
            const o2 = t2 instanceof oc ? t2.name : t2, r2 = this._markers.get(o2);
            if (r2) {
              const t3 = r2.getRange();
              let s3 = false;
              return t3.isEqual(e2) || (r2._attachLiveRange(Rs.fromRange(e2)), s3 = true), n2 != r2.managedUsingOperations && (r2._managedUsingOperations = n2, s3 = true), "boolean" == typeof i2 && i2 != r2.affectsData && (r2._affectsData = i2, s3 = true), s3 && this.fire("update:" + o2, r2, t3, e2), r2;
            }
            const s2 = Rs.fromRange(e2), a2 = new oc(o2, s2, n2, i2);
            return this._markers.set(o2, a2), this.fire("update:" + o2, a2, null, e2), a2;
          }
          _remove(t2) {
            const e2 = t2 instanceof oc ? t2.name : t2, n2 = this._markers.get(e2);
            return !!n2 && (this._markers.delete(e2), this.fire("update:" + e2, n2, n2.getRange(), null), this._destroyMarker(n2), true);
          }
          _refresh(t2) {
            const e2 = t2 instanceof oc ? t2.name : t2, n2 = this._markers.get(e2);
            if (!n2)
              throw new hn.b("markercollection-refresh-marker-not-exists: Marker with provided name does not exists.", this);
            const i2 = n2.getRange();
            this.fire("update:" + e2, n2, i2, i2, n2.managedUsingOperations, n2.affectsData);
          }
          *getMarkersAtPosition(t2) {
            for (const e2 of this)
              e2.getRange().containsPosition(t2) && (yield e2);
          }
          *getMarkersIntersectingRange(t2) {
            for (const e2 of this)
              null !== e2.getRange().getIntersection(t2) && (yield e2);
          }
          destroy() {
            for (const t2 of this._markers.values())
              this._destroyMarker(t2);
            this._markers = null, this.stopListening();
          }
          *getMarkersGroup(t2) {
            for (const e2 of this._markers.values())
              e2.name.startsWith(t2 + ":") && (yield e2);
          }
          _destroyMarker(t2) {
            t2.stopListening(), t2._detachLiveRange();
          }
        }
        xn(ic, gn);
        class oc {
          constructor(t2, e2, n2, i2) {
            this.name = t2, this._liveRange = this._attachLiveRange(e2), this._managedUsingOperations = n2, this._affectsData = i2;
          }
          get managedUsingOperations() {
            if (!this._liveRange)
              throw new hn.b("marker-destroyed: Cannot use a destroyed marker instance.", this);
            return this._managedUsingOperations;
          }
          get affectsData() {
            if (!this._liveRange)
              throw new hn.b("marker-destroyed: Cannot use a destroyed marker instance.", this);
            return this._affectsData;
          }
          getStart() {
            if (!this._liveRange)
              throw new hn.b("marker-destroyed: Cannot use a destroyed marker instance.", this);
            return this._liveRange.start.clone();
          }
          getEnd() {
            if (!this._liveRange)
              throw new hn.b("marker-destroyed: Cannot use a destroyed marker instance.", this);
            return this._liveRange.end.clone();
          }
          getRange() {
            if (!this._liveRange)
              throw new hn.b("marker-destroyed: Cannot use a destroyed marker instance.", this);
            return this._liveRange.toRange();
          }
          is(t2) {
            return "marker" === t2 || "model:marker" === t2;
          }
          _attachLiveRange(t2) {
            return this._liveRange && this._detachLiveRange(), t2.delegate("change:range").to(this), t2.delegate("change:content").to(this), this._liveRange = t2, t2;
          }
          _detachLiveRange() {
            this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
          }
        }
        xn(oc, gn);
        class rc extends ya {
          get type() {
            return "noop";
          }
          clone() {
            return new rc(this.baseVersion);
          }
          getReversed() {
            return new rc(this.baseVersion + 1);
          }
          _execute() {
          }
          static get className() {
            return "NoOperation";
          }
        }
        const sc = {};
        sc[Na.className] = Na, sc[Da.className] = Da, sc[La.className] = La, sc[Ra.className] = Ra, sc[rc.className] = rc, sc[ya.className] = ya, sc[ja.className] = ja, sc[Va.className] = Va, sc[Ba.className] = Ba, sc[za.className] = za;
        class ac extends ks {
          constructor(t2, e2, n2 = "toNone") {
            if (super(t2, e2, n2), !this.root.is("rootElement"))
              throw new hn.b("model-liveposition-root-not-rootelement: LivePosition's root has to be an instance of RootElement.", t2);
            cc.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t2) {
            return "livePosition" === t2 || "model:livePosition" === t2 || "position" == t2 || "model:position" === t2;
          }
          toPosition() {
            return new ks(this.root, this.path.slice(), this.stickiness);
          }
          static fromPosition(t2, e2) {
            return new this(t2.root, t2.path.slice(), e2 || t2.stickiness);
          }
        }
        function cc() {
          this.listenTo(this.root.document.model, "applyOperation", (t2, e2) => {
            const n2 = e2[0];
            n2.isDocumentOperation && lc.call(this, n2);
          }, { priority: "low" });
        }
        function lc(t2) {
          const e2 = this.getTransformedByOperation(t2);
          if (!this.isEqual(e2)) {
            const t3 = this.toPosition();
            this.path = e2.path, this.root = e2.root, this.fire("change", t3);
          }
        }
        xn(ac, gn);
        class dc {
          constructor(t2, e2, n2) {
            this.model = t2, this.writer = e2, this.position = n2, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = t2.schema, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null;
          }
          handleNodes(t2, e2) {
            t2 = Array.from(t2);
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = t2[n2];
              this._handleNode(i2, { isFirst: 0 === n2 && e2.isFirst, isLast: n2 === t2.length - 1 && e2.isLast });
            }
            this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
          }
          getSelectionRange() {
            return this.nodeToSelect ? xs._createOn(this.nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
          }
          getAffectedRange() {
            return this._affectedStart ? new xs(this._affectedStart, this._affectedEnd) : null;
          }
          destroy() {
            this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
          }
          _handleNode(t2, e2) {
            if (this.schema.isObject(t2))
              return void this._handleObject(t2, e2);
            this._checkAndSplitToAllowedPosition(t2, e2) ? (this._insert(t2), this._mergeSiblingsOf(t2, e2)) : this._handleDisallowedNode(t2, e2);
          }
          _handleObject(t2, e2) {
            this._checkAndSplitToAllowedPosition(t2) ? this._insert(t2) : this._tryAutoparagraphing(t2, e2);
          }
          _handleDisallowedNode(t2, e2) {
            t2.is("element") ? this.handleNodes(t2.getChildren(), e2) : this._tryAutoparagraphing(t2, e2);
          }
          _insert(t2) {
            if (!this.schema.checkChild(this.position, t2))
              throw new hn.b("insertcontent-wrong-position: Given node cannot be inserted on the given position.", this, { node: t2, position: this.position });
            const e2 = ac.fromPosition(this.position, "toNext");
            this._setAffectedBoundaries(this.position), this.writer.insert(t2, this.position), this.position = e2.toPosition(), e2.detach(), this.schema.isObject(t2) && !this.schema.checkChild(this.position, "$text") ? this.nodeToSelect = t2 : this.nodeToSelect = null, this._filterAttributesOf.push(t2);
          }
          _setAffectedBoundaries(t2) {
            this._affectedStart || (this._affectedStart = ac.fromPosition(t2, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t2) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = ac.fromPosition(t2, "toNext"));
          }
          _mergeSiblingsOf(t2, e2) {
            if (!(t2 instanceof ps))
              return;
            const n2 = this._canMergeLeft(t2, e2), i2 = this._canMergeRight(t2, e2), o2 = ac._createBefore(t2);
            o2.stickiness = "toNext";
            const r2 = ac._createAfter(t2);
            if (r2.stickiness = "toNext", n2) {
              const t3 = ac.fromPosition(this.position);
              t3.stickiness = "toNext", this._affectedStart.isEqual(o2) && (this._affectedStart.detach(), this._affectedStart = ac._createAt(o2.nodeBefore, "end", "toPrevious")), this.writer.merge(o2), o2.isEqual(this._affectedEnd) && e2.isLast && (this._affectedEnd.detach(), this._affectedEnd = ac._createAt(o2.nodeBefore, "end", "toNext")), this.position = t3.toPosition(), t3.detach();
            }
            if (i2) {
              if (!this.position.isEqual(r2))
                throw new hn.b("insertcontent-invalid-insertion-position", this);
              this.position = ks._createAt(r2.nodeBefore, "end");
              const t3 = ac.fromPosition(this.position, "toPrevious");
              this._affectedEnd.isEqual(r2) && (this._affectedEnd.detach(), this._affectedEnd = ac._createAt(r2.nodeBefore, "end", "toNext")), this.writer.merge(r2), r2.getShiftedBy(-1).isEqual(this._affectedStart) && e2.isFirst && (this._affectedStart.detach(), this._affectedStart = ac._createAt(r2.nodeBefore, 0, "toPrevious")), this.position = t3.toPosition(), t3.detach();
            }
            (n2 || i2) && this._filterAttributesOf.push(this.position.parent), o2.detach(), r2.detach();
          }
          _canMergeLeft(t2, e2) {
            const n2 = t2.previousSibling;
            return e2.isFirst && n2 instanceof ps && this.canMergeWith.has(n2) && this.model.schema.checkMerge(n2, t2);
          }
          _canMergeRight(t2, e2) {
            const n2 = t2.nextSibling;
            return e2.isLast && n2 instanceof ps && this.canMergeWith.has(n2) && this.model.schema.checkMerge(t2, n2);
          }
          _tryAutoparagraphing(t2, e2) {
            const n2 = this.writer.createElement("paragraph");
            this._getAllowedIn(n2, this.position.parent) && this.schema.checkChild(n2, t2) && (n2._appendChild(t2), this._handleNode(n2, e2));
          }
          _checkAndSplitToAllowedPosition(t2) {
            const e2 = this._getAllowedIn(t2, this.position.parent);
            if (!e2)
              return false;
            for (; e2 != this.position.parent; ) {
              if (this.schema.isLimit(this.position.parent))
                return false;
              if (this.position.isAtStart) {
                const t3 = this.position.parent;
                this.position = this.writer.createPositionBefore(t3), t3.isEmpty && t3.parent === e2 && this.writer.remove(t3);
              } else if (this.position.isAtEnd)
                this.position = this.writer.createPositionAfter(this.position.parent);
              else {
                const t3 = this.writer.createPositionAfter(this.position.parent);
                this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t3, this.canMergeWith.add(this.position.nodeAfter);
              }
            }
            return true;
          }
          _getAllowedIn(t2, e2) {
            return this.schema.checkChild(e2, t2) ? e2 : e2.parent ? this._getAllowedIn(t2, e2.parent) : null;
          }
        }
        function uc(t2, e2, n2 = {}) {
          if (e2.isCollapsed)
            return;
          const i2 = e2.getFirstRange();
          if ("$graveyard" == i2.root.rootName)
            return;
          const o2 = t2.schema;
          t2.change((t3) => {
            if (!n2.doNotResetEntireContent && function(t4, e3) {
              const n3 = t4.getLimitElement(e3);
              if (!e3.containsEntireContent(n3))
                return false;
              const i3 = e3.getFirstRange();
              if (i3.start.parent == i3.end.parent)
                return false;
              return t4.checkChild(n3, "paragraph");
            }(o2, e2))
              return void function(t4, e3) {
                const n3 = t4.model.schema.getLimitElement(e3);
                t4.remove(t4.createRangeIn(n3)), hc(t4, t4.createPositionAt(n3, 0), e3);
              }(t3, e2);
            const r2 = i2.start, s2 = ac.fromPosition(i2.end, "toNext");
            i2.start.isTouching(i2.end) || t3.remove(i2), n2.leaveUnmerged || (!function t4(e3, n3, i3) {
              const o3 = n3.parent, r3 = i3.parent;
              if (o3 == r3)
                return;
              if (e3.model.schema.isLimit(o3) || e3.model.schema.isLimit(r3))
                return;
              if (!function(t5, e4, n4) {
                const i4 = new xs(t5, e4);
                for (const t6 of i4.getWalker())
                  if (n4.isLimit(t6.item))
                    return false;
                return true;
              }(n3, i3, e3.model.schema))
                return;
              n3 = e3.createPositionAfter(o3), (i3 = e3.createPositionBefore(r3)).isEqual(n3) || e3.insert(r3, n3);
              e3.merge(n3);
              for (; i3.parent.isEmpty; ) {
                const t5 = i3.parent;
                i3 = e3.createPositionBefore(t5), e3.remove(t5);
              }
              t4(e3, n3, i3);
            }(t3, r2, s2), o2.removeDisallowedAttributes(r2.parent.getChildren(), t3)), fc(t3, e2, r2), !n2.doNotAutoparagraph && function(t4, e3) {
              const n3 = t4.checkChild(e3, "$text"), i3 = t4.checkChild(e3, "paragraph");
              return !n3 && i3;
            }(o2, r2) && hc(t3, r2, e2), s2.detach();
          });
        }
        function hc(t2, e2, n2) {
          const i2 = t2.createElement("paragraph");
          t2.insert(i2, e2), fc(t2, n2, t2.createPositionAt(i2, 0));
        }
        function fc(t2, e2, n2) {
          e2 instanceof js ? t2.setSelection(n2) : e2.setTo(n2);
        }
        function mc(t2, e2) {
          if ("text" == e2.type)
            return "word" === t2.unit ? function(t3, e3) {
              let n2 = t3.position.textNode;
              if (n2) {
                let i2 = t3.position.offset - n2.startOffset;
                for (; !pc(n2.data, i2, e3) && !bc(n2, i2, e3); ) {
                  t3.next();
                  const o2 = e3 ? t3.position.nodeAfter : t3.position.nodeBefore;
                  if (o2 && o2.is("text")) {
                    const i3 = o2.data.charAt(e3 ? 0 : o2.data.length - 1);
                    ' ,.?!:;"-()'.includes(i3) || (t3.next(), n2 = t3.position.textNode);
                  }
                  i2 = t3.position.offset - n2.startOffset;
                }
              }
              return t3.position;
            }(t2.walker, t2.isForward) : function(t3, e3) {
              const n2 = t3.position.textNode;
              if (n2) {
                const i2 = n2.data;
                let o2 = t3.position.offset - n2.startOffset;
                for (; Xa(i2, o2) || "character" == e3 && tc(i2, o2); )
                  t3.next(), o2 = t3.position.offset - n2.startOffset;
              }
              return t3.position;
            }(t2.walker, t2.unit, t2.isForward);
          if (e2.type == (t2.isForward ? "elementStart" : "elementEnd")) {
            if (t2.schema.isObject(e2.item))
              return ks._createAt(e2.item, t2.isForward ? "after" : "before");
            if (t2.schema.checkChild(e2.nextPosition, "$text"))
              return e2.nextPosition;
          } else {
            if (t2.schema.isLimit(e2.item))
              return void t2.walker.skip(() => true);
            if (t2.schema.checkChild(e2.nextPosition, "$text"))
              return e2.nextPosition;
          }
        }
        function gc(t2, e2) {
          const n2 = t2.root, i2 = ks._createAt(n2, e2 ? "end" : 0);
          return e2 ? new xs(t2, i2) : new xs(i2, t2);
        }
        function pc(t2, e2, n2) {
          const i2 = e2 + (n2 ? 0 : -1);
          return ' ,.?!:;"-()'.includes(t2.charAt(i2));
        }
        function bc(t2, e2, n2) {
          return e2 === (n2 ? t2.endOffset : 0);
        }
        function wc(t2, e2) {
          const n2 = [];
          Array.from(t2.getItems({ direction: "backward" })).map((t3) => e2.createRangeOn(t3)).filter((e3) => (e3.start.isAfter(t2.start) || e3.start.isEqual(t2.start)) && (e3.end.isBefore(t2.end) || e3.end.isEqual(t2.end))).forEach((t3) => {
            n2.push(t3.start.parent), e2.remove(t3);
          }), n2.forEach((t3) => {
            let n3 = t3;
            for (; n3.parent && n3.isEmpty; ) {
              const t4 = e2.createRangeOn(n3);
              n3 = n3.parent, e2.remove(t4);
            }
          });
        }
        function kc(t2) {
          t2.document.registerPostFixer((e2) => function(t3, e3) {
            const n2 = e3.document.selection, i2 = e3.schema, o2 = [];
            let r2 = false;
            for (const t4 of n2.getRanges()) {
              const e4 = _c(t4, i2);
              e4 ? (o2.push(e4), r2 = true) : o2.push(t4);
            }
            r2 && t3.setSelection(function(t4) {
              const e4 = [];
              e4.push(t4.shift());
              for (const n3 of t4) {
                const t5 = e4.pop();
                if (n3.isIntersecting(t5)) {
                  const i3 = t5.start.isAfter(n3.start) ? n3.start : t5.start, o3 = t5.end.isAfter(n3.end) ? t5.end : n3.end, r3 = new xs(i3, o3);
                  e4.push(r3);
                } else
                  e4.push(t5), e4.push(n3);
              }
              return e4;
            }(o2), { backward: n2.isBackward });
          }(e2, t2));
        }
        function _c(t2, e2) {
          return t2.isCollapsed ? function(t3, e3) {
            const n2 = t3.start, i2 = e3.getNearestSelectionRange(n2);
            if (!i2)
              return null;
            if (!i2.isCollapsed)
              return i2;
            const o2 = i2.start;
            if (n2.isEqual(o2))
              return null;
            return new xs(o2);
          }(t2, e2) : function(t3, e3) {
            const n2 = t3.start, i2 = t3.end, o2 = e3.checkChild(n2, "$text"), r2 = e3.checkChild(i2, "$text"), s2 = e3.getLimitElement(n2), a2 = e3.getLimitElement(i2);
            if (s2 === a2) {
              if (o2 && r2)
                return null;
              if (function(t4, e4, n3) {
                const i3 = t4.nodeAfter && !n3.isLimit(t4.nodeAfter) || n3.checkChild(t4, "$text"), o3 = e4.nodeBefore && !n3.isLimit(e4.nodeBefore) || n3.checkChild(e4, "$text");
                return i3 || o3;
              }(n2, i2, e3)) {
                const t4 = n2.nodeAfter && e3.isObject(n2.nodeAfter) ? null : e3.getNearestSelectionRange(n2, "forward"), o3 = i2.nodeBefore && e3.isObject(i2.nodeBefore) ? null : e3.getNearestSelectionRange(i2, "backward"), r3 = t4 ? t4.start : n2, s3 = o3 ? o3.start : i2;
                return new xs(r3, s3);
              }
            }
            const c2 = s2 && !s2.is("rootElement"), l2 = a2 && !a2.is("rootElement");
            if (c2 || l2) {
              const t4 = n2.nodeAfter && i2.nodeBefore && n2.nodeAfter.parent === i2.nodeBefore.parent, o3 = c2 && (!t4 || !yc(n2.nodeAfter, e3)), r3 = l2 && (!t4 || !yc(i2.nodeBefore, e3));
              let d2 = n2, u2 = i2;
              return o3 && (d2 = ks._createBefore(vc(s2, e3))), r3 && (u2 = ks._createAfter(vc(a2, e3))), new xs(d2, u2);
            }
            return null;
          }(t2, e2);
        }
        function vc(t2, e2) {
          let n2 = t2, i2 = n2;
          for (; e2.isLimit(i2) && i2.parent; )
            n2 = i2, i2 = i2.parent;
          return n2;
        }
        function yc(t2, e2) {
          return t2 && e2.isObject(t2);
        }
        class xc {
          constructor() {
            this.markers = new ic(), this.document = new ec(this), this.schema = new ia(), this._pendingChanges = [], this._currentWriter = null, ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t2) => this.decorate(t2)), this.on("applyOperation", (t2, e2) => {
              e2[0]._validate();
            }, { priority: "highest" }), this.schema.register("$root", { isLimit: true }), this.schema.register("$block", { allowIn: "$root", isBlock: true }), this.schema.register("$text", { allowIn: "$block", isInline: true }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", isLimit: true }), this.schema.extend("$text", { allowIn: "$clipboardHolder" }), this.schema.register("$marker"), this.schema.addChildCheck((t2, e2) => {
              if ("$marker" === e2.name)
                return true;
            }), kc(this);
          }
          change(t2) {
            try {
              return 0 === this._pendingChanges.length ? (this._pendingChanges.push({ batch: new va(), callback: t2 }), this._runPendingChanges()[0]) : t2(this._currentWriter);
            } catch (t3) {
              hn.b.rethrowUnexpectedError(t3, this);
            }
          }
          enqueueChange(t2, e2) {
            try {
              "string" == typeof t2 ? t2 = new va(t2) : "function" == typeof t2 && (e2 = t2, t2 = new va()), this._pendingChanges.push({ batch: t2, callback: e2 }), 1 == this._pendingChanges.length && this._runPendingChanges();
            } catch (t3) {
              hn.b.rethrowUnexpectedError(t3, this);
            }
          }
          applyOperation(t2) {
            t2._execute();
          }
          insertContent(t2, e2, n2) {
            return function(t3, e3, n3, i2) {
              return t3.change((o2) => {
                let r2;
                r2 = n3 ? n3 instanceof Ms || n3 instanceof js ? n3 : o2.createSelection(n3, i2) : t3.document.selection, r2.isCollapsed || t3.deleteContent(r2, { doNotAutoparagraph: true });
                const s2 = new dc(t3, o2, r2.anchor);
                let a2;
                a2 = e3.is("documentFragment") ? e3.getChildren() : [e3], s2.handleNodes(a2, { isFirst: true, isLast: true });
                const c2 = s2.getSelectionRange();
                c2 && (r2 instanceof js ? o2.setSelection(c2) : r2.setTo(c2));
                const l2 = s2.getAffectedRange() || t3.createRange(r2.anchor);
                return s2.destroy(), l2;
              });
            }(this, t2, e2, n2);
          }
          deleteContent(t2, e2) {
            uc(this, t2, e2);
          }
          modifySelection(t2, e2) {
            !function(t3, e3, n2 = {}) {
              const i2 = t3.schema, o2 = "backward" != n2.direction, r2 = n2.unit ? n2.unit : "character", s2 = e3.focus, a2 = new bs({ boundaries: gc(s2, o2), singleCharacters: true, direction: o2 ? "forward" : "backward" }), c2 = { walker: a2, schema: i2, isForward: o2, unit: r2 };
              let l2;
              for (; l2 = a2.next(); ) {
                if (l2.done)
                  return;
                const n3 = mc(c2, l2.value);
                if (n3)
                  return void (e3 instanceof js ? t3.change((t4) => {
                    t4.setSelectionFocus(n3);
                  }) : e3.setFocus(n3));
              }
            }(this, t2, e2);
          }
          getSelectedContent(t2) {
            return function(t3, e2) {
              return t3.change((t4) => {
                const n2 = t4.createDocumentFragment(), i2 = e2.getFirstRange();
                if (!i2 || i2.isCollapsed)
                  return n2;
                const o2 = i2.start.root, r2 = i2.start.getCommonPath(i2.end), s2 = o2.getNodeByPath(r2);
                let a2;
                a2 = i2.start.parent == i2.end.parent ? i2 : t4.createRange(t4.createPositionAt(s2, i2.start.path[r2.length]), t4.createPositionAt(s2, i2.end.path[r2.length] + 1));
                const c2 = a2.end.offset - a2.start.offset;
                for (const e3 of a2.getItems({ shallow: true }))
                  e3.is("textProxy") ? t4.appendText(e3.data, e3.getAttributes(), n2) : t4.append(e3._clone(true), n2);
                if (a2 != i2) {
                  const e3 = i2._getTransformedByMove(a2.start, t4.createPositionAt(n2, 0), c2)[0], o3 = t4.createRange(t4.createPositionAt(n2, 0), e3.start);
                  wc(t4.createRange(e3.end, t4.createPositionAt(n2, "end")), t4), wc(o3, t4);
                }
                return n2;
              });
            }(this, t2);
          }
          hasContent(t2, e2) {
            const n2 = t2 instanceof ps ? xs._createIn(t2) : t2;
            if (n2.isCollapsed)
              return false;
            for (const t3 of this.markers.getMarkersIntersectingRange(n2))
              if (t3.affectsData)
                return true;
            const { ignoreWhitespaces: i2 = false } = e2 || {};
            for (const t3 of n2.getItems())
              if (t3.is("textProxy")) {
                if (!i2)
                  return true;
                if (-1 !== t3.data.search(/\S/))
                  return true;
              } else if (this.schema.isObject(t3))
                return true;
            return false;
          }
          createPositionFromPath(t2, e2, n2) {
            return new ks(t2, e2, n2);
          }
          createPositionAt(t2, e2) {
            return ks._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return ks._createAfter(t2);
          }
          createPositionBefore(t2) {
            return ks._createBefore(t2);
          }
          createRange(t2, e2) {
            return new xs(t2, e2);
          }
          createRangeIn(t2) {
            return xs._createIn(t2);
          }
          createRangeOn(t2) {
            return xs._createOn(t2);
          }
          createSelection(t2, e2, n2) {
            return new Ms(t2, e2, n2);
          }
          createBatch(t2) {
            return new va(t2);
          }
          createOperationFromJSON(t2) {
            return class {
              static fromJSON(t3, e2) {
                return sc[t3.__className].fromJSON(t3, e2);
              }
            }.fromJSON(t2, this.document);
          }
          destroy() {
            this.document.destroy(), this.stopListening();
          }
          _runPendingChanges() {
            const t2 = [];
            for (this.fire("_beforeChanges"); this._pendingChanges.length; ) {
              const e2 = this._pendingChanges[0].batch;
              this._currentWriter = new Ua(this, e2);
              const n2 = this._pendingChanges[0].callback(this._currentWriter);
              t2.push(n2), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
            }
            return this.fire("_afterChanges"), t2;
          }
        }
        xn(xc, Ui);
        class Ac {
          constructor() {
            this._listener = Object.create(cr);
          }
          listenTo(t2) {
            this._listener.listenTo(t2, "keydown", (t3, e2) => {
              this._listener.fire("_keydown:" + po(e2), e2);
            });
          }
          set(t2, e2, n2 = {}) {
            const i2 = bo(t2), o2 = n2.priority;
            this._listener.listenTo(this._listener, "_keydown:" + i2, (t3, n3) => {
              e2(n3, () => {
                n3.preventDefault(), n3.stopPropagation(), t3.stop();
              }), t3.return = true;
            }, { priority: o2 });
          }
          press(t2) {
            return !!this._listener.fire("_keydown:" + po(t2), t2);
          }
          destroy() {
            this._listener.stopListening();
          }
        }
        class Tc extends Ac {
          constructor(t2) {
            super(), this.editor = t2;
          }
          set(t2, e2, n2 = {}) {
            if ("string" == typeof e2) {
              const t3 = e2;
              e2 = (e3, n3) => {
                this.editor.execute(t3), n3();
              };
            }
            super.set(t2, e2, n2);
          }
        }
        class Cc {
          constructor(t2 = {}) {
            this._context = t2.context || new En({ language: t2.language }), this._context._addEditor(this, !t2.context);
            const e2 = Array.from(this.constructor.builtinPlugins || []);
            this.config = new on(t2, this.constructor.defaultConfig), this.config.define("plugins", e2), this.config.define(this._context._getEditorConfig()), this.plugins = new Tn(this, e2, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this.commands = new ta(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.set("isReadOnly", false), this.model = new xc();
            const n2 = new Ei();
            this.data = new ba(this.model, n2), this.editing = new Xs(this.model, n2), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new wa([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Tc(this), this.keystrokes.listenTo(this.editing.view.document);
          }
          initPlugins() {
            const t2 = this.config, e2 = t2.get("plugins"), n2 = t2.get("removePlugins") || [], i2 = t2.get("extraPlugins") || [];
            return this.plugins.init(e2.concat(i2), n2);
          }
          destroy() {
            let t2 = Promise.resolve();
            return "initializing" == this.state && (t2 = new Promise((t3) => this.once("ready", t3))), t2.then(() => {
              this.fire("destroy"), this.stopListening(), this.commands.destroy();
            }).then(() => this.plugins.destroy()).then(() => {
              this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
            }).then(() => this._context._removeEditor(this));
          }
          execute(...t2) {
            try {
              this.commands.execute(...t2);
            } catch (t3) {
              hn.b.rethrowUnexpectedError(t3, this);
            }
          }
        }
        xn(Cc, Ui);
        var Pc = { setData(t2) {
          this.data.set(t2);
        }, getData(t2) {
          return this.data.get(t2);
        } };
        var Sc = { updateSourceElement() {
          if (!this.sourceElement)
            throw new hn.b("editor-missing-sourceelement: Cannot update the source element of a detached editor.", this);
          var t2, e2;
          t2 = this.sourceElement, e2 = this.data.get(), t2 instanceof HTMLTextAreaElement && (t2.value = e2), t2.innerHTML = e2;
        } };
        class Mc {
          getHtml(t2) {
            const e2 = document.implementation.createHTMLDocument("").createElement("div");
            return e2.appendChild(t2), e2.innerHTML;
          }
        }
        class Ec {
          constructor(t2) {
            this._domParser = new DOMParser(), this._domConverter = new ir(t2, { blockFillerMode: "nbsp" }), this._htmlWriter = new Mc();
          }
          toData(t2) {
            const e2 = this._domConverter.viewToDom(t2, document);
            return this._htmlWriter.getHtml(e2);
          }
          toView(t2) {
            const e2 = this._toDom(t2);
            return this._domConverter.domToView(e2);
          }
          _toDom(t2) {
            const e2 = this._domParser.parseFromString(t2, "text/html"), n2 = e2.createDocumentFragment(), i2 = e2.body.childNodes;
            for (; i2.length > 0; )
              n2.appendChild(i2[0]);
            return n2;
          }
        }
        class Ic {
          constructor(t2) {
            this.editor = t2, this._components = /* @__PURE__ */ new Map();
          }
          *names() {
            for (const t2 of this._components.values())
              yield t2.originalName;
          }
          add(t2, e2) {
            if (this.has(t2))
              throw new hn.b("componentfactory-item-exists: The item already exists in the component factory.", this, { name: t2 });
            this._components.set(Nc(t2), { callback: e2, originalName: t2 });
          }
          create(t2) {
            if (!this.has(t2))
              throw new hn.b("componentfactory-item-missing: The required component is not registered in the factory.", this, { name: t2 });
            return this._components.get(Nc(t2)).callback(this.editor.locale);
          }
          has(t2) {
            return this._components.has(Nc(t2));
          }
        }
        function Nc(t2) {
          return String(t2).toLowerCase();
        }
        class Oc {
          constructor() {
            this.set("isFocused", false), this.set("focusedElement", null), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null;
          }
          add(t2) {
            if (this._elements.has(t2))
              throw new hn.b("focusTracker-add-element-already-exist", this);
            this.listenTo(t2, "focus", () => this._focus(t2), { useCapture: true }), this.listenTo(t2, "blur", () => this._blur(), { useCapture: true }), this._elements.add(t2);
          }
          remove(t2) {
            t2 === this.focusedElement && this._blur(t2), this._elements.has(t2) && (this.stopListening(t2), this._elements.delete(t2));
          }
          destroy() {
            this.stopListening();
          }
          _focus(t2) {
            clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t2, this.isFocused = true;
          }
          _blur() {
            clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
              this.focusedElement = null, this.isFocused = false;
            }, 0);
          }
        }
        xn(Oc, cr), xn(Oc, Ui);
        class Rc {
          constructor(t2) {
            this.editor = t2, this.componentFactory = new Ic(t2), this.focusTracker = new Oc(), this._editableElementsMap = /* @__PURE__ */ new Map(), this.listenTo(t2.editing.view.document, "layoutChanged", () => this.update());
          }
          get element() {
            return null;
          }
          update() {
            this.fire("update");
          }
          destroy() {
            this.stopListening(), this.focusTracker.destroy();
            for (const t2 of this._editableElementsMap.values())
              t2.ckeditorInstance = null;
            this._editableElementsMap = /* @__PURE__ */ new Map();
          }
          setEditableElement(t2, e2) {
            this._editableElementsMap.set(t2, e2), e2.ckeditorInstance || (e2.ckeditorInstance = this.editor);
          }
          getEditableElement(t2 = "main") {
            return this._editableElementsMap.get(t2);
          }
          getEditableElementsNames() {
            return this._editableElementsMap.keys();
          }
          get _editableElements() {
            return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
          }
        }
        xn(Rc, gn);
        n(13);
        const Dc = /* @__PURE__ */ new WeakMap();
        function Lc(t2) {
          const { view: e2, element: n2, text: i2, isDirectHost: o2 = true } = t2, r2 = e2.document;
          Dc.has(r2) || (Dc.set(r2, /* @__PURE__ */ new Map()), r2.registerPostFixer((t3) => Vc(r2, t3))), Dc.get(r2).set(n2, { text: i2, isDirectHost: o2 }), e2.change((t3) => Vc(r2, t3));
        }
        function jc(t2, e2) {
          return !!e2.hasClass("ck-placeholder") && (t2.removeClass("ck-placeholder", e2), true);
        }
        function Vc(t2, e2) {
          const n2 = Dc.get(t2);
          let i2 = false;
          for (const [t3, o2] of n2)
            zc(e2, t3, o2) && (i2 = true);
          return i2;
        }
        function zc(t2, e2, n2) {
          const { text: i2, isDirectHost: o2 } = n2, r2 = o2 ? e2 : function(t3) {
            if (1 === t3.childCount) {
              const e3 = t3.getChild(0);
              if (e3.is("element") && !e3.is("uiElement"))
                return e3;
            }
            return null;
          }(e2);
          let s2 = false;
          return !!r2 && (n2.hostElement = r2, r2.getAttribute("data-placeholder") !== i2 && (t2.setAttribute("data-placeholder", i2, r2), s2 = true), !function(t3) {
            if (!t3.isAttached())
              return false;
            const e3 = !Array.from(t3.getChildren()).some((t4) => !t4.is("uiElement")), n3 = t3.document;
            if (!n3.isFocused && e3)
              return true;
            const i3 = n3.selection.anchor;
            return !(!e3 || !i3 || i3.parent === t3);
          }(r2) ? jc(t2, r2) && (s2 = true) : function(t3, e3) {
            return !e3.hasClass("ck-placeholder") && (t3.addClass("ck-placeholder", e3), true);
          }(t2, r2) && (s2 = true), s2);
        }
        class Bc {
          constructor() {
            this._replacedElements = [];
          }
          replace(t2, e2) {
            this._replacedElements.push({ element: t2, newElement: e2 }), t2.style.display = "none", e2 && t2.parentNode.insertBefore(e2, t2.nextSibling);
          }
          restore() {
            this._replacedElements.forEach(({ element: t2, newElement: e2 }) => {
              t2.style.display = "", e2 && e2.remove();
            }), this._replacedElements = [];
          }
        }
        class Fc extends Rc {
          constructor(t2, e2) {
            var n2;
            super(t2), this.view = e2, this._toolbarConfig = (n2 = t2.config.get("toolbar"), Array.isArray(n2) ? { items: n2 } : n2 ? Object.assign({ items: [] }, n2) : { items: [] }), this._elementReplacer = new Bc();
          }
          get element() {
            return this.view.element;
          }
          init(t2) {
            const e2 = this.editor, n2 = this.view, i2 = e2.editing.view, o2 = n2.editable, r2 = i2.document.getRoot();
            o2.name = r2.rootName, n2.render();
            const s2 = o2.element;
            this.setEditableElement(o2.name, s2), this.focusTracker.add(s2), n2.editable.bind("isFocused").to(this.focusTracker), i2.attachDomRoot(s2), t2 && this._elementReplacer.replace(t2, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
          }
          destroy() {
            const t2 = this.view, e2 = this.editor.editing.view;
            this._elementReplacer.restore(), e2.detachDomRoot(t2.editable.name), t2.destroy(), super.destroy();
          }
          _initToolbar() {
            const t2 = this.editor, e2 = this.view, n2 = t2.editing.view;
            e2.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e2.stickyPanel.limiterElement = e2.element, this._toolbarConfig.viewportTopOffset && (e2.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset), e2.toolbar.fillFromConfig(this._toolbarConfig.items, this.componentFactory), function({ origin: t3, originKeystrokeHandler: e3, originFocusTracker: n3, toolbar: i2, beforeFocus: o2, afterBlur: r2 }) {
              n3.add(i2.element), e3.set("Alt+F10", (t4, e4) => {
                n3.isFocused && !i2.focusTracker.isFocused && (o2 && o2(), i2.focus(), e4());
              }), i2.keystrokes.set("Esc", (e4, n4) => {
                i2.focusTracker.isFocused && (t3.focus(), r2 && r2(), n4());
              });
            }({ origin: n2, originFocusTracker: this.focusTracker, originKeystrokeHandler: t2.keystrokes, toolbar: e2.toolbar });
          }
          _initPlaceholder() {
            const t2 = this.editor, e2 = t2.editing.view, n2 = e2.document.getRoot(), i2 = t2.sourceElement, o2 = t2.config.get("placeholder") || i2 && "textarea" === i2.tagName.toLowerCase() && i2.getAttribute("placeholder");
            o2 && Lc({ view: e2, element: n2, text: o2, isDirectHost: false });
          }
        }
        class Uc extends An {
          constructor(t2 = []) {
            super(t2, { idProperty: "viewUid" }), this.on("add", (t3, e2, n2) => {
              this._renderViewIntoCollectionParent(e2, n2);
            }), this.on("remove", (t3, e2) => {
              e2.element && this._parentElement && e2.element.remove();
            }), this._parentElement = null;
          }
          destroy() {
            this.map((t2) => t2.destroy());
          }
          setParent(t2) {
            this._parentElement = t2;
            for (const t3 of this)
              this._renderViewIntoCollectionParent(t3);
          }
          delegate(...t2) {
            if (!t2.length || !t2.every((t3) => "string" == typeof t3))
              throw new hn.b("ui-viewcollection-delegate-wrong-events: All event names must be strings.", this);
            return { to: (e2) => {
              for (const n2 of this)
                for (const i2 of t2)
                  n2.delegate(i2).to(e2);
              this.on("add", (n2, i2) => {
                for (const n3 of t2)
                  i2.delegate(n3).to(e2);
              }), this.on("remove", (n2, i2) => {
                for (const n3 of t2)
                  i2.stopDelegating(n3, e2);
              });
            } };
          }
          _renderViewIntoCollectionParent(t2, e2) {
            t2.isRendered || t2.render(), t2.element && this._parentElement && this._parentElement.insertBefore(t2.element, this._parentElement.children[e2]);
          }
        }
        class Hc {
          constructor(t2) {
            Object.assign(this, Xc(Zc(t2))), this._isRendered = false, this._revertData = null;
          }
          render() {
            const t2 = this._renderNode({ intoFragment: true });
            return this._isRendered = true, t2;
          }
          apply(t2) {
            return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: t2, isApplying: true, revertData: this._revertData }), t2;
          }
          revert(t2) {
            if (!this._revertData)
              throw new hn.b("ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.", [this, t2]);
            this._revertTemplateFromNode(t2, this._revertData);
          }
          *getViews() {
            yield* function* t2(e2) {
              if (e2.children)
                for (const n2 of e2.children)
                  ol(n2) ? yield n2 : rl(n2) && (yield* t2(n2));
            }(this);
          }
          static bind(t2, e2) {
            return { to: (n2, i2) => new Wc({ eventNameOrFunction: n2, attribute: n2, observable: t2, emitter: e2, callback: i2 }), if: (n2, i2, o2) => new Yc({ observable: t2, emitter: e2, attribute: n2, valueIfTrue: i2, callback: o2 }) };
          }
          static extend(t2, e2) {
            if (t2._isRendered)
              throw new hn.b("template-extend-render: Attempting to extend a template which has already been rendered.", [this, t2]);
            !function t3(e3, n2) {
              n2.attributes && (e3.attributes || (e3.attributes = {}), nl(e3.attributes, n2.attributes));
              n2.eventListeners && (e3.eventListeners || (e3.eventListeners = {}), nl(e3.eventListeners, n2.eventListeners));
              n2.text && e3.text.push(...n2.text);
              if (n2.children && n2.children.length) {
                if (e3.children.length != n2.children.length)
                  throw new hn.b("ui-template-extend-children-mismatch: The number of children in extended definition does not match.", e3);
                let i2 = 0;
                for (const o2 of n2.children)
                  t3(e3.children[i2++], o2);
              }
            }(t2, Xc(Zc(e2)));
          }
          _renderNode(t2) {
            let e2;
            if (e2 = t2.node ? this.tag && this.text : this.tag ? this.text : !this.text, e2)
              throw new hn.b('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.', this);
            return this.text ? this._renderText(t2) : this._renderElement(t2);
          }
          _renderElement(t2) {
            let e2 = t2.node;
            return e2 || (e2 = t2.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t2), this._renderElementChildren(t2), this._setUpListeners(t2), e2;
          }
          _renderText(t2) {
            let e2 = t2.node;
            return e2 ? t2.revertData.text = e2.textContent : e2 = t2.node = document.createTextNode(""), Gc(this.text) ? this._bindToObservable({ schema: this.text, updater: Qc(e2), data: t2 }) : e2.textContent = this.text.join(""), e2;
          }
          _renderAttributes(t2) {
            let e2, n2, i2, o2;
            if (!this.attributes)
              return;
            const r2 = t2.node, s2 = t2.revertData;
            for (e2 in this.attributes)
              if (i2 = r2.getAttribute(e2), n2 = this.attributes[e2], s2 && (s2.attributes[e2] = i2), o2 = j(n2[0]) && n2[0].ns ? n2[0].ns : null, Gc(n2)) {
                const a2 = o2 ? n2[0].value : n2;
                s2 && al(e2) && a2.unshift(i2), this._bindToObservable({ schema: a2, updater: Kc(r2, e2, o2), data: t2 });
              } else
                "style" == e2 && "string" != typeof n2[0] ? this._renderStyleAttribute(n2[0], t2) : (s2 && i2 && al(e2) && n2.unshift(i2), n2 = n2.map((t3) => t3 && t3.value || t3).reduce((t3, e3) => t3.concat(e3), []).reduce(el, ""), il(n2) || r2.setAttributeNS(o2, e2, n2));
          }
          _renderStyleAttribute(t2, e2) {
            const n2 = e2.node;
            for (const i2 in t2) {
              const o2 = t2[i2];
              Gc(o2) ? this._bindToObservable({ schema: [o2], updater: Jc(n2, i2), data: e2 }) : n2.style[i2] = o2;
            }
          }
          _renderElementChildren(t2) {
            const e2 = t2.node, n2 = t2.intoFragment ? document.createDocumentFragment() : e2, i2 = t2.isApplying;
            let o2 = 0;
            for (const r2 of this.children)
              if (sl(r2)) {
                if (!i2) {
                  r2.setParent(e2);
                  for (const t3 of r2)
                    n2.appendChild(t3.element);
                }
              } else if (ol(r2))
                i2 || (r2.isRendered || r2.render(), n2.appendChild(r2.element));
              else if ($o(r2))
                n2.appendChild(r2);
              else if (i2) {
                const e3 = { children: [], bindings: [], attributes: {} };
                t2.revertData.children.push(e3), r2._renderNode({ node: n2.childNodes[o2++], isApplying: true, revertData: e3 });
              } else
                n2.appendChild(r2.render());
            t2.intoFragment && e2.appendChild(n2);
          }
          _setUpListeners(t2) {
            if (this.eventListeners)
              for (const e2 in this.eventListeners) {
                const n2 = this.eventListeners[e2].map((n3) => {
                  const [i2, o2] = e2.split("@");
                  return n3.activateDomEventListener(i2, o2, t2);
                });
                t2.revertData && t2.revertData.bindings.push(n2);
              }
          }
          _bindToObservable({ schema: t2, updater: e2, data: n2 }) {
            const i2 = n2.revertData;
            $c(t2, e2, n2);
            const o2 = t2.filter((t3) => !il(t3)).filter((t3) => t3.observable).map((i3) => i3.activateAttributeListener(t2, e2, n2));
            i2 && i2.bindings.push(o2);
          }
          _revertTemplateFromNode(t2, e2) {
            for (const t3 of e2.bindings)
              for (const e3 of t3)
                e3();
            if (e2.text)
              t2.textContent = e2.text;
            else {
              for (const n2 in e2.attributes) {
                const i2 = e2.attributes[n2];
                null === i2 ? t2.removeAttribute(n2) : t2.setAttribute(n2, i2);
              }
              for (let n2 = 0; n2 < e2.children.length; ++n2)
                this._revertTemplateFromNode(t2.childNodes[n2], e2.children[n2]);
            }
          }
        }
        xn(Hc, gn);
        class qc {
          constructor(t2) {
            Object.assign(this, t2);
          }
          getValue(t2) {
            const e2 = this.observable[this.attribute];
            return this.callback ? this.callback(e2, t2) : e2;
          }
          activateAttributeListener(t2, e2, n2) {
            const i2 = () => $c(t2, e2, n2);
            return this.emitter.listenTo(this.observable, "change:" + this.attribute, i2), () => {
              this.emitter.stopListening(this.observable, "change:" + this.attribute, i2);
            };
          }
        }
        class Wc extends qc {
          activateDomEventListener(t2, e2, n2) {
            const i2 = (t3, n3) => {
              e2 && !n3.target.matches(e2) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n3) : this.observable.fire(this.eventNameOrFunction, n3));
            };
            return this.emitter.listenTo(n2.node, t2, i2), () => {
              this.emitter.stopListening(n2.node, t2, i2);
            };
          }
        }
        class Yc extends qc {
          getValue(t2) {
            return !il(super.getValue(t2)) && (this.valueIfTrue || true);
          }
        }
        function Gc(t2) {
          return !!t2 && (t2.value && (t2 = t2.value), Array.isArray(t2) ? t2.some(Gc) : t2 instanceof qc);
        }
        function $c(t2, e2, { node: n2 }) {
          let i2 = function(t3, e3) {
            return t3.map((t4) => t4 instanceof qc ? t4.getValue(e3) : t4);
          }(t2, n2);
          i2 = 1 == t2.length && t2[0] instanceof Yc ? i2[0] : i2.reduce(el, ""), il(i2) ? e2.remove() : e2.set(i2);
        }
        function Qc(t2) {
          return { set(e2) {
            t2.textContent = e2;
          }, remove() {
            t2.textContent = "";
          } };
        }
        function Kc(t2, e2, n2) {
          return { set(i2) {
            t2.setAttributeNS(n2, e2, i2);
          }, remove() {
            t2.removeAttributeNS(n2, e2);
          } };
        }
        function Jc(t2, e2) {
          return { set(n2) {
            t2.style[e2] = n2;
          }, remove() {
            t2.style[e2] = null;
          } };
        }
        function Zc(t2) {
          return en(t2, (t3) => {
            if (t3 && (t3 instanceof qc || rl(t3) || ol(t3) || sl(t3)))
              return t3;
          });
        }
        function Xc(t2) {
          if ("string" == typeof t2 ? t2 = function(t3) {
            return { text: [t3] };
          }(t2) : t2.text && function(t3) {
            Array.isArray(t3.text) || (t3.text = [t3.text]);
          }(t2), t2.on && (t2.eventListeners = function(t3) {
            for (const e2 in t3)
              tl(t3, e2);
            return t3;
          }(t2.on), delete t2.on), !t2.text) {
            t2.attributes && function(t3) {
              for (const e3 in t3)
                t3[e3].value && (t3[e3].value = [].concat(t3[e3].value)), tl(t3, e3);
            }(t2.attributes);
            const e2 = [];
            if (t2.children)
              if (sl(t2.children))
                e2.push(t2.children);
              else
                for (const n2 of t2.children)
                  rl(n2) || ol(n2) || $o(n2) ? e2.push(n2) : e2.push(new Hc(n2));
            t2.children = e2;
          }
          return t2;
        }
        function tl(t2, e2) {
          Array.isArray(t2[e2]) || (t2[e2] = [t2[e2]]);
        }
        function el(t2, e2) {
          return il(e2) ? t2 : il(t2) ? e2 : `${t2} ${e2}`;
        }
        function nl(t2, e2) {
          for (const n2 in e2)
            t2[n2] ? t2[n2].push(...e2[n2]) : t2[n2] = e2[n2];
        }
        function il(t2) {
          return !t2 && 0 !== t2;
        }
        function ol(t2) {
          return t2 instanceof cl;
        }
        function rl(t2) {
          return t2 instanceof Hc;
        }
        function sl(t2) {
          return t2 instanceof Uc;
        }
        function al(t2) {
          return "class" == t2 || "style" == t2;
        }
        n(15);
        class cl {
          constructor(t2) {
            this.element = null, this.isRendered = false, this.locale = t2, this.t = t2 && t2.t, this._viewCollections = new An(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (e2, n2) => {
              n2.locale = t2;
            }), this.decorate("render");
          }
          get bindTemplate() {
            return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Hc.bind(this, this);
          }
          createCollection(t2) {
            const e2 = new Uc(t2);
            return this._viewCollections.add(e2), e2;
          }
          registerChild(t2) {
            yn(t2) || (t2 = [t2]);
            for (const e2 of t2)
              this._unboundChildren.add(e2);
          }
          deregisterChild(t2) {
            yn(t2) || (t2 = [t2]);
            for (const e2 of t2)
              this._unboundChildren.remove(e2);
          }
          setTemplate(t2) {
            this.template = new Hc(t2);
          }
          extendTemplate(t2) {
            Hc.extend(this.template, t2);
          }
          render() {
            if (this.isRendered)
              throw new hn.b("ui-view-render-already-rendered: This View has already been rendered.", this);
            this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = true;
          }
          destroy() {
            this.stopListening(), this._viewCollections.map((t2) => t2.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
          }
        }
        xn(cl, cr), xn(cl, Ui);
        var ll = function(t2) {
          return "string" == typeof t2 || !Dt(t2) && p(t2) && "[object String]" == f(t2);
        };
        class dl extends Uc {
          constructor(t2, e2 = []) {
            super(e2), this.locale = t2;
          }
          attachToDom() {
            this._bodyCollectionContainer = new Hc({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
            let t2 = document.querySelector(".ck-body-wrapper");
            t2 || (t2 = function(t3, e2, n2 = {}, i2 = []) {
              const o2 = n2 && n2.xmlns, r2 = o2 ? t3.createElementNS(o2, e2) : t3.createElement(e2);
              for (const t4 in n2)
                r2.setAttribute(t4, n2[t4]);
              !ll(i2) && yn(i2) || (i2 = [i2]);
              for (let e3 of i2)
                ll(e3) && (e3 = t3.createTextNode(e3)), r2.appendChild(e3);
              return r2;
            }(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(t2)), t2.appendChild(this._bodyCollectionContainer);
          }
          detachFromDom() {
            super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
            const t2 = document.querySelector(".ck-body-wrapper");
            t2 && 0 == t2.childElementCount && t2.remove();
          }
        }
        n(17);
        class ul extends cl {
          constructor(t2) {
            super(t2), this.body = new dl(t2);
          }
          render() {
            super.render(), this.body.attachToDom();
          }
          destroy() {
            return this.body.detachFromDom(), super.destroy();
          }
        }
        n(19);
        class hl extends cl {
          constructor(t2) {
            super(t2), this.set("text"), this.set("for"), this.id = "ck-editor__label_" + dn();
            const e2 = this.bindTemplate;
            this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e2.to("for") }, children: [{ text: e2.to("text") }] });
          }
        }
        class fl extends ul {
          constructor(t2) {
            super(t2), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t2.uiLanguageDirection, lang: t2.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
          }
          _createVoiceLabel() {
            const t2 = this.t, e2 = new hl();
            return e2.text = t2("Rich Text Editor"), e2.extendTemplate({ attributes: { class: "ck-voice-label" } }), e2;
          }
        }
        class ml extends cl {
          constructor(t2, e2, n2) {
            super(t2), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t2.contentLanguage, dir: t2.contentLanguageDirection } }), this.name = null, this.set("isFocused", false), this._editableElement = n2, this._hasExternalElement = !!this._editableElement, this._editingView = e2;
          }
          render() {
            super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
          }
          destroy() {
            this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
          }
          _updateIsFocusedClasses() {
            const t2 = this._editingView;
            function e2(e3) {
              t2.change((n2) => {
                const i2 = t2.document.getRoot(e3.name);
                n2.addClass(e3.isFocused ? "ck-focused" : "ck-blurred", i2), n2.removeClass(e3.isFocused ? "ck-blurred" : "ck-focused", i2);
              });
            }
            t2.isRenderingInProgress ? function n2(i2) {
              t2.once("change:isRenderingInProgress", (t3, o2, r2) => {
                r2 ? n2(i2) : e2(i2);
              });
            }(this) : e2(this);
          }
        }
        class gl extends ml {
          constructor(t2, e2, n2) {
            super(t2, e2, n2), this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } });
          }
          render() {
            super.render();
            const t2 = this._editingView, e2 = this.t;
            t2.change((n2) => {
              const i2 = t2.document.getRoot(this.name);
              n2.setAttribute("aria-label", e2("Rich Text Editor, %0", [this.name]), i2);
            });
          }
        }
        function pl(t2) {
          return (e2) => e2 + t2;
        }
        n(21);
        const bl = pl("px");
        class wl extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("isActive", false), this.set("isSticky", false), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", false), this.set("_hasViewportTopOffset", false), this.content = this.createCollection(), this._contentPanelPlaceholder = new Hc({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e2.to("isSticky", (t3) => t3 ? "block" : "none"), height: e2.to("isSticky", (t3) => t3 ? bl(this._panelRect.height) : null) } } }).render(), this._contentPanel = new Hc({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e2.if("isSticky", "ck-sticky-panel__content_sticky"), e2.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e2.to("isSticky", (t3) => t3 ? bl(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: e2.to("_hasViewportTopOffset", (t3) => t3 ? bl(this.viewportTopOffset) : null), bottom: e2.to("_isStickyToTheLimiter", (t3) => t3 ? bl(this.limiterBottomOffset) : null), marginLeft: e2.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
          }
          render() {
            super.render(), this._checkIfShouldBeSticky(), this.listenTo(Xo.window, "scroll", () => {
              this._checkIfShouldBeSticky();
            }), this.listenTo(this, "change:isActive", () => {
              this._checkIfShouldBeSticky();
            });
          }
          _checkIfShouldBeSticky() {
            const t2 = this._panelRect = this._contentPanel.getBoundingClientRect();
            let e2;
            this.limiterElement ? (e2 = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && e2.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e2.height) : this.isSticky = false, this.isSticky ? (this._isStickyToTheLimiter = e2.bottom < t2.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : bl(-Xo.window.scrollX)) : (this._isStickyToTheLimiter = false, this._hasViewportTopOffset = false, this._marginLeft = null);
          }
        }
        class kl {
          constructor(t2) {
            if (Object.assign(this, t2), t2.actions && t2.keystrokeHandler)
              for (const e2 in t2.actions) {
                let n2 = t2.actions[e2];
                "string" == typeof n2 && (n2 = [n2]);
                for (const i2 of n2)
                  t2.keystrokeHandler.set(i2, (t3, n3) => {
                    this[e2](), n3();
                  });
              }
          }
          get first() {
            return this.focusables.find(_l) || null;
          }
          get last() {
            return this.focusables.filter(_l).slice(-1)[0] || null;
          }
          get next() {
            return this._getFocusableItem(1);
          }
          get previous() {
            return this._getFocusableItem(-1);
          }
          get current() {
            let t2 = null;
            return null === this.focusTracker.focusedElement ? null : (this.focusables.find((e2, n2) => {
              const i2 = e2.element === this.focusTracker.focusedElement;
              return i2 && (t2 = n2), i2;
            }), t2);
          }
          focusFirst() {
            this._focus(this.first);
          }
          focusLast() {
            this._focus(this.last);
          }
          focusNext() {
            this._focus(this.next);
          }
          focusPrevious() {
            this._focus(this.previous);
          }
          _focus(t2) {
            t2 && t2.focus();
          }
          _getFocusableItem(t2) {
            const e2 = this.current, n2 = this.focusables.length;
            if (!n2)
              return null;
            if (null === e2)
              return this[1 === t2 ? "first" : "last"];
            let i2 = (e2 + n2 + t2) % n2;
            do {
              const e3 = this.focusables.get(i2);
              if (_l(e3))
                return e3;
              i2 = (i2 + n2 + t2) % n2;
            } while (i2 !== e2);
            return null;
          }
        }
        function _l(t2) {
          return !(!t2.focus || "none" == Xo.window.getComputedStyle(t2.element).display);
        }
        class vl extends cl {
          constructor(t2) {
            super(t2), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
          }
        }
        class yl {
          constructor(t2, e2) {
            yl._observerInstance || yl._createObserver(), this._element = t2, this._callback = e2, yl._addElementCallback(t2, e2), yl._observerInstance.observe(t2);
          }
          destroy() {
            yl._deleteElementCallback(this._element, this._callback);
          }
          static _addElementCallback(t2, e2) {
            yl._elementCallbacks || (yl._elementCallbacks = /* @__PURE__ */ new Map());
            let n2 = yl._elementCallbacks.get(t2);
            n2 || (n2 = /* @__PURE__ */ new Set(), yl._elementCallbacks.set(t2, n2)), n2.add(e2);
          }
          static _deleteElementCallback(t2, e2) {
            const n2 = yl._getElementCallbacks(t2);
            n2 && (n2.delete(e2), n2.size || (yl._elementCallbacks.delete(t2), yl._observerInstance.unobserve(t2))), yl._elementCallbacks && !yl._elementCallbacks.size && (yl._observerInstance = null, yl._elementCallbacks = null);
          }
          static _getElementCallbacks(t2) {
            return yl._elementCallbacks ? yl._elementCallbacks.get(t2) : null;
          }
          static _createObserver() {
            let t2;
            t2 = "function" == typeof Xo.window.ResizeObserver ? Xo.window.ResizeObserver : xl, yl._observerInstance = new t2((t3) => {
              for (const e2 of t3) {
                if (!e2.target.offsetParent)
                  continue;
                const t4 = yl._getElementCallbacks(e2.target);
                if (t4)
                  for (const n2 of t4)
                    n2(e2);
              }
            });
          }
        }
        yl._observerInstance = null, yl._elementCallbacks = null;
        class xl {
          constructor(t2) {
            this._callback = t2, this._elements = /* @__PURE__ */ new Set(), this._previousRects = /* @__PURE__ */ new Map(), this._periodicCheckTimeout = null;
          }
          observe(t2) {
            this._elements.add(t2), this._checkElementRectsAndExecuteCallback(), 1 === this._elements.size && this._startPeriodicCheck();
          }
          unobserve(t2) {
            this._elements.delete(t2), this._previousRects.delete(t2), this._elements.size || this._stopPeriodicCheck();
          }
          _startPeriodicCheck() {
            const t2 = () => {
              this._checkElementRectsAndExecuteCallback(), this._periodicCheckTimeout = setTimeout(t2, 100);
            };
            this.listenTo(Xo.window, "resize", () => {
              this._checkElementRectsAndExecuteCallback();
            }), this._periodicCheckTimeout = setTimeout(t2, 100);
          }
          _stopPeriodicCheck() {
            clearTimeout(this._periodicCheckTimeout), this.stopListening(), this._previousRects.clear();
          }
          _checkElementRectsAndExecuteCallback() {
            const t2 = [];
            for (const e2 of this._elements)
              this._hasRectChanged(e2) && t2.push({ target: e2, contentRect: this._previousRects.get(e2) });
            t2.length && this._callback(t2);
          }
          _hasRectChanged(t2) {
            if (!t2.ownerDocument.body.contains(t2))
              return false;
            const e2 = new Zr(t2), n2 = this._previousRects.get(t2), i2 = !n2 || !n2.isEqual(e2);
            return this._previousRects.set(t2, e2), i2;
          }
        }
        xn(xl, cr);
        class Al extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("isVisible", false), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e2.to("position", (t3) => "ck-dropdown__panel_" + t3), e2.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: e2.to((t3) => t3.preventDefault()) } });
          }
          focus() {
            this.children.length && this.children.first.focus();
          }
          focusLast() {
            if (this.children.length) {
              const t2 = this.children.last;
              "function" == typeof t2.focusLast ? t2.focusLast() : t2.focus();
            }
          }
        }
        n(23);
        function Tl({ element: t2, target: e2, positions: n2, limiter: i2, fitInViewport: o2 }) {
          z(e2) && (e2 = e2()), z(i2) && (i2 = i2());
          const r2 = function(t3) {
            return t3 && t3.parentNode ? t3.offsetParent === Xo.document.body ? null : t3.offsetParent : null;
          }(t2), s2 = new Zr(t2), a2 = new Zr(e2);
          let c2, l2;
          if (i2 || o2) {
            const t3 = function(t4, e3) {
              const { elementRect: n3, viewportRect: i3 } = e3, o3 = n3.getArea(), r3 = function(t5, { targetRect: e4, elementRect: n4, limiterRect: i4, viewportRect: o4 }) {
                const r4 = [], s3 = n4.getArea();
                for (const a3 of t5) {
                  const [t6, c3] = Cl(a3, e4, n4);
                  let l3 = 0, d3 = 0;
                  if (i4)
                    if (o4) {
                      const t7 = i4.getIntersection(o4);
                      t7 && (l3 = t7.getIntersectionArea(c3));
                    } else
                      l3 = i4.getIntersectionArea(c3);
                  o4 && (d3 = o4.getIntersectionArea(c3));
                  const u2 = { positionName: t6, positionRect: c3, limiterIntersectArea: l3, viewportIntersectArea: d3 };
                  if (l3 === s3)
                    return [u2];
                  r4.push(u2);
                }
                return r4;
              }(t4, e3);
              if (i3) {
                const t5 = Pl(r3.filter(({ viewportIntersectArea: t6 }) => t6 === o3), o3);
                if (t5)
                  return t5;
              }
              return Pl(r3, o3);
            }(n2, { targetRect: a2, elementRect: s2, limiterRect: i2 && new Zr(i2).getVisible(), viewportRect: o2 && new Zr(Xo.window) });
            [l2, c2] = t3 || Cl(n2[0], a2, s2);
          } else
            [l2, c2] = Cl(n2[0], a2, s2);
          let d2 = Sl(c2);
          return r2 && (d2 = function({ left: t3, top: e3 }, n3) {
            const i3 = Sl(new Zr(n3)), o3 = Kr(n3);
            return t3 -= i3.left, e3 -= i3.top, t3 += n3.scrollLeft, e3 += n3.scrollTop, t3 -= o3.left, e3 -= o3.top, { left: t3, top: e3 };
          }(d2, r2)), { left: d2.left, top: d2.top, name: l2 };
        }
        function Cl(t2, e2, n2) {
          const { left: i2, top: o2, name: r2 } = t2(e2, n2);
          return [r2, n2.clone().moveTo(i2, o2)];
        }
        function Pl(t2, e2) {
          let n2, i2, o2 = 0;
          for (const { positionName: r2, positionRect: s2, limiterIntersectArea: a2, viewportIntersectArea: c2 } of t2) {
            if (a2 === e2)
              return [r2, s2];
            const t3 = c2 ** 2 + a2 ** 2;
            t3 > o2 && (o2 = t3, n2 = s2, i2 = r2);
          }
          return n2 ? [i2, n2] : null;
        }
        function Sl({ left: t2, top: e2 }) {
          const { scrollX: n2, scrollY: i2 } = Xo.window;
          return { left: t2 + n2, top: e2 + i2 };
        }
        class Ml extends cl {
          constructor(t2, e2, n2) {
            super(t2);
            const i2 = this.bindTemplate;
            this.buttonView = e2, this.panelView = n2, this.set("isOpen", false), this.set("isEnabled", true), this.set("class"), this.set("id"), this.set("panelPosition", "auto"), this.keystrokes = new Ac(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", i2.to("class"), i2.if("isEnabled", "ck-disabled", (t3) => !t3)], id: i2.to("id"), "aria-describedby": i2.to("ariaDescribedById") }, children: [e2, n2] }), e2.extendTemplate({ attributes: { class: ["ck-dropdown__button"] } });
          }
          render() {
            super.render(), this.listenTo(this.buttonView, "open", () => {
              this.isOpen = !this.isOpen;
            }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", () => {
              this.isOpen && ("auto" === this.panelPosition ? this.panelView.position = Ml._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
            }), this.keystrokes.listenTo(this.element);
            const t2 = (t3, e2) => {
              this.isOpen && (this.buttonView.focus(), this.isOpen = false, e2());
            };
            this.keystrokes.set("arrowdown", (t3, e2) => {
              this.buttonView.isEnabled && !this.isOpen && (this.isOpen = true, e2());
            }), this.keystrokes.set("arrowright", (t3, e2) => {
              this.isOpen && e2();
            }), this.keystrokes.set("arrowleft", t2), this.keystrokes.set("esc", t2);
          }
          focus() {
            this.buttonView.focus();
          }
          get _panelPositions() {
            const { southEast: t2, southWest: e2, northEast: n2, northWest: i2 } = Ml.defaultPanelPositions;
            return "ltr" === this.locale.uiLanguageDirection ? [t2, e2, n2, i2] : [e2, t2, i2, n2];
          }
        }
        Ml.defaultPanelPositions = { southEast: (t2) => ({ top: t2.bottom, left: t2.left, name: "se" }), southWest: (t2, e2) => ({ top: t2.bottom, left: t2.left - e2.width + t2.width, name: "sw" }), northEast: (t2, e2) => ({ top: t2.top - e2.height, left: t2.left, name: "ne" }), northWest: (t2, e2) => ({ top: t2.bottom - e2.height, left: t2.left - e2.width + t2.width, name: "nw" }) }, Ml._getOptimalPosition = Tl;
        n(25);
        class El extends cl {
          constructor() {
            super();
            const t2 = this.bindTemplate;
            this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon"], viewBox: t2.to("viewBox") } });
          }
          render() {
            super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
              this._updateXMLContent(), this._colorFillPaths();
            }), this.on("change:fillColor", () => {
              this._colorFillPaths();
            });
          }
          _updateXMLContent() {
            if (this.content) {
              const t2 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e2 = t2.getAttribute("viewBox");
              for (e2 && (this.viewBox = e2), this.element.innerHTML = ""; t2.childNodes.length > 0; )
                this.element.appendChild(t2.childNodes[0]);
            }
          }
          _colorFillPaths() {
            this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t2) => {
              t2.style.fill = this.fillColor;
            });
          }
        }
        n(27);
        class Il extends cl {
          constructor(t2) {
            super(t2), this.set("text", ""), this.set("position", "s");
            const e2 = this.bindTemplate;
            this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip", e2.to("position", (t3) => "ck-tooltip_" + t3), e2.if("text", "ck-hidden", (t3) => !t3.trim())] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: e2.to("text") }] }] });
          }
        }
        n(29);
        class Nl extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate, n2 = dn();
            this.set("class"), this.set("labelStyle"), this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isVisible", true), this.set("isToggleable", false), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.set("withKeystroke", false), this.children = this.createCollection(), this.tooltipView = this._createTooltipView(), this.labelView = this._createLabelView(n2), this.iconView = new El(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this)), this.setTemplate({ tag: "button", attributes: { class: ["ck", "ck-button", e2.to("class"), e2.if("isEnabled", "ck-disabled", (t3) => !t3), e2.if("isVisible", "ck-hidden", (t3) => !t3), e2.to("isOn", (t3) => t3 ? "ck-on" : "ck-off"), e2.if("withText", "ck-button_with-text"), e2.if("withKeystroke", "ck-button_with-keystroke")], type: e2.to("type", (t3) => t3 || "button"), tabindex: e2.to("tabindex"), "aria-labelledby": "ck-editor__aria-label_" + n2, "aria-disabled": e2.if("isEnabled", true, (t3) => !t3), "aria-pressed": e2.to("isOn", (t3) => !!this.isToggleable && String(t3)) }, children: this.children, on: { mousedown: e2.to((t3) => {
              t3.preventDefault();
            }), click: e2.to((t3) => {
              this.isEnabled ? this.fire("execute") : t3.preventDefault();
            }) } });
          }
          render() {
            super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.tooltipView), this.children.add(this.labelView), this.withKeystroke && this.children.add(this.keystrokeView);
          }
          focus() {
            this.element.focus();
          }
          _createTooltipView() {
            const t2 = new Il();
            return t2.bind("text").to(this, "_tooltipString"), t2.bind("position").to(this, "tooltipPosition"), t2;
          }
          _createLabelView(t2) {
            const e2 = new cl(), n2 = this.bindTemplate;
            return e2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: n2.to("labelStyle"), id: "ck-editor__aria-label_" + t2 }, children: [{ text: this.bindTemplate.to("label") }] }), e2;
          }
          _createKeystrokeView() {
            const t2 = new cl();
            return t2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t3) => wo(t3)) }] }), t2;
          }
          _getTooltipString(t2, e2, n2) {
            return t2 ? "string" == typeof t2 ? t2 : (n2 && (n2 = wo(n2)), t2 instanceof Function ? t2(e2, n2) : `${e2}${n2 ? ` (${n2})` : ""}`) : "";
          }
        }
        var Ol = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class Rl extends Nl {
          constructor(t2) {
            super(t2), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": true } }), this.delegate("execute").to(this, "open");
          }
          render() {
            super.render(), this.children.add(this.arrowView);
          }
          _createArrowView() {
            const t2 = new El();
            return t2.content = Ol, t2.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), t2;
          }
        }
        n(31);
        class Dl extends cl {
          constructor() {
            super(), this.items = this.createCollection(), this.focusTracker = new Oc(), this.keystrokes = new Ac(), this._focusCycler = new kl({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"] }, children: this.items });
          }
          render() {
            super.render();
            for (const t2 of this.items)
              this.focusTracker.add(t2.element);
            this.items.on("add", (t2, e2) => {
              this.focusTracker.add(e2.element);
            }), this.items.on("remove", (t2, e2) => {
              this.focusTracker.remove(e2.element);
            }), this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        class Ll extends cl {
          constructor(t2) {
            super(t2), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item"] }, children: this.children });
          }
          focus() {
            this.children.first.focus();
          }
        }
        class jl extends cl {
          constructor(t2) {
            super(t2), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
          }
        }
        n(33);
        class Vl extends Nl {
          constructor(t2) {
            super(t2), this.isToggleable = true, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
          }
          render() {
            super.render(), this.children.add(this.toggleSwitchView);
          }
          _createToggleView() {
            const t2 = new cl();
            return t2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), t2;
          }
        }
        function zl({ emitter: t2, activator: e2, callback: n2, contextElements: i2 }) {
          t2.listenTo(document, "mousedown", (t3, { target: o2 }) => {
            if (e2()) {
              for (const t4 of i2)
                if (t4.contains(o2))
                  return;
              n2();
            }
          });
        }
        n(35), n(37);
        function Bl(t2, e2 = Rl) {
          const n2 = new e2(t2), i2 = new Al(t2), o2 = new Ml(t2, n2, i2);
          return n2.bind("isEnabled").to(o2), n2 instanceof Rl ? n2.bind("isOn").to(o2, "isOpen") : n2.arrowView.bind("isOn").to(o2, "isOpen"), function(t3) {
            (function(t4) {
              t4.on("render", () => {
                zl({ emitter: t4, activator: () => t4.isOpen, callback: () => {
                  t4.isOpen = false;
                }, contextElements: [t4.element] });
              });
            })(t3), function(t4) {
              t4.on("execute", (e3) => {
                e3.source instanceof Vl || (t4.isOpen = false);
              });
            }(t3), function(t4) {
              t4.keystrokes.set("arrowdown", (e3, n3) => {
                t4.isOpen && (t4.panelView.focus(), n3());
              }), t4.keystrokes.set("arrowup", (e3, n3) => {
                t4.isOpen && (t4.panelView.focusLast(), n3());
              });
            }(t3);
          }(o2), o2;
        }
        function Fl(t2, e2) {
          const n2 = t2.locale, i2 = t2.listView = new Dl(n2);
          i2.items.bindTo(e2).using(({ type: t3, model: e3 }) => {
            if ("separator" === t3)
              return new jl(n2);
            if ("button" === t3 || "switchbutton" === t3) {
              const i3 = new Ll(n2);
              let o2;
              return o2 = "button" === t3 ? new Nl(n2) : new Vl(n2), o2.bind(...Object.keys(e3)).to(e3), o2.delegate("execute").to(i3), i3.children.add(o2), i3;
            }
          }), t2.panelView.children.add(i2), i2.items.delegate("execute").to(t2);
        }
        n(39);
        class Ul extends cl {
          constructor(t2, e2) {
            super(t2);
            const n2 = this.bindTemplate, i2 = this.t;
            var o2;
            this.options = e2 || {}, this.set("ariaLabel", i2("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Oc(), this.keystrokes = new Ac(), this.set("class"), this.set("isCompact", false), this.itemsView = new Hl(t2), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection(), this._focusCycler = new kl({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: ["arrowleft", "arrowup"], focusNext: ["arrowright", "arrowdown"] } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar", n2.to("class"), n2.if("isCompact", "ck-toolbar_compact")], role: "toolbar", "aria-label": n2.to("ariaLabel"), style: { maxWidth: n2.to("maxWidth") } }, children: this.children, on: { mousedown: (o2 = this, o2.bindTemplate.to((t3) => {
              t3.target === o2.element && t3.preventDefault();
            })) } }), this._behavior = this.options.shouldGroupWhenFull ? new Wl(this) : new ql(this);
          }
          render() {
            super.render();
            for (const t2 of this.items)
              this.focusTracker.add(t2.element);
            this.items.on("add", (t2, e2) => {
              this.focusTracker.add(e2.element);
            }), this.items.on("remove", (t2, e2) => {
              this.focusTracker.remove(e2.element);
            }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
          }
          destroy() {
            return this._behavior.destroy(), super.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          fillFromConfig(t2, e2) {
            t2.map((t3) => {
              "|" == t3 ? this.items.add(new vl()) : e2.has(t3) ? this.items.add(e2.create(t3)) : console.warn(Object(hn.a)("toolbarview-item-unavailable: The requested toolbar item is unavailable."), { name: t3 });
            });
          }
        }
        class Hl extends cl {
          constructor(t2) {
            super(t2), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
          }
        }
        class ql {
          constructor(t2) {
            const e2 = t2.bindTemplate;
            t2.set("isVertical", false), t2.itemsView.children.bindTo(t2.items).using((t3) => t3), t2.focusables.bindTo(t2.items).using((t3) => t3), t2.extendTemplate({ attributes: { class: [e2.if("isVertical", "ck-toolbar_vertical")] } });
          }
          render() {
          }
          destroy() {
          }
        }
        class Wl {
          constructor(t2) {
            this.viewChildren = t2.children, this.viewFocusables = t2.focusables, this.viewItemsView = t2.itemsView, this.viewFocusTracker = t2.focusTracker, this.viewLocale = t2.locale, this.ungroupedItems = t2.createCollection(), this.groupedItems = t2.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = false, t2.itemsView.children.bindTo(this.ungroupedItems).using((t3) => t3), this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this)), this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this)), t2.children.on("add", this._updateFocusCycleableItems.bind(this)), t2.children.on("remove", this._updateFocusCycleableItems.bind(this)), t2.items.on("add", (t3, e2, n2) => {
              n2 > this.ungroupedItems.length ? this.groupedItems.add(e2, n2 - this.ungroupedItems.length) : this.ungroupedItems.add(e2, n2), this._updateGrouping();
            }), t2.items.on("remove", (t3, e2, n2) => {
              n2 > this.ungroupedItems.length ? this.groupedItems.remove(e2) : this.ungroupedItems.remove(e2), this._updateGrouping();
            }), t2.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
          }
          render(t2) {
            this.viewElement = t2.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t2);
          }
          destroy() {
            this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
          }
          _updateGrouping() {
            if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
              return;
            if (!this.viewElement.offsetParent)
              return void (this.shouldUpdateGroupingOnNextResize = true);
            let t2;
            for (; this._areItemsOverflowing; )
              this._groupLastItem(), t2 = true;
            if (!t2 && this.groupedItems.length) {
              for (; this.groupedItems.length && !this._areItemsOverflowing; )
                this._ungroupFirstItem();
              this._areItemsOverflowing && this._groupLastItem();
            }
          }
          get _areItemsOverflowing() {
            if (!this.ungroupedItems.length)
              return false;
            const t2 = this.viewElement, e2 = this.viewLocale.uiLanguageDirection, n2 = new Zr(t2.lastChild), i2 = new Zr(t2);
            if (!this.cachedPadding) {
              const n3 = Xo.window.getComputedStyle(t2), i3 = "ltr" === e2 ? "paddingRight" : "paddingLeft";
              this.cachedPadding = Number.parseInt(n3[i3]);
            }
            return "ltr" === e2 ? n2.right > i2.right - this.cachedPadding : n2.left < i2.left + this.cachedPadding;
          }
          _enableGroupingOnResize() {
            let t2;
            this.resizeObserver = new yl(this.viewElement, (e2) => {
              t2 && t2 === e2.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = false, this._updateGrouping(), t2 = e2.contentRect.width);
            }), this._updateGrouping();
          }
          _enableGroupingOnMaxWidthChange(t2) {
            t2.on("change:maxWidth", () => {
              this._updateGrouping();
            });
          }
          _groupLastItem() {
            this.groupedItems.length || (this.viewChildren.add(new vl()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
          }
          _ungroupFirstItem() {
            this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
          }
          _createGroupedItemsDropdown() {
            const t2 = this.viewLocale, e2 = t2.t, n2 = Bl(t2);
            return n2.class = "ck-toolbar__grouped-dropdown", n2.panelPosition = "ltr" === t2.uiLanguageDirection ? "sw" : "se", function(t3, e3) {
              const n3 = t3.locale, i2 = n3.t, o2 = t3.toolbarView = new Ul(n3);
              o2.set("ariaLabel", i2("Dropdown toolbar")), t3.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), e3.map((t4) => o2.items.add(t4)), t3.panelView.children.add(o2), o2.items.delegate("execute").to(t3);
            }(n2, []), n2.buttonView.set({ label: e2("Show more items"), tooltip: true, icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>' }), n2.toolbarView.items.bindTo(this.groupedItems).using((t3) => t3), n2;
          }
          _updateFocusCycleableItems() {
            this.viewFocusables.clear(), this.ungroupedItems.map((t2) => {
              this.viewFocusables.add(t2);
            }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
        n(41);
        class Yl extends fl {
          constructor(t2, e2, n2 = {}) {
            super(t2), this.stickyPanel = new wl(t2), this.toolbar = new Ul(t2, { shouldGroupWhenFull: n2.shouldToolbarGroupWhenFull }), this.editable = new gl(t2, e2);
          }
          render() {
            super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
          }
        }
        class Gl extends Cc {
          constructor(t2, e2) {
            super(e2), nn(t2) && (this.sourceElement = t2), this.data.processor = new Ec(this.data.viewDocument), this.model.document.createRoot();
            const n2 = !this.config.get("toolbar.shouldNotGroupWhenFull"), i2 = new Yl(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n2 });
            this.ui = new Fc(this, i2), function(t3) {
              if (!z(t3.updateSourceElement))
                throw new hn.b("attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.", t3);
              const e3 = t3.sourceElement;
              if (e3 && "textarea" === e3.tagName.toLowerCase() && e3.form) {
                let n3;
                const i3 = e3.form, o2 = () => t3.updateSourceElement();
                z(i3.submit) && (n3 = i3.submit, i3.submit = () => {
                  o2(), n3.apply(i3);
                }), i3.addEventListener("submit", o2), t3.on("destroy", () => {
                  i3.removeEventListener("submit", o2), n3 && (i3.submit = n3);
                });
              }
            }(this);
          }
          destroy() {
            return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
          }
          static create(t2, e2 = {}) {
            return new Promise((n2) => {
              const i2 = new this(t2, e2);
              n2(i2.initPlugins().then(() => i2.ui.init(nn(t2) ? t2 : null)).then(() => {
                if (!nn(t2) && e2.initialData)
                  throw new hn.b("editor-create-initial-data: The config.initialData option cannot be used together with initial data passed in Editor.create().", null);
                const n3 = e2.initialData || function(t3) {
                  return nn(t3) ? (e3 = t3, e3 instanceof HTMLTextAreaElement ? e3.value : e3.innerHTML) : t3;
                  var e3;
                }(t2);
                return i2.data.init(n3);
              }).then(() => i2.fire("ready")).then(() => i2));
            });
          }
        }
        xn(Gl, Pc), xn(Gl, Sc);
        class $l {
          constructor(t2) {
            this.editor = t2, this.set("isEnabled", true), this._disableStack = /* @__PURE__ */ new Set();
          }
          forceDisabled(t2) {
            this._disableStack.add(t2), 1 == this._disableStack.size && (this.on("set:isEnabled", Ql, { priority: "highest" }), this.isEnabled = false);
          }
          clearForceDisabled(t2) {
            this._disableStack.delete(t2), 0 == this._disableStack.size && (this.off("set:isEnabled", Ql), this.isEnabled = true);
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return false;
          }
        }
        function Ql(t2) {
          t2.return = false, t2.stop();
        }
        xn($l, Ui);
        class Kl {
          constructor(t2) {
            this.files = function(t3) {
              const e2 = t3.files ? Array.from(t3.files) : [], n2 = t3.items ? Array.from(t3.items) : [];
              if (e2.length)
                return e2;
              return n2.filter((t4) => "file" === t4.kind).map((t4) => t4.getAsFile());
            }(t2), this._native = t2;
          }
          get types() {
            return this._native.types;
          }
          getData(t2) {
            return this._native.getData(t2);
          }
          setData(t2, e2) {
            this._native.setData(t2, e2);
          }
        }
        class Jl extends Nr {
          constructor(t2) {
            super(t2);
            const e2 = this.document;
            function n2(t3, n3) {
              n3.preventDefault();
              const i2 = n3.dropRange ? [n3.dropRange] : Array.from(e2.selection.getRanges()), o2 = new cn(e2, "clipboardInput");
              e2.fire(o2, { dataTransfer: n3.dataTransfer, targetRanges: i2 }), o2.stop.called && n3.stopPropagation();
            }
            this.domEventType = ["paste", "copy", "cut", "drop", "dragover"], this.listenTo(e2, "paste", n2, { priority: "low" }), this.listenTo(e2, "drop", n2, { priority: "low" });
          }
          onDomEvent(t2) {
            const e2 = { dataTransfer: new Kl(t2.clipboardData ? t2.clipboardData : t2.dataTransfer) };
            "drop" == t2.type && (e2.dropRange = function(t3, e3) {
              const n2 = e3.target.ownerDocument, i2 = e3.clientX, o2 = e3.clientY;
              let r2;
              n2.caretRangeFromPoint && n2.caretRangeFromPoint(i2, o2) ? r2 = n2.caretRangeFromPoint(i2, o2) : e3.rangeParent && (r2 = n2.createRange(), r2.setStart(e3.rangeParent, e3.rangeOffset), r2.collapse(true));
              return r2 ? t3.domConverter.domRangeToView(r2) : t3.document.selection.getFirstRange();
            }(this.view, t2)), this.fire(t2.type, t2, e2);
          }
        }
        const Zl = ["figcaption", "li"];
        class Xl extends $l {
          static get pluginName() {
            return "Clipboard";
          }
          init() {
            const t2 = this.editor, e2 = t2.model.document, n2 = t2.editing.view, i2 = n2.document;
            function o2(n3, o3) {
              const r2 = o3.dataTransfer;
              o3.preventDefault();
              const s2 = t2.data.toView(t2.model.getSelectedContent(e2.selection));
              i2.fire("clipboardOutput", { dataTransfer: r2, content: s2, method: n3.name });
            }
            this._htmlDataProcessor = new Ec(i2), n2.addObserver(Jl), this.listenTo(i2, "clipboardInput", (e3) => {
              t2.isReadOnly && e3.stop();
            }, { priority: "highest" }), this.listenTo(i2, "clipboardInput", (t3, e3) => {
              const i3 = e3.dataTransfer;
              let o3 = "";
              var r2;
              i3.getData("text/html") ? o3 = function(t4) {
                return t4.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t5, e4) => 1 == e4.length ? " " : e4);
              }(i3.getData("text/html")) : i3.getData("text/plain") && ((r2 = (r2 = i3.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "</p><p>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).indexOf("</p><p>") > -1 && (r2 = `<p>${r2}</p>`), o3 = r2), o3 = this._htmlDataProcessor.toView(o3);
              const s2 = new cn(this, "inputTransformation");
              this.fire(s2, { content: o3, dataTransfer: i3 }), s2.stop.called && t3.stop(), n2.scrollToTheSelection();
            }, { priority: "low" }), this.listenTo(this, "inputTransformation", (t3, e3) => {
              if (!e3.content.isEmpty) {
                const n3 = this.editor.data, i3 = this.editor.model, o3 = n3.toModel(e3.content, "$clipboardHolder");
                if (0 == o3.childCount)
                  return;
                i3.insertContent(o3), t3.stop();
              }
            }, { priority: "low" }), this.listenTo(i2, "copy", o2, { priority: "low" }), this.listenTo(i2, "cut", (e3, n3) => {
              t2.isReadOnly ? n3.preventDefault() : o2(e3, n3);
            }, { priority: "low" }), this.listenTo(i2, "clipboardOutput", (n3, i3) => {
              i3.content.isEmpty || (i3.dataTransfer.setData("text/html", this._htmlDataProcessor.toData(i3.content)), i3.dataTransfer.setData("text/plain", function t3(e3) {
                let n4 = "";
                if (e3.is("text") || e3.is("textProxy"))
                  n4 = e3.data;
                else if (e3.is("img") && e3.hasAttribute("alt"))
                  n4 = e3.getAttribute("alt");
                else {
                  let i4 = null;
                  for (const o3 of e3.getChildren()) {
                    const e4 = t3(o3);
                    i4 && (i4.is("containerElement") || o3.is("containerElement")) && (Zl.includes(i4.name) || Zl.includes(o3.name) ? n4 += "\n" : n4 += "\n\n"), n4 += e4, i4 = o3;
                  }
                }
                return n4;
              }(i3.content))), "cut" == i3.method && t2.model.deleteContent(e2.selection);
            }, { priority: "low" });
          }
        }
        class td {
          constructor(t2) {
            this.editor = t2, this.set("value", void 0), this.set("isEnabled", false), this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
              this.refresh();
            }), this.on("execute", (t3) => {
              this.isEnabled || t3.stop();
            }, { priority: "high" }), this.listenTo(t2, "change:isReadOnly", (t3, e2, n2) => {
              n2 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
            });
          }
          refresh() {
            this.isEnabled = true;
          }
          forceDisabled(t2) {
            this._disableStack.add(t2), 1 == this._disableStack.size && (this.on("set:isEnabled", ed, { priority: "highest" }), this.isEnabled = false);
          }
          clearForceDisabled(t2) {
            this._disableStack.delete(t2), 0 == this._disableStack.size && (this.off("set:isEnabled", ed), this.refresh());
          }
          execute() {
          }
          destroy() {
            this.stopListening();
          }
        }
        function ed(t2) {
          t2.return = false, t2.stop();
        }
        function* nd(t2, e2) {
          for (const n2 of e2)
            n2 && t2.getAttributeProperties(n2[0]).copyOnEnter && (yield n2);
        }
        xn(td, Ui);
        class id extends td {
          execute() {
            const t2 = this.editor.model, e2 = t2.document;
            t2.change((n2) => {
              !function(t3, e3, n3, i2) {
                const o2 = n3.isCollapsed, r2 = n3.getFirstRange(), s2 = r2.start.parent, a2 = r2.end.parent;
                if (i2.isLimit(s2) || i2.isLimit(a2))
                  return void (o2 || s2 != a2 || t3.deleteContent(n3));
                if (o2) {
                  const t4 = nd(e3.model.schema, n3.getAttributes());
                  od(e3, r2.start), e3.setSelectionAttribute(t4);
                } else {
                  const i3 = !(r2.start.isAtStart && r2.end.isAtEnd), o3 = s2 == a2;
                  t3.deleteContent(n3, { leaveUnmerged: i3 }), i3 && (o3 ? od(e3, n3.focus) : e3.setSelection(a2, 0));
                }
              }(this.editor.model, n2, e2.selection, t2.schema), this.fire("afterExecute", { writer: n2 });
            });
          }
        }
        function od(t2, e2) {
          t2.split(e2), t2.setSelection(e2.parent.nextSibling, 0);
        }
        class rd extends ur {
          constructor(t2) {
            super(t2);
            const e2 = this.document;
            e2.on("keydown", (t3, n2) => {
              if (this.isEnabled && n2.keyCode == go.enter) {
                let i2;
                e2.once("enter", (t4) => i2 = t4, { priority: "highest" }), e2.fire("enter", new Ir(e2, n2.domEvent, { isSoft: n2.shiftKey })), i2 && i2.stop.called && t3.stop();
              }
            });
          }
          observe() {
          }
        }
        class sd extends $l {
          static get pluginName() {
            return "Enter";
          }
          init() {
            const t2 = this.editor, e2 = t2.editing.view, n2 = e2.document;
            e2.addObserver(rd), t2.commands.add("enter", new id(t2)), this.listenTo(n2, "enter", (n3, i2) => {
              i2.preventDefault(), i2.isSoft || (t2.execute("enter"), e2.scrollToTheSelection());
            }, { priority: "low" });
          }
        }
        class ad extends td {
          execute() {
            const t2 = this.editor.model, e2 = t2.document;
            t2.change((n2) => {
              !function(t3, e3, n3) {
                const i2 = n3.isCollapsed, o2 = n3.getFirstRange(), r2 = o2.start.parent, s2 = o2.end.parent, a2 = r2 == s2;
                if (i2) {
                  const i3 = nd(t3.schema, n3.getAttributes());
                  cd(t3, e3, o2.end), e3.removeSelectionAttribute(n3.getAttributeKeys()), e3.setSelectionAttribute(i3);
                } else {
                  const i3 = !(o2.start.isAtStart && o2.end.isAtEnd);
                  t3.deleteContent(n3, { leaveUnmerged: i3 }), a2 ? cd(t3, e3, n3.focus) : i3 && e3.setSelection(s2, 0);
                }
              }(t2, n2, e2.selection), this.fire("afterExecute", { writer: n2 });
            });
          }
          refresh() {
            const t2 = this.editor.model, e2 = t2.document;
            this.isEnabled = function(t3, e3) {
              if (e3.rangeCount > 1)
                return false;
              const n2 = e3.anchor;
              if (!n2 || !t3.checkChild(n2, "softBreak"))
                return false;
              const i2 = e3.getFirstRange(), o2 = i2.start.parent, r2 = i2.end.parent;
              if ((ld(o2, t3) || ld(r2, t3)) && o2 !== r2)
                return false;
              return true;
            }(t2.schema, e2.selection);
          }
        }
        function cd(t2, e2, n2) {
          const i2 = e2.createElement("softBreak");
          t2.insertContent(i2, n2), e2.setSelection(i2, "after");
        }
        function ld(t2, e2) {
          return !t2.is("rootElement") && (e2.isLimit(t2) || ld(t2.parent, e2));
        }
        class dd extends $l {
          static get pluginName() {
            return "ShiftEnter";
          }
          init() {
            const t2 = this.editor, e2 = t2.model.schema, n2 = t2.conversion, i2 = t2.editing.view, o2 = i2.document;
            e2.register("softBreak", { allowWhere: "$text", isInline: true }), n2.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n2.for("downcast").elementToElement({ model: "softBreak", view: (t3, e3) => e3.createEmptyElement("br") }), i2.addObserver(rd), t2.commands.add("shiftEnter", new ad(t2)), this.listenTo(o2, "enter", (e3, n3) => {
              n3.preventDefault(), n3.isSoft && (t2.execute("shiftEnter"), i2.scrollToTheSelection());
            }, { priority: "low" });
          }
        }
        class ud extends td {
          execute() {
            const t2 = this.editor.model, e2 = t2.schema.getLimitElement(t2.document.selection);
            t2.change((t3) => {
              t3.setSelection(e2, "in");
            });
          }
        }
        const hd = bo("Ctrl+A");
        class fd extends $l {
          static get pluginName() {
            return "SelectAllEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.editing.view.document;
            t2.commands.add("selectAll", new ud(t2)), this.listenTo(e2, "keydown", (e3, n2) => {
              po(n2) === hd && (t2.execute("selectAll"), n2.preventDefault());
            });
          }
        }
        class md extends $l {
          static get pluginName() {
            return "SelectAllUI";
          }
          init() {
            const t2 = this.editor;
            t2.ui.componentFactory.add("selectAll", (e2) => {
              const n2 = t2.commands.get("selectAll"), i2 = new Nl(e2), o2 = e2.t;
              return i2.set({ label: o2("Select all"), icon: '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: true }), i2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled"), this.listenTo(i2, "execute", () => {
                t2.execute("selectAll"), t2.editing.view.focus();
              }), i2;
            });
          }
        }
        class gd extends $l {
          static get requires() {
            return [fd, md];
          }
          static get pluginName() {
            return "SelectAll";
          }
        }
        class pd {
          constructor(t2, e2 = 20) {
            this.model = t2, this.size = 0, this.limit = e2, this.isLocked = false, this._changeCallback = (t3, e3) => {
              "transparent" != e3.type && e3 !== this._batch && this._reset(true);
            }, this._selectionChangeCallback = () => {
              this._reset();
            }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
          }
          get batch() {
            return this._batch || (this._batch = this.model.createBatch()), this._batch;
          }
          input(t2) {
            this.size += t2, this.size >= this.limit && this._reset(true);
          }
          lock() {
            this.isLocked = true;
          }
          unlock() {
            this.isLocked = false;
          }
          destroy() {
            this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
          }
          _reset(t2) {
            this.isLocked && !t2 || (this._batch = null, this.size = 0);
          }
        }
        class bd extends td {
          constructor(t2, e2) {
            super(t2), this._buffer = new pd(t2.model, e2), this._batches = /* @__PURE__ */ new WeakSet();
          }
          get buffer() {
            return this._buffer;
          }
          destroy() {
            super.destroy(), this._buffer.destroy();
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.document, i2 = t2.text || "", o2 = i2.length, r2 = t2.range ? e2.createSelection(t2.range) : n2.selection, s2 = t2.resultRange;
            e2.enqueueChange(this._buffer.batch, (t3) => {
              this._buffer.lock(), e2.deleteContent(r2), i2 && e2.insertContent(t3.createText(i2, n2.selection.getAttributes()), r2), s2 ? t3.setSelection(s2) : r2.is("documentSelection") || t3.setSelection(r2), this._buffer.unlock(), this._buffer.input(o2), this._batches.add(this._buffer.batch);
            });
          }
        }
        function wd(t2) {
          let e2 = null;
          const n2 = t2.model, i2 = t2.editing.view, o2 = t2.commands.get("input");
          function r2(t3) {
            const r3 = n2.document, a2 = i2.document.isComposing, c2 = e2 && e2.isEqual(r3.selection);
            e2 = null, o2.isEnabled && (function(t4) {
              if (t4.ctrlKey)
                return true;
              return kd.includes(t4.keyCode);
            }(t3) || r3.selection.isCollapsed || a2 && 229 === t3.keyCode || !a2 && 229 === t3.keyCode && c2 || s2());
          }
          function s2() {
            const t3 = o2.buffer;
            t3.lock(), n2.enqueueChange(t3.batch, () => {
              n2.deleteContent(n2.document.selection);
            }), t3.unlock();
          }
          ho.isAndroid ? i2.document.on("beforeinput", (t3, e3) => r2(e3), { priority: "lowest" }) : i2.document.on("keydown", (t3, e3) => r2(e3), { priority: "lowest" }), i2.document.on("compositionstart", function() {
            const t3 = n2.document, e3 = 1 !== t3.selection.rangeCount || t3.selection.getFirstRange().isFlat;
            if (t3.selection.isCollapsed || e3)
              return;
            s2();
          }, { priority: "lowest" }), i2.document.on("compositionend", () => {
            e2 = n2.createSelection(n2.document.selection);
          }, { priority: "lowest" });
        }
        const kd = [po("arrowUp"), po("arrowRight"), po("arrowDown"), po("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
        for (let t2 = 112; t2 <= 135; t2++)
          kd.push(t2);
        function _d(t2) {
          if (t2.newChildren.length - t2.oldChildren.length != 1)
            return;
          const e2 = function(t3, e3) {
            const n3 = [];
            let i2, o2 = 0;
            return t3.forEach((t4) => {
              "equal" == t4 ? (r2(), o2++) : "insert" == t4 ? (s2("insert") ? i2.values.push(e3[o2]) : (r2(), i2 = { type: "insert", index: o2, values: [e3[o2]] }), o2++) : s2("delete") ? i2.howMany++ : (r2(), i2 = { type: "delete", index: o2, howMany: 1 });
            }), r2(), n3;
            function r2() {
              i2 && (n3.push(i2), i2 = null);
            }
            function s2(t4) {
              return i2 && i2.type == t4;
            }
          }(Wo(t2.oldChildren, t2.newChildren, vd), t2.newChildren);
          if (e2.length > 1)
            return;
          const n2 = e2[0];
          return n2.values[0] && n2.values[0].is("text") ? n2 : void 0;
        }
        function vd(t2, e2) {
          return t2 && t2.is("text") && e2 && e2.is("text") ? t2.data === e2.data : t2 === e2;
        }
        class yd {
          constructor(t2) {
            this.editor = t2, this.editing = this.editor.editing;
          }
          handle(t2, e2) {
            if (function(t3) {
              if (0 == t3.length)
                return false;
              for (const e3 of t3)
                if ("children" === e3.type && !_d(e3))
                  return true;
              return false;
            }(t2))
              this._handleContainerChildrenMutations(t2, e2);
            else
              for (const n2 of t2)
                this._handleTextMutation(n2, e2), this._handleTextNodeInsertion(n2);
          }
          _handleContainerChildrenMutations(t2, e2) {
            const n2 = function(t3) {
              const e3 = t3.map((t4) => t4.node).reduce((t4, e4) => t4.getCommonAncestor(e4, { includeSelf: true }));
              if (!e3)
                return;
              return e3.getAncestors({ includeSelf: true, parentFirst: true }).find((t4) => t4.is("containerElement") || t4.is("rootElement"));
            }(t2);
            if (!n2)
              return;
            const i2 = this.editor.editing.view.domConverter.mapViewToDom(n2), o2 = new ir(this.editor.editing.view.document), r2 = this.editor.data.toModel(o2.domToView(i2)).getChild(0), s2 = this.editor.editing.mapper.toModelElement(n2);
            if (!s2)
              return;
            const a2 = Array.from(r2.getChildren()), c2 = Array.from(s2.getChildren()), l2 = a2[a2.length - 1], d2 = c2[c2.length - 1];
            l2 && l2.is("softBreak") && d2 && !d2.is("softBreak") && a2.pop();
            const u2 = this.editor.model.schema;
            if (!xd(a2, u2) || !xd(c2, u2))
              return;
            const h2 = a2.map((t3) => t3.is("text") ? t3.data : "@").join("").replace(/\u00A0/g, " "), f2 = c2.map((t3) => t3.is("text") ? t3.data : "@").join("").replace(/\u00A0/g, " ");
            if (f2 === h2)
              return;
            const m2 = Wo(f2, h2), { firstChangeAt: g2, insertions: p2, deletions: b2 } = Ad(m2);
            let w2 = null;
            e2 && (w2 = this.editing.mapper.toModelRange(e2.getFirstRange()));
            const k2 = h2.substr(g2, p2), _2 = this.editor.model.createRange(this.editor.model.createPositionAt(s2, g2), this.editor.model.createPositionAt(s2, g2 + b2));
            this.editor.execute("input", { text: k2, range: _2, resultRange: w2 });
          }
          _handleTextMutation(t2, e2) {
            if ("text" != t2.type)
              return;
            const n2 = t2.newText.replace(/\u00A0/g, " "), i2 = t2.oldText.replace(/\u00A0/g, " ");
            if (i2 === n2)
              return;
            const o2 = Wo(i2, n2), { firstChangeAt: r2, insertions: s2, deletions: a2 } = Ad(o2);
            let c2 = null;
            e2 && (c2 = this.editing.mapper.toModelRange(e2.getFirstRange()));
            const l2 = this.editing.view.createPositionAt(t2.node, r2), d2 = this.editing.mapper.toModelPosition(l2), u2 = this.editor.model.createRange(d2, d2.getShiftedBy(a2)), h2 = n2.substr(r2, s2);
            this.editor.execute("input", { text: h2, range: u2, resultRange: c2 });
          }
          _handleTextNodeInsertion(t2) {
            if ("children" != t2.type)
              return;
            const e2 = _d(t2), n2 = this.editing.view.createPositionAt(t2.node, e2.index), i2 = this.editing.mapper.toModelPosition(n2), o2 = e2.values[0].data;
            this.editor.execute("input", { text: o2.replace(/\u00A0/g, " "), range: this.editor.model.createRange(i2) });
          }
        }
        function xd(t2, e2) {
          return t2.every((t3) => e2.isInline(t3));
        }
        function Ad(t2) {
          let e2 = null, n2 = null;
          for (let i3 = 0; i3 < t2.length; i3++) {
            "equal" != t2[i3] && (e2 = null === e2 ? i3 : e2, n2 = i3);
          }
          let i2 = 0, o2 = 0;
          for (let r2 = e2; r2 <= n2; r2++)
            "insert" != t2[r2] && i2++, "delete" != t2[r2] && o2++;
          return { insertions: o2, deletions: i2, firstChangeAt: e2 };
        }
        class Td extends $l {
          static get pluginName() {
            return "Input";
          }
          init() {
            const t2 = this.editor, e2 = new bd(t2, t2.config.get("typing.undoStep") || 20);
            t2.commands.add("input", e2), wd(t2), function(t3) {
              t3.editing.view.document.on("mutations", (e3, n2, i2) => {
                new yd(t3).handle(n2, i2);
              });
            }(t2);
          }
          isInput(t2) {
            return this.editor.commands.get("input")._batches.has(t2);
          }
        }
        class Cd extends td {
          constructor(t2, e2) {
            super(t2), this.direction = e2, this._buffer = new pd(t2.model, t2.config.get("typing.undoStep"));
          }
          get buffer() {
            return this._buffer;
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.document;
            e2.enqueueChange(this._buffer.batch, (i2) => {
              this._buffer.lock();
              const o2 = i2.createSelection(t2.selection || n2.selection), r2 = o2.isCollapsed;
              if (o2.isCollapsed && e2.modifySelection(o2, { direction: this.direction, unit: t2.unit }), this._shouldEntireContentBeReplacedWithParagraph(t2.sequence || 1))
                return void this._replaceEntireContentWithParagraph(i2);
              if (o2.isCollapsed)
                return;
              let s2 = 0;
              o2.getFirstRange().getMinimalFlatRanges().forEach((t3) => {
                s2 += eo(t3.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
              }), e2.deleteContent(o2, { doNotResetEntireContent: r2, direction: this.direction }), this._buffer.input(s2), i2.setSelection(o2), this._buffer.unlock();
            });
          }
          _shouldEntireContentBeReplacedWithParagraph(t2) {
            if (t2 > 1)
              return false;
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = e2.schema.getLimitElement(n2);
            if (!(n2.isCollapsed && n2.containsEntireContent(i2)))
              return false;
            if (!e2.schema.checkChild(i2, "paragraph"))
              return false;
            const o2 = i2.getChild(0);
            return !o2 || "paragraph" !== o2.name;
          }
          _replaceEntireContentWithParagraph(t2) {
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = e2.schema.getLimitElement(n2), o2 = t2.createElement("paragraph");
            t2.remove(t2.createRangeIn(i2)), t2.insert(o2, i2), t2.setSelection(o2, 0);
          }
        }
        class Pd extends ur {
          constructor(t2) {
            super(t2);
            const e2 = t2.document;
            let n2 = 0;
            function i2(t3, n3, i3) {
              let o2;
              e2.once("delete", (t4) => o2 = t4, { priority: Number.POSITIVE_INFINITY }), e2.fire("delete", new Ir(e2, n3, i3)), o2 && o2.stop.called && t3.stop();
            }
            e2.on("keyup", (t3, e3) => {
              e3.keyCode != go.delete && e3.keyCode != go.backspace || (n2 = 0);
            }), e2.on("keydown", (t3, e3) => {
              const o2 = {};
              if (e3.keyCode == go.delete)
                o2.direction = "forward", o2.unit = "character";
              else {
                if (e3.keyCode != go.backspace)
                  return;
                o2.direction = "backward", o2.unit = "codePoint";
              }
              const r2 = ho.isMac ? e3.altKey : e3.ctrlKey;
              o2.unit = r2 ? "word" : o2.unit, o2.sequence = ++n2, i2(t3, e3.domEvent, o2);
            }), ho.isAndroid && e2.on("beforeinput", (e3, n3) => {
              if ("deleteContentBackward" != n3.domEvent.inputType)
                return;
              const o2 = { unit: "codepoint", direction: "backward", sequence: 1 }, r2 = n3.domTarget.ownerDocument.defaultView.getSelection();
              r2.anchorNode == r2.focusNode && r2.anchorOffset + 1 != r2.focusOffset && (o2.selectionToRemove = t2.domConverter.domSelectionToView(r2)), i2(e3, n3.domEvent, o2);
            });
          }
          observe() {
          }
        }
        class Sd extends $l {
          static get pluginName() {
            return "Delete";
          }
          init() {
            const t2 = this.editor, e2 = t2.editing.view, n2 = e2.document;
            if (e2.addObserver(Pd), t2.commands.add("forwardDelete", new Cd(t2, "forward")), t2.commands.add("delete", new Cd(t2, "backward")), this.listenTo(n2, "delete", (n3, i2) => {
              const o2 = { unit: i2.unit, sequence: i2.sequence };
              if (i2.selectionToRemove) {
                const e3 = t2.model.createSelection(), n4 = [];
                for (const e4 of i2.selectionToRemove.getRanges())
                  n4.push(t2.editing.mapper.toModelRange(e4));
                e3.setTo(n4), o2.selection = e3;
              }
              t2.execute("forward" == i2.direction ? "forwardDelete" : "delete", o2), i2.preventDefault(), e2.scrollToTheSelection();
            }), ho.isAndroid) {
              let t3 = null;
              this.listenTo(n2, "delete", (e3, n3) => {
                const i2 = n3.domTarget.ownerDocument.defaultView.getSelection();
                t3 = { anchorNode: i2.anchorNode, anchorOffset: i2.anchorOffset, focusNode: i2.focusNode, focusOffset: i2.focusOffset };
              }, { priority: "lowest" }), this.listenTo(n2, "keyup", (e3, n3) => {
                if (t3) {
                  const e4 = n3.domTarget.ownerDocument.defaultView.getSelection();
                  e4.collapse(t3.anchorNode, t3.anchorOffset), e4.extend(t3.focusNode, t3.focusOffset), t3 = null;
                }
              });
            }
          }
        }
        class Md extends $l {
          static get requires() {
            return [Td, Sd];
          }
          static get pluginName() {
            return "Typing";
          }
        }
        const Ed = /* @__PURE__ */ new Map();
        function Id(t2, e2, n2) {
          let i2 = Ed.get(t2);
          i2 || (i2 = /* @__PURE__ */ new Map(), Ed.set(t2, i2)), i2.set(e2, n2);
        }
        function Nd(t2) {
          return [t2];
        }
        function Od(t2, e2, n2 = {}) {
          const i2 = function(t3, e3) {
            const n3 = Ed.get(t3);
            return n3 && n3.has(e3) ? n3.get(e3) : Nd;
          }(t2.constructor, e2.constructor);
          try {
            return i2(t2 = t2.clone(), e2, n2);
          } catch (t3) {
            throw t3;
          }
        }
        function Rd(t2, e2, n2) {
          t2 = t2.slice(), e2 = e2.slice();
          const i2 = new Dd(n2.document, n2.useRelations, n2.forceWeakRemove);
          i2.setOriginalOperations(t2), i2.setOriginalOperations(e2);
          const o2 = i2.originalOperations;
          if (0 == t2.length || 0 == e2.length)
            return { operationsA: t2, operationsB: e2, originalOperations: o2 };
          const r2 = /* @__PURE__ */ new WeakMap();
          for (const e3 of t2)
            r2.set(e3, 0);
          const s2 = { nextBaseVersionA: t2[t2.length - 1].baseVersion + 1, nextBaseVersionB: e2[e2.length - 1].baseVersion + 1, originalOperationsACount: t2.length, originalOperationsBCount: e2.length };
          let a2 = 0;
          for (; a2 < t2.length; ) {
            const n3 = t2[a2], o3 = r2.get(n3);
            if (o3 == e2.length) {
              a2++;
              continue;
            }
            const s3 = e2[o3], c2 = Od(n3, s3, i2.getContext(n3, s3, true)), l2 = Od(s3, n3, i2.getContext(s3, n3, false));
            i2.updateRelation(n3, s3), i2.setOriginalOperations(c2, n3), i2.setOriginalOperations(l2, s3);
            for (const t3 of c2)
              r2.set(t3, o3 + l2.length);
            t2.splice(a2, 1, ...c2), e2.splice(o3, 1, ...l2);
          }
          if (n2.padWithNoOps) {
            const n3 = t2.length - s2.originalOperationsACount, i3 = e2.length - s2.originalOperationsBCount;
            jd(t2, i3 - n3), jd(e2, n3 - i3);
          }
          return Ld(t2, s2.nextBaseVersionB), Ld(e2, s2.nextBaseVersionA), { operationsA: t2, operationsB: e2, originalOperations: o2 };
        }
        class Dd {
          constructor(t2, e2, n2 = false) {
            this.originalOperations = /* @__PURE__ */ new Map(), this._history = t2.history, this._useRelations = e2, this._forceWeakRemove = !!n2, this._relations = /* @__PURE__ */ new Map();
          }
          setOriginalOperations(t2, e2 = null) {
            const n2 = e2 ? this.originalOperations.get(e2) : null;
            for (const e3 of t2)
              this.originalOperations.set(e3, n2 || e3);
          }
          updateRelation(t2, e2) {
            switch (t2.constructor) {
              case Ra:
                switch (e2.constructor) {
                  case za:
                    t2.targetPosition.isEqual(e2.sourcePosition) || e2.movedRange.containsPosition(t2.targetPosition) ? this._setRelation(t2, e2, "insertAtSource") : t2.targetPosition.isEqual(e2.deletionPosition) ? this._setRelation(t2, e2, "insertBetween") : t2.targetPosition.isAfter(e2.sourcePosition) && this._setRelation(t2, e2, "moveTargetAfter");
                    break;
                  case Ra:
                    t2.targetPosition.isEqual(e2.sourcePosition) || t2.targetPosition.isBefore(e2.sourcePosition) ? this._setRelation(t2, e2, "insertBefore") : this._setRelation(t2, e2, "insertAfter");
                }
                break;
              case Ba:
                switch (e2.constructor) {
                  case za:
                    t2.splitPosition.isBefore(e2.sourcePosition) && this._setRelation(t2, e2, "splitBefore");
                    break;
                  case Ra:
                    (t2.splitPosition.isEqual(e2.sourcePosition) || t2.splitPosition.isBefore(e2.sourcePosition)) && this._setRelation(t2, e2, "splitBefore");
                }
                break;
              case za:
                switch (e2.constructor) {
                  case za:
                    t2.targetPosition.isEqual(e2.sourcePosition) || this._setRelation(t2, e2, "mergeTargetNotMoved"), t2.sourcePosition.isEqual(e2.targetPosition) && this._setRelation(t2, e2, "mergeSourceNotMoved"), t2.sourcePosition.isEqual(e2.sourcePosition) && this._setRelation(t2, e2, "mergeSameElement");
                    break;
                  case Ba:
                    t2.sourcePosition.isEqual(e2.splitPosition) && this._setRelation(t2, e2, "splitAtSource");
                }
                break;
              case La: {
                const n2 = t2.newRange;
                if (!n2)
                  return;
                switch (e2.constructor) {
                  case Ra: {
                    const i2 = xs._createFromPositionAndShift(e2.sourcePosition, e2.howMany), o2 = i2.containsPosition(n2.start) || i2.start.isEqual(n2.start), r2 = i2.containsPosition(n2.end) || i2.end.isEqual(n2.end);
                    !o2 && !r2 || i2.containsRange(n2) || this._setRelation(t2, e2, { side: o2 ? "left" : "right", path: o2 ? n2.start.path.slice() : n2.end.path.slice() });
                    break;
                  }
                  case za: {
                    const i2 = n2.start.isEqual(e2.targetPosition), o2 = n2.start.isEqual(e2.deletionPosition), r2 = n2.end.isEqual(e2.deletionPosition), s2 = n2.end.isEqual(e2.sourcePosition);
                    (i2 || o2 || r2 || s2) && this._setRelation(t2, e2, { wasInLeftElement: i2, wasStartBeforeMergedElement: o2, wasEndBeforeMergedElement: r2, wasInRightElement: s2 });
                    break;
                  }
                }
                break;
              }
            }
          }
          getContext(t2, e2, n2) {
            return { aIsStrong: n2, aWasUndone: this._wasUndone(t2), bWasUndone: this._wasUndone(e2), abRelation: this._useRelations ? this._getRelation(t2, e2) : null, baRelation: this._useRelations ? this._getRelation(e2, t2) : null, forceWeakRemove: this._forceWeakRemove };
          }
          _wasUndone(t2) {
            const e2 = this.originalOperations.get(t2);
            return e2.wasUndone || this._history.isUndoneOperation(e2);
          }
          _getRelation(t2, e2) {
            const n2 = this.originalOperations.get(e2), i2 = this._history.getUndoneOperation(n2);
            if (!i2)
              return null;
            const o2 = this.originalOperations.get(t2), r2 = this._relations.get(o2);
            return r2 && r2.get(i2) || null;
          }
          _setRelation(t2, e2, n2) {
            const i2 = this.originalOperations.get(t2), o2 = this.originalOperations.get(e2);
            let r2 = this._relations.get(i2);
            r2 || (r2 = /* @__PURE__ */ new Map(), this._relations.set(i2, r2)), r2.set(o2, n2);
          }
        }
        function Ld(t2, e2) {
          for (const n2 of t2)
            n2.baseVersion = e2++;
        }
        function jd(t2, e2) {
          for (let n2 = 0; n2 < e2; n2++)
            t2.push(new rc(0));
        }
        function Vd(t2, e2, n2) {
          const i2 = t2.nodes.getNode(0).getAttribute(e2);
          if (i2 == n2)
            return null;
          const o2 = new xs(t2.position, t2.position.getShiftedBy(t2.howMany));
          return new Na(o2, e2, i2, n2, 0);
        }
        function zd(t2, e2) {
          return null === t2.targetPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
        }
        function Bd(t2, e2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const o2 = t2[i2], r2 = new Ra(o2.start, o2.end.offset - o2.start.offset, e2, 0);
            n2.push(r2);
            for (let e3 = i2 + 1; e3 < t2.length; e3++)
              t2[e3] = t2[e3]._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany)[0];
            e2 = e2._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany);
          }
          return n2;
        }
        Id(Na, Na, (t2, e2, n2) => {
          if (t2.key === e2.key && t2.range.start.hasSameParentAs(e2.range.start)) {
            const i2 = t2.range.getDifference(e2.range).map((e3) => new Na(e3, t2.key, t2.oldValue, t2.newValue, 0)), o2 = t2.range.getIntersection(e2.range);
            return o2 && n2.aIsStrong && i2.push(new Na(o2, e2.key, e2.newValue, t2.newValue, 0)), 0 == i2.length ? [new rc(0)] : i2;
          }
          return [t2];
        }), Id(Na, Da, (t2, e2) => {
          if (t2.range.start.hasSameParentAs(e2.position) && t2.range.containsPosition(e2.position)) {
            const n2 = t2.range._getTransformedByInsertion(e2.position, e2.howMany, !e2.shouldReceiveAttributes).map((e3) => new Na(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion));
            if (e2.shouldReceiveAttributes) {
              const i2 = Vd(e2, t2.key, t2.oldValue);
              i2 && n2.unshift(i2);
            }
            return n2;
          }
          return t2.range = t2.range._getTransformedByInsertion(e2.position, e2.howMany, false)[0], [t2];
        }), Id(Na, za, (t2, e2) => {
          const n2 = [];
          t2.range.start.hasSameParentAs(e2.deletionPosition) && (t2.range.containsPosition(e2.deletionPosition) || t2.range.start.isEqual(e2.deletionPosition)) && n2.push(xs._createFromPositionAndShift(e2.graveyardPosition, 1));
          const i2 = t2.range._getTransformedByMergeOperation(e2);
          return i2.isCollapsed || n2.push(i2), n2.map((e3) => new Na(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion));
        }), Id(Na, Ra, (t2, e2) => function(t3, e3) {
          const n2 = xs._createFromPositionAndShift(e3.sourcePosition, e3.howMany);
          let i2 = null, o2 = [];
          n2.containsRange(t3, true) ? i2 = t3 : t3.start.hasSameParentAs(n2.start) ? (o2 = t3.getDifference(n2), i2 = t3.getIntersection(n2)) : o2 = [t3];
          const r2 = [];
          for (let t4 of o2) {
            t4 = t4._getTransformedByDeletion(e3.sourcePosition, e3.howMany);
            const n3 = e3.getMovedRangeStart(), i3 = t4.start.hasSameParentAs(n3);
            t4 = t4._getTransformedByInsertion(n3, e3.howMany, i3), r2.push(...t4);
          }
          i2 && r2.push(i2._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany, false)[0]);
          return r2;
        }(t2.range, e2).map((e3) => new Na(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion))), Id(Na, Ba, (t2, e2) => {
          if (t2.range.end.isEqual(e2.insertionPosition))
            return e2.graveyardPosition || t2.range.end.offset++, [t2];
          if (t2.range.start.hasSameParentAs(e2.splitPosition) && t2.range.containsPosition(e2.splitPosition)) {
            const n2 = t2.clone();
            return n2.range = new xs(e2.moveTargetPosition.clone(), t2.range.end._getCombined(e2.splitPosition, e2.moveTargetPosition)), t2.range.end = e2.splitPosition.clone(), t2.range.end.stickiness = "toPrevious", [t2, n2];
          }
          return t2.range = t2.range._getTransformedBySplitOperation(e2), [t2];
        }), Id(Da, Na, (t2, e2) => {
          const n2 = [t2];
          if (t2.shouldReceiveAttributes && t2.position.hasSameParentAs(e2.range.start) && e2.range.containsPosition(t2.position)) {
            const i2 = Vd(t2, e2.key, e2.newValue);
            i2 && n2.push(i2);
          }
          return n2;
        }), Id(Da, Da, (t2, e2, n2) => (t2.position.isEqual(e2.position) && n2.aIsStrong || (t2.position = t2.position._getTransformedByInsertOperation(e2)), [t2])), Id(Da, Ra, (t2, e2) => (t2.position = t2.position._getTransformedByMoveOperation(e2), [t2])), Id(Da, Ba, (t2, e2) => (t2.position = t2.position._getTransformedBySplitOperation(e2), [t2])), Id(Da, za, (t2, e2) => (t2.position = t2.position._getTransformedByMergeOperation(e2), [t2])), Id(La, Da, (t2, e2) => (t2.oldRange && (t2.oldRange = t2.oldRange._getTransformedByInsertOperation(e2)[0]), t2.newRange && (t2.newRange = t2.newRange._getTransformedByInsertOperation(e2)[0]), [t2])), Id(La, La, (t2, e2, n2) => {
          if (t2.name == e2.name) {
            if (!n2.aIsStrong)
              return [new rc(0)];
            t2.oldRange = e2.newRange ? e2.newRange.clone() : null;
          }
          return [t2];
        }), Id(La, za, (t2, e2) => (t2.oldRange && (t2.oldRange = t2.oldRange._getTransformedByMergeOperation(e2)), t2.newRange && (t2.newRange = t2.newRange._getTransformedByMergeOperation(e2)), [t2])), Id(La, Ra, (t2, e2, n2) => {
          if (t2.oldRange && (t2.oldRange = xs._createFromRanges(t2.oldRange._getTransformedByMoveOperation(e2))), t2.newRange) {
            if (n2.abRelation) {
              const i2 = xs._createFromRanges(t2.newRange._getTransformedByMoveOperation(e2));
              if ("left" == n2.abRelation.side && e2.targetPosition.isEqual(t2.newRange.start))
                return t2.newRange.start.path = n2.abRelation.path, t2.newRange.end = i2.end, [t2];
              if ("right" == n2.abRelation.side && e2.targetPosition.isEqual(t2.newRange.end))
                return t2.newRange.start = i2.start, t2.newRange.end.path = n2.abRelation.path, [t2];
            }
            t2.newRange = xs._createFromRanges(t2.newRange._getTransformedByMoveOperation(e2));
          }
          return [t2];
        }), Id(La, Ba, (t2, e2, n2) => {
          if (t2.oldRange && (t2.oldRange = t2.oldRange._getTransformedBySplitOperation(e2)), t2.newRange) {
            if (n2.abRelation) {
              const i2 = t2.newRange._getTransformedBySplitOperation(e2);
              return t2.newRange.start.isEqual(e2.splitPosition) && n2.abRelation.wasStartBeforeMergedElement ? t2.newRange.start = ks._createAt(e2.insertionPosition) : t2.newRange.start.isEqual(e2.splitPosition) && !n2.abRelation.wasInLeftElement && (t2.newRange.start = ks._createAt(e2.moveTargetPosition)), t2.newRange.end.isEqual(e2.splitPosition) && n2.abRelation.wasInRightElement ? t2.newRange.end = ks._createAt(e2.moveTargetPosition) : t2.newRange.end.isEqual(e2.splitPosition) && n2.abRelation.wasEndBeforeMergedElement ? t2.newRange.end = ks._createAt(e2.insertionPosition) : t2.newRange.end = i2.end, [t2];
            }
            t2.newRange = t2.newRange._getTransformedBySplitOperation(e2);
          }
          return [t2];
        }), Id(za, Da, (t2, e2) => (t2.sourcePosition.hasSameParentAs(e2.position) && (t2.howMany += e2.howMany), t2.sourcePosition = t2.sourcePosition._getTransformedByInsertOperation(e2), t2.targetPosition = t2.targetPosition._getTransformedByInsertOperation(e2), [t2])), Id(za, za, (t2, e2, n2) => {
          if (t2.sourcePosition.isEqual(e2.sourcePosition) && t2.targetPosition.isEqual(e2.targetPosition)) {
            if (n2.bWasUndone) {
              const n3 = e2.graveyardPosition.path.slice();
              return n3.push(0), t2.sourcePosition = new ks(e2.graveyardPosition.root, n3), t2.howMany = 0, [t2];
            }
            return [new rc(0)];
          }
          if (t2.sourcePosition.isEqual(e2.sourcePosition) && !t2.targetPosition.isEqual(e2.targetPosition) && !n2.bWasUndone && "splitAtSource" != n2.abRelation) {
            const i2 = "$graveyard" == t2.targetPosition.root.rootName, o2 = "$graveyard" == e2.targetPosition.root.rootName, r2 = i2 && !o2;
            if (o2 && !i2 || !r2 && n2.aIsStrong) {
              const n3 = e2.targetPosition._getTransformedByMergeOperation(e2), i3 = t2.targetPosition._getTransformedByMergeOperation(e2);
              return [new Ra(n3, t2.howMany, i3, 0)];
            }
            return [new rc(0)];
          }
          return t2.sourcePosition.hasSameParentAs(e2.targetPosition) && (t2.howMany += e2.howMany), t2.sourcePosition = t2.sourcePosition._getTransformedByMergeOperation(e2), t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2), t2.graveyardPosition.isEqual(e2.graveyardPosition) && n2.aIsStrong || (t2.graveyardPosition = t2.graveyardPosition._getTransformedByMergeOperation(e2)), [t2];
        }), Id(za, Ra, (t2, e2, n2) => {
          const i2 = xs._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          return "remove" == e2.type && !n2.bWasUndone && !n2.forceWeakRemove && t2.deletionPosition.hasSameParentAs(e2.sourcePosition) && i2.containsPosition(t2.sourcePosition) ? [new rc(0)] : (t2.sourcePosition.hasSameParentAs(e2.targetPosition) && (t2.howMany += e2.howMany), t2.sourcePosition.hasSameParentAs(e2.sourcePosition) && (t2.howMany -= e2.howMany), t2.sourcePosition = t2.sourcePosition._getTransformedByMoveOperation(e2), t2.targetPosition = t2.targetPosition._getTransformedByMoveOperation(e2), t2.graveyardPosition.isEqual(e2.targetPosition) || (t2.graveyardPosition = t2.graveyardPosition._getTransformedByMoveOperation(e2)), [t2]);
        }), Id(za, Ba, (t2, e2, n2) => {
          if (e2.graveyardPosition && (t2.graveyardPosition = t2.graveyardPosition._getTransformedByDeletion(e2.graveyardPosition, 1), t2.deletionPosition.isEqual(e2.graveyardPosition) && (t2.howMany = e2.howMany)), t2.targetPosition.isEqual(e2.splitPosition)) {
            const i2 = 0 != e2.howMany, o2 = e2.graveyardPosition && t2.deletionPosition.isEqual(e2.graveyardPosition);
            if (i2 || o2 || "mergeTargetNotMoved" == n2.abRelation)
              return t2.sourcePosition = t2.sourcePosition._getTransformedBySplitOperation(e2), [t2];
          }
          if (t2.sourcePosition.isEqual(e2.splitPosition)) {
            if ("mergeSourceNotMoved" == n2.abRelation)
              return t2.howMany = 0, t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2), [t2];
            if ("mergeSameElement" == n2.abRelation || t2.sourcePosition.offset > 0)
              return t2.sourcePosition = e2.moveTargetPosition.clone(), t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2), [t2];
          }
          return t2.sourcePosition.hasSameParentAs(e2.splitPosition) && (t2.howMany = e2.splitPosition.offset), t2.sourcePosition = t2.sourcePosition._getTransformedBySplitOperation(e2), t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2), [t2];
        }), Id(Ra, Da, (t2, e2) => {
          const n2 = xs._createFromPositionAndShift(t2.sourcePosition, t2.howMany)._getTransformedByInsertOperation(e2, false)[0];
          return t2.sourcePosition = n2.start, t2.howMany = n2.end.offset - n2.start.offset, t2.targetPosition.isEqual(e2.position) || (t2.targetPosition = t2.targetPosition._getTransformedByInsertOperation(e2)), [t2];
        }), Id(Ra, Ra, (t2, e2, n2) => {
          const i2 = xs._createFromPositionAndShift(t2.sourcePosition, t2.howMany), o2 = xs._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          let r2, s2 = n2.aIsStrong, a2 = !n2.aIsStrong;
          if ("insertBefore" == n2.abRelation || "insertAfter" == n2.baRelation ? a2 = true : "insertAfter" != n2.abRelation && "insertBefore" != n2.baRelation || (a2 = false), r2 = t2.targetPosition.isEqual(e2.targetPosition) && a2 ? t2.targetPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany) : t2.targetPosition._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany), zd(t2, e2) && zd(e2, t2))
            return [e2.getReversed()];
          if (i2.containsPosition(e2.targetPosition) && i2.containsRange(o2, true))
            return i2.start = i2.start._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany), i2.end = i2.end._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany), Bd([i2], r2);
          if (o2.containsPosition(t2.targetPosition) && o2.containsRange(i2, true))
            return i2.start = i2.start._getCombined(e2.sourcePosition, e2.getMovedRangeStart()), i2.end = i2.end._getCombined(e2.sourcePosition, e2.getMovedRangeStart()), Bd([i2], r2);
          const c2 = In(t2.sourcePosition.getParentPath(), e2.sourcePosition.getParentPath());
          if ("prefix" == c2 || "extension" == c2)
            return i2.start = i2.start._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany), i2.end = i2.end._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany), Bd([i2], r2);
          "remove" != t2.type || "remove" == e2.type || n2.aWasUndone || n2.forceWeakRemove ? "remove" == t2.type || "remove" != e2.type || n2.bWasUndone || n2.forceWeakRemove || (s2 = false) : s2 = true;
          const l2 = [], d2 = i2.getDifference(o2);
          for (const t3 of d2) {
            t3.start = t3.start._getTransformedByDeletion(e2.sourcePosition, e2.howMany), t3.end = t3.end._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
            const n3 = "same" == In(t3.start.getParentPath(), e2.getMovedRangeStart().getParentPath()), i3 = t3._getTransformedByInsertion(e2.getMovedRangeStart(), e2.howMany, n3);
            l2.push(...i3);
          }
          const u2 = i2.getIntersection(o2);
          return null !== u2 && s2 && (u2.start = u2.start._getCombined(e2.sourcePosition, e2.getMovedRangeStart()), u2.end = u2.end._getCombined(e2.sourcePosition, e2.getMovedRangeStart()), 0 === l2.length ? l2.push(u2) : 1 == l2.length ? o2.start.isBefore(i2.start) || o2.start.isEqual(i2.start) ? l2.unshift(u2) : l2.push(u2) : l2.splice(1, 0, u2)), 0 === l2.length ? [new rc(t2.baseVersion)] : Bd(l2, r2);
        }), Id(Ra, Ba, (t2, e2, n2) => {
          let i2 = t2.targetPosition.clone();
          t2.targetPosition.isEqual(e2.insertionPosition) && e2.graveyardPosition && "moveTargetAfter" != n2.abRelation || (i2 = t2.targetPosition._getTransformedBySplitOperation(e2));
          const o2 = xs._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          if (o2.end.isEqual(e2.insertionPosition))
            return e2.graveyardPosition || t2.howMany++, t2.targetPosition = i2, [t2];
          if (o2.start.hasSameParentAs(e2.splitPosition) && o2.containsPosition(e2.splitPosition)) {
            let t3 = new xs(e2.splitPosition, o2.end);
            return t3 = t3._getTransformedBySplitOperation(e2), Bd([new xs(o2.start, e2.splitPosition), t3], i2);
          }
          t2.targetPosition.isEqual(e2.splitPosition) && "insertAtSource" == n2.abRelation && (i2 = e2.moveTargetPosition), t2.targetPosition.isEqual(e2.insertionPosition) && "insertBetween" == n2.abRelation && (i2 = t2.targetPosition);
          const r2 = [o2._getTransformedBySplitOperation(e2)];
          if (e2.graveyardPosition) {
            const i3 = o2.start.isEqual(e2.graveyardPosition) || o2.containsPosition(e2.graveyardPosition);
            t2.howMany > 1 && i3 && !n2.aWasUndone && r2.push(xs._createFromPositionAndShift(e2.insertionPosition, 1));
          }
          return Bd(r2, i2);
        }), Id(Ra, za, (t2, e2, n2) => {
          const i2 = xs._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          if (e2.deletionPosition.hasSameParentAs(t2.sourcePosition) && i2.containsPosition(e2.sourcePosition)) {
            if ("remove" != t2.type || n2.forceWeakRemove) {
              if (1 == t2.howMany)
                return n2.bWasUndone ? (t2.sourcePosition = e2.graveyardPosition.clone(), t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2), [t2]) : [new rc(0)];
            } else if (!n2.aWasUndone) {
              const n3 = [];
              let i3 = e2.graveyardPosition.clone(), o3 = e2.targetPosition._getTransformedByMergeOperation(e2);
              t2.howMany > 1 && (n3.push(new Ra(t2.sourcePosition, t2.howMany - 1, t2.targetPosition, 0)), i3 = i3._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany - 1), o3 = o3._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany - 1));
              const r2 = e2.deletionPosition._getCombined(t2.sourcePosition, t2.targetPosition), s2 = new Ra(i3, 1, r2, 0), a2 = s2.getMovedRangeStart().path.slice();
              a2.push(0);
              const c2 = new ks(s2.targetPosition.root, a2);
              o3 = o3._getTransformedByMove(i3, r2, 1);
              const l2 = new Ra(o3, e2.howMany, c2, 0);
              return n3.push(s2), n3.push(l2), n3;
            }
          }
          const o2 = xs._createFromPositionAndShift(t2.sourcePosition, t2.howMany)._getTransformedByMergeOperation(e2);
          return t2.sourcePosition = o2.start, t2.howMany = o2.end.offset - o2.start.offset, t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2), [t2];
        }), Id(ja, Da, (t2, e2) => (t2.position = t2.position._getTransformedByInsertOperation(e2), [t2])), Id(ja, za, (t2, e2) => t2.position.isEqual(e2.deletionPosition) ? (t2.position = e2.graveyardPosition.clone(), t2.position.stickiness = "toNext", [t2]) : (t2.position = t2.position._getTransformedByMergeOperation(e2), [t2])), Id(ja, Ra, (t2, e2) => (t2.position = t2.position._getTransformedByMoveOperation(e2), [t2])), Id(ja, ja, (t2, e2, n2) => {
          if (t2.position.isEqual(e2.position)) {
            if (!n2.aIsStrong)
              return [new rc(0)];
            t2.oldName = e2.newName;
          }
          return [t2];
        }), Id(ja, Ba, (t2, e2) => {
          if ("same" == In(t2.position.path, e2.splitPosition.getParentPath()) && !e2.graveyardPosition) {
            const e3 = new ja(t2.position.getShiftedBy(1), t2.oldName, t2.newName, 0);
            return [t2, e3];
          }
          return t2.position = t2.position._getTransformedBySplitOperation(e2), [t2];
        }), Id(Va, Va, (t2, e2, n2) => {
          if (t2.root === e2.root && t2.key === e2.key) {
            if (!n2.aIsStrong || t2.newValue === e2.newValue)
              return [new rc(0)];
            t2.oldValue = e2.newValue;
          }
          return [t2];
        }), Id(Ba, Da, (t2, e2) => (t2.splitPosition.hasSameParentAs(e2.position) && t2.splitPosition.offset < e2.position.offset && (t2.howMany += e2.howMany), t2.splitPosition = t2.splitPosition._getTransformedByInsertOperation(e2), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), [t2])), Id(Ba, za, (t2, e2, n2) => {
          if (!t2.graveyardPosition && !n2.bWasUndone && t2.splitPosition.hasSameParentAs(e2.sourcePosition)) {
            const n3 = e2.graveyardPosition.path.slice();
            n3.push(0);
            const i2 = new ks(e2.graveyardPosition.root, n3), o2 = Ba.getInsertionPosition(new ks(e2.graveyardPosition.root, n3)), r2 = new Ba(i2, 0, null, 0);
            return r2.insertionPosition = o2, t2.splitPosition = t2.splitPosition._getTransformedByMergeOperation(e2), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), t2.graveyardPosition = r2.insertionPosition.clone(), t2.graveyardPosition.stickiness = "toNext", [r2, t2];
          }
          return t2.splitPosition.hasSameParentAs(e2.deletionPosition) && !t2.splitPosition.isAfter(e2.deletionPosition) && t2.howMany--, t2.splitPosition.hasSameParentAs(e2.targetPosition) && (t2.howMany += e2.howMany), t2.splitPosition = t2.splitPosition._getTransformedByMergeOperation(e2), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), t2.graveyardPosition && (t2.graveyardPosition = t2.graveyardPosition._getTransformedByMergeOperation(e2)), [t2];
        }), Id(Ba, Ra, (t2, e2, n2) => {
          const i2 = xs._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          if (t2.graveyardPosition) {
            const o2 = i2.start.isEqual(t2.graveyardPosition) || i2.containsPosition(t2.graveyardPosition);
            if (!n2.bWasUndone && o2) {
              const n3 = t2.splitPosition._getTransformedByMoveOperation(e2), i3 = t2.graveyardPosition._getTransformedByMoveOperation(e2), o3 = i3.path.slice();
              o3.push(0);
              const r2 = new ks(i3.root, o3);
              return [new Ra(n3, t2.howMany, r2, 0)];
            }
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByMoveOperation(e2);
          }
          if (t2.splitPosition.hasSameParentAs(e2.sourcePosition) && i2.containsPosition(t2.splitPosition)) {
            const n3 = e2.howMany - (t2.splitPosition.offset - e2.sourcePosition.offset);
            return t2.howMany -= n3, t2.splitPosition.hasSameParentAs(e2.targetPosition) && t2.splitPosition.offset < e2.targetPosition.offset && (t2.howMany += e2.howMany), t2.splitPosition = e2.sourcePosition.clone(), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), [t2];
          }
          return !t2.splitPosition.isEqual(e2.targetPosition) || "insertAtSource" != n2.baRelation && "splitBefore" != n2.abRelation ? (e2.sourcePosition.isEqual(e2.targetPosition) || (t2.splitPosition.hasSameParentAs(e2.sourcePosition) && t2.splitPosition.offset <= e2.sourcePosition.offset && (t2.howMany -= e2.howMany), t2.splitPosition.hasSameParentAs(e2.targetPosition) && t2.splitPosition.offset < e2.targetPosition.offset && (t2.howMany += e2.howMany)), t2.splitPosition.stickiness = "toNone", t2.splitPosition = t2.splitPosition._getTransformedByMoveOperation(e2), t2.splitPosition.stickiness = "toNext", t2.graveyardPosition ? t2.insertionPosition = t2.insertionPosition._getTransformedByMoveOperation(e2) : t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), [t2]) : (t2.howMany += e2.howMany, t2.splitPosition = t2.splitPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), [t2]);
        }), Id(Ba, Ba, (t2, e2, n2) => {
          if (t2.splitPosition.isEqual(e2.splitPosition)) {
            if (!t2.graveyardPosition && !e2.graveyardPosition)
              return [new rc(0)];
            if (t2.graveyardPosition && e2.graveyardPosition && t2.graveyardPosition.isEqual(e2.graveyardPosition))
              return [new rc(0)];
            if ("splitBefore" == n2.abRelation)
              return t2.howMany = 0, t2.graveyardPosition = t2.graveyardPosition._getTransformedBySplitOperation(e2), [t2];
          }
          if (t2.graveyardPosition && e2.graveyardPosition && t2.graveyardPosition.isEqual(e2.graveyardPosition)) {
            const i2 = "$graveyard" == t2.splitPosition.root.rootName, o2 = "$graveyard" == e2.splitPosition.root.rootName, r2 = i2 && !o2;
            if (o2 && !i2 || !r2 && n2.aIsStrong) {
              const n3 = [];
              return e2.howMany && n3.push(new Ra(e2.moveTargetPosition, e2.howMany, e2.splitPosition, 0)), t2.howMany && n3.push(new Ra(t2.splitPosition, t2.howMany, t2.moveTargetPosition, 0)), n3;
            }
            return [new rc(0)];
          }
          if (t2.graveyardPosition && (t2.graveyardPosition = t2.graveyardPosition._getTransformedBySplitOperation(e2)), t2.splitPosition.isEqual(e2.insertionPosition) && "splitBefore" == n2.abRelation)
            return t2.howMany++, [t2];
          if (e2.splitPosition.isEqual(t2.insertionPosition) && "splitBefore" == n2.baRelation) {
            const n3 = e2.insertionPosition.path.slice();
            n3.push(0);
            const i2 = new ks(e2.insertionPosition.root, n3);
            return [t2, new Ra(t2.insertionPosition, 1, i2, 0)];
          }
          return t2.splitPosition.hasSameParentAs(e2.splitPosition) && t2.splitPosition.offset < e2.splitPosition.offset && (t2.howMany -= e2.howMany), t2.splitPosition = t2.splitPosition._getTransformedBySplitOperation(e2), t2.insertionPosition = Ba.getInsertionPosition(t2.splitPosition), [t2];
        });
        class Fd extends td {
          constructor(t2) {
            super(t2), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh();
          }
          refresh() {
            this.isEnabled = this._stack.length > 0;
          }
          addBatch(t2) {
            const e2 = this.editor.model.document.selection, n2 = { ranges: e2.hasOwnRange ? Array.from(e2.getRanges()) : [], isBackward: e2.isBackward };
            this._stack.push({ batch: t2, selection: n2 }), this.refresh();
          }
          clearStack() {
            this._stack = [], this.refresh();
          }
          _restoreSelection(t2, e2, n2) {
            const i2 = this.editor.model, o2 = i2.document, r2 = [];
            for (const e3 of t2) {
              const t3 = Ud(e3, n2).find((t4) => t4.start.root != o2.graveyard);
              t3 && r2.push(t3);
            }
            r2.length && i2.change((t3) => {
              t3.setSelection(r2, { backward: e2 });
            });
          }
          _undo(t2, e2) {
            const n2 = this.editor.model, i2 = n2.document;
            this._createdBatches.add(e2);
            const o2 = t2.operations.slice().filter((t3) => t3.isDocumentOperation);
            o2.reverse();
            for (const t3 of o2) {
              const o3 = t3.baseVersion + 1, r2 = Array.from(i2.history.getOperations(o3)), s2 = Rd([t3.getReversed()], r2, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }).operationsA;
              for (const o4 of s2)
                e2.addOperation(o4), n2.applyOperation(o4), i2.history.setOperationAsUndone(t3, o4);
            }
          }
        }
        function Ud(t2, e2) {
          const n2 = t2.getTransformedByOperations(e2);
          n2.sort((t3, e3) => t3.start.isBefore(e3.start) ? -1 : 1);
          for (let t3 = 1; t3 < n2.length; t3++) {
            const e3 = n2[t3 - 1], i2 = n2[t3];
            e3.end.isTouching(i2.start) && (e3.end = i2.end, n2.splice(t3, 1), t3--);
          }
          return n2;
        }
        class Hd extends Fd {
          execute(t2 = null) {
            const e2 = t2 ? this._stack.findIndex((e3) => e3.batch == t2) : this._stack.length - 1, n2 = this._stack.splice(e2, 1)[0], i2 = this.editor.model.createBatch("transparent");
            this.editor.model.enqueueChange(i2, () => {
              this._undo(n2.batch, i2);
              const t3 = this.editor.model.document.history.getOperations(n2.batch.baseVersion);
              this._restoreSelection(n2.selection.ranges, n2.selection.isBackward, t3), this.fire("revert", n2.batch, i2);
            }), this.refresh();
          }
        }
        class qd extends Fd {
          execute() {
            const t2 = this._stack.pop(), e2 = this.editor.model.createBatch("transparent");
            this.editor.model.enqueueChange(e2, () => {
              const n2 = t2.batch.operations[t2.batch.operations.length - 1].baseVersion + 1, i2 = this.editor.model.document.history.getOperations(n2);
              this._restoreSelection(t2.selection.ranges, t2.selection.isBackward, i2), this._undo(t2.batch, e2);
            }), this.refresh();
          }
        }
        class Wd extends $l {
          static get pluginName() {
            return "UndoEditing";
          }
          constructor(t2) {
            super(t2), this._batchRegistry = /* @__PURE__ */ new WeakSet();
          }
          init() {
            const t2 = this.editor;
            this._undoCommand = new Hd(t2), this._redoCommand = new qd(t2), t2.commands.add("undo", this._undoCommand), t2.commands.add("redo", this._redoCommand), this.listenTo(t2.model, "applyOperation", (t3, e2) => {
              const n2 = e2[0];
              if (!n2.isDocumentOperation)
                return;
              const i2 = n2.batch, o2 = this._redoCommand._createdBatches.has(i2), r2 = this._undoCommand._createdBatches.has(i2);
              this._batchRegistry.has(i2) || "transparent" == i2.type && !o2 && !r2 || (o2 ? this._undoCommand.addBatch(i2) : r2 || (this._undoCommand.addBatch(i2), this._redoCommand.clearStack()), this._batchRegistry.add(i2));
            }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t3, e2, n2) => {
              this._redoCommand.addBatch(n2);
            }), t2.keystrokes.set("CTRL+Z", "undo"), t2.keystrokes.set("CTRL+Y", "redo"), t2.keystrokes.set("CTRL+SHIFT+Z", "redo");
          }
        }
        var Yd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', Gd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class $d extends $l {
          init() {
            const t2 = this.editor, e2 = t2.locale, n2 = t2.t, i2 = "ltr" == e2.uiLanguageDirection ? Yd : Gd, o2 = "ltr" == e2.uiLanguageDirection ? Gd : Yd;
            this._addButton("undo", n2("Undo"), "CTRL+Z", i2), this._addButton("redo", n2("Redo"), "CTRL+Y", o2);
          }
          _addButton(t2, e2, n2, i2) {
            const o2 = this.editor;
            o2.ui.componentFactory.add(t2, (r2) => {
              const s2 = o2.commands.get(t2), a2 = new Nl(r2);
              return a2.set({ label: e2, icon: i2, keystroke: n2, tooltip: true }), a2.bind("isEnabled").to(s2, "isEnabled"), this.listenTo(a2, "execute", () => {
                o2.execute(t2), o2.editing.view.focus();
              }), a2;
            });
          }
        }
        class Qd extends $l {
          static get requires() {
            return [Wd, $d];
          }
          static get pluginName() {
            return "Undo";
          }
        }
        class Kd {
          constructor(t2) {
            this.context = t2;
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return true;
          }
        }
        xn(Kd, Ui);
        class Jd extends Kd {
          static get pluginName() {
            return "PendingActions";
          }
          init() {
            this.set("hasAny", false), this._actions = new An({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
          }
          add(t2) {
            if ("string" != typeof t2)
              throw new hn.b("pendingactions-add-invalid-message: The message must be a string.", this);
            const e2 = Object.create(Ui);
            return e2.set("message", t2), this._actions.add(e2), this.hasAny = true, e2;
          }
          remove(t2) {
            this._actions.remove(t2), this.hasAny = !!this._actions.length;
          }
          get first() {
            return this._actions.get(0);
          }
          [Symbol.iterator]() {
            return this._actions[Symbol.iterator]();
          }
        }
        class Zd {
          constructor() {
            const t2 = new window.FileReader();
            this._reader = t2, this._data = void 0, this.set("loaded", 0), t2.onprogress = (t3) => {
              this.loaded = t3.loaded;
            };
          }
          get error() {
            return this._reader.error;
          }
          get data() {
            return this._data;
          }
          read(t2) {
            const e2 = this._reader;
            return this.total = t2.size, new Promise((n2, i2) => {
              e2.onload = () => {
                const t3 = e2.result;
                this._data = t3, n2(t3);
              }, e2.onerror = () => {
                i2("error");
              }, e2.onabort = () => {
                i2("aborted");
              }, this._reader.readAsDataURL(t2);
            });
          }
          abort() {
            this._reader.abort();
          }
        }
        xn(Zd, Ui);
        class Xd extends $l {
          static get pluginName() {
            return "FileRepository";
          }
          static get requires() {
            return [Jd];
          }
          init() {
            this.loaders = new An(), this.loaders.on("add", () => this._updatePendingAction()), this.loaders.on("remove", () => this._updatePendingAction()), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null, this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t2, e2) => e2 ? t2 / e2 * 100 : 0);
          }
          getLoader(t2) {
            return this._loadersMap.get(t2) || null;
          }
          createLoader(t2) {
            if (!this.createUploadAdapter)
              return console.warn(Object(hn.a)("filerepository-no-upload-adapter: Upload adapter is not defined.")), null;
            const e2 = new tu(Promise.resolve(t2), this.createUploadAdapter);
            return this.loaders.add(e2), this._loadersMap.set(t2, e2), t2 instanceof Promise && e2.file.then((t3) => {
              this._loadersMap.set(t3, e2);
            }).catch(() => {
            }), e2.on("change:uploaded", () => {
              let t3 = 0;
              for (const e3 of this.loaders)
                t3 += e3.uploaded;
              this.uploaded = t3;
            }), e2.on("change:uploadTotal", () => {
              let t3 = 0;
              for (const e3 of this.loaders)
                e3.uploadTotal && (t3 += e3.uploadTotal);
              this.uploadTotal = t3;
            }), e2;
          }
          destroyLoader(t2) {
            const e2 = t2 instanceof tu ? t2 : this.getLoader(t2);
            e2._destroy(), this.loaders.remove(e2), this._loadersMap.forEach((t3, n2) => {
              t3 === e2 && this._loadersMap.delete(n2);
            });
          }
          _updatePendingAction() {
            const t2 = this.editor.plugins.get(Jd);
            if (this.loaders.length) {
              if (!this._pendingAction) {
                const e2 = this.editor.t, n2 = (t3) => `${e2("Upload in progress")} ${parseInt(t3)}%.`;
                this._pendingAction = t2.add(n2(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n2);
              }
            } else
              t2.remove(this._pendingAction), this._pendingAction = null;
          }
        }
        xn(Xd, Ui);
        class tu {
          constructor(t2, e2) {
            this.id = dn(), this._filePromiseWrapper = this._createFilePromiseWrapper(t2), this._adapter = e2(this), this._reader = new Zd(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t3, e3) => e3 ? t3 / e3 * 100 : 0), this.set("uploadResponse", null);
          }
          get file() {
            return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t2) => this._filePromiseWrapper ? t2 : null) : Promise.resolve(null);
          }
          get data() {
            return this._reader.data;
          }
          read() {
            if ("idle" != this.status)
              throw new hn.b("filerepository-read-wrong-status: You cannot call read if the status is different than idle.", this);
            return this.status = "reading", this.file.then((t2) => this._reader.read(t2)).then((t2) => {
              if ("reading" !== this.status)
                throw this.status;
              return this.status = "idle", t2;
            }).catch((t2) => {
              if ("aborted" === t2)
                throw this.status = "aborted", "aborted";
              throw this.status = "error", this._reader.error ? this._reader.error : t2;
            });
          }
          upload() {
            if ("idle" != this.status)
              throw new hn.b("filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.", this);
            return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((t2) => (this.uploadResponse = t2, this.status = "idle", t2)).catch((t2) => {
              if ("aborted" === this.status)
                throw "aborted";
              throw this.status = "error", t2;
            });
          }
          abort() {
            const t2 = this.status;
            this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t2 ? this._reader.abort() : "uploading" == t2 && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
            }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
          }
          _destroy() {
            this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
          }
          _createFilePromiseWrapper(t2) {
            const e2 = {};
            return e2.promise = new Promise((n2, i2) => {
              e2.rejecter = i2, e2.isFulfilled = false, t2.then((t3) => {
                e2.isFulfilled = true, n2(t3);
              }).catch((t3) => {
                e2.isFulfilled = true, i2(t3);
              });
            }), e2;
          }
        }
        xn(tu, Ui);
        function eu() {
          let t2 = function(t3) {
            t3 = t3.toLowerCase();
            const e3 = document.cookie.split(";");
            for (const n3 of e3) {
              const e4 = n3.split("=");
              if (decodeURIComponent(e4[0].trim().toLowerCase()) === t3)
                return decodeURIComponent(e4[1]);
            }
            return null;
          }("ckCsrfToken");
          var e2, n2;
          return t2 && 40 == t2.length || (t2 = function(t3) {
            let e3 = "";
            const n3 = new Uint8Array(t3);
            window.crypto.getRandomValues(n3);
            for (let t4 = 0; t4 < n3.length; t4++) {
              const i2 = "abcdefghijklmnopqrstuvwxyz0123456789".charAt(n3[t4] % "abcdefghijklmnopqrstuvwxyz0123456789".length);
              e3 += Math.random() > 0.5 ? i2.toUpperCase() : i2;
            }
            return e3;
          }(40), e2 = "ckCsrfToken", n2 = t2, document.cookie = encodeURIComponent(e2) + "=" + encodeURIComponent(n2) + ";path=/"), t2;
        }
        class nu extends $l {
          static get requires() {
            return [Xd];
          }
          static get pluginName() {
            return "CKFinderUploadAdapter";
          }
          init() {
            const t2 = this.editor.config.get("ckfinder.uploadUrl");
            t2 && (this.editor.plugins.get(Xd).createUploadAdapter = (e2) => new iu(e2, t2, this.editor.t));
          }
        }
        class iu {
          constructor(t2, e2, n2) {
            this.loader = t2, this.url = e2, this.t = n2;
          }
          upload() {
            return this.loader.file.then((t2) => new Promise((e2, n2) => {
              this._initRequest(), this._initListeners(e2, n2, t2), this._sendRequest(t2);
            }));
          }
          abort() {
            this.xhr && this.xhr.abort();
          }
          _initRequest() {
            const t2 = this.xhr = new XMLHttpRequest();
            t2.open("POST", this.url, true), t2.responseType = "json";
          }
          _initListeners(t2, e2, n2) {
            const i2 = this.xhr, o2 = this.loader, r2 = (0, this.t)("Cannot upload file:") + ` ${n2.name}.`;
            i2.addEventListener("error", () => e2(r2)), i2.addEventListener("abort", () => e2()), i2.addEventListener("load", () => {
              const n3 = i2.response;
              if (!n3 || !n3.uploaded)
                return e2(n3 && n3.error && n3.error.message ? n3.error.message : r2);
              t2({ default: n3.url });
            }), i2.upload && i2.upload.addEventListener("progress", (t3) => {
              t3.lengthComputable && (o2.uploadTotal = t3.total, o2.uploaded = t3.loaded);
            });
          }
          _sendRequest(t2) {
            const e2 = new FormData();
            e2.append("upload", t2), e2.append("ckCsrfToken", eu()), this.xhr.send(e2);
          }
        }
        class ou {
          static get pluginName() {
            return "BlockAutoformatEditing";
          }
          constructor(t2, e2, n2) {
            let i2, o2 = null;
            "function" == typeof n2 ? i2 = n2 : (o2 = t2.commands.get(n2), i2 = () => {
              t2.execute(n2);
            }), t2.model.document.on("change", (n3, r2) => {
              if (o2 && !o2.isEnabled)
                return;
              if ("transparent" == r2.type)
                return;
              const s2 = Array.from(t2.model.document.differ.getChanges()), a2 = s2[0];
              if (1 != s2.length || "insert" !== a2.type || "$text" != a2.name || 1 != a2.length)
                return;
              const c2 = a2.position.parent;
              if (!c2.is("paragraph") || 1 !== c2.childCount)
                return;
              const l2 = e2.exec(c2.getChild(0).data);
              l2 && t2.model.enqueueChange((t3) => {
                const e3 = t3.createPositionAt(c2, 0), n4 = t3.createPositionAt(c2, l2[0].length), o3 = new Rs(e3, n4);
                false !== i2({ match: l2 }) && t3.remove(o3), o3.detach();
              });
            });
          }
        }
        function ru(t2, e2) {
          let n2 = t2.start;
          return { text: Array.from(t2.getItems()).reduce((t3, i2) => i2.is("text") || i2.is("textProxy") ? t3 + i2.data : (n2 = e2.createPositionAfter(i2), ""), ""), range: e2.createRange(n2, t2.end) };
        }
        class su {
          static get pluginName() {
            return "InlineAutoformatEditing";
          }
          constructor(t2, e2, n2) {
            let i2, o2, r2, s2;
            e2 instanceof RegExp ? i2 = e2 : r2 = e2, "string" == typeof n2 ? o2 = n2 : s2 = n2, r2 = r2 || ((t3) => {
              let e3;
              const n3 = [], o3 = [];
              for (; null !== (e3 = i2.exec(t3)) && !(e3 && e3.length < 4); ) {
                let { index: t4, 1: i3, 2: r3, 3: s3 } = e3;
                const a2 = i3 + r3 + s3;
                t4 += e3[0].length - a2.length;
                const c2 = [t4, t4 + i3.length], l2 = [t4 + i3.length + r3.length, t4 + i3.length + r3.length + s3.length];
                n3.push(c2), n3.push(l2), o3.push([t4 + i3.length, t4 + i3.length + r3.length]);
              }
              return { remove: n3, format: o3 };
            }), s2 = s2 || ((e3, n3) => {
              const i3 = t2.model.schema.getValidRanges(n3, o2);
              for (const t3 of i3)
                e3.setAttribute(o2, true, t3);
              e3.removeSelectionAttribute(o2);
            }), t2.model.document.on("change", (e3, n3) => {
              if ("transparent" == n3.type)
                return;
              const i3 = t2.model, o3 = i3.document.selection;
              if (!o3.isCollapsed)
                return;
              const a2 = Array.from(i3.document.differ.getChanges()), c2 = a2[0];
              if (1 != a2.length || "insert" !== c2.type || "$text" != c2.name || 1 != c2.length)
                return;
              const l2 = o3.focus, d2 = l2.parent, { text: u2, range: h2 } = ru(i3.createRange(i3.createPositionAt(d2, 0), l2), i3), f2 = r2(u2), m2 = au(h2.start, f2.format, i3), g2 = au(h2.start, f2.remove, i3);
              m2.length && g2.length && i3.enqueueChange((t3) => {
                if (false !== s2(t3, m2))
                  for (const e4 of g2.reverse())
                    t3.remove(e4);
              });
            });
          }
        }
        function au(t2, e2, n2) {
          return e2.filter((t3) => void 0 !== t3[0] && void 0 !== t3[1]).map((e3) => n2.createRange(t2.getShiftedBy(e3[0]), t2.getShiftedBy(e3[1])));
        }
        function cu(t2, e2) {
          return (n2, i2) => {
            if (!t2.commands.get(e2).isEnabled)
              return false;
            const o2 = t2.model.schema.getValidRanges(i2, e2);
            for (const t3 of o2)
              n2.setAttribute(e2, true, t3);
            n2.removeSelectionAttribute(e2);
          };
        }
        class lu extends td {
          constructor(t2, e2) {
            super(t2), this.attributeKey = e2;
          }
          refresh() {
            const t2 = this.editor.model, e2 = t2.document;
            this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t2.schema.checkAttributeInSelection(e2.selection, this.attributeKey);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = void 0 === t2.forceValue ? !this.value : t2.forceValue;
            e2.change((t3) => {
              if (n2.isCollapsed)
                i2 ? t3.setSelectionAttribute(this.attributeKey, true) : t3.removeSelectionAttribute(this.attributeKey);
              else {
                const o2 = e2.schema.getValidRanges(n2.getRanges(), this.attributeKey);
                for (const e3 of o2)
                  i2 ? t3.setAttribute(this.attributeKey, i2, e3) : t3.removeAttribute(this.attributeKey, e3);
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t2 = this.editor.model, e2 = t2.schema, n2 = t2.document.selection;
            if (n2.isCollapsed)
              return n2.hasAttribute(this.attributeKey);
            for (const t3 of n2.getRanges())
              for (const n3 of t3.getItems())
                if (e2.checkAttribute(n3, this.attributeKey))
                  return n3.hasAttribute(this.attributeKey);
            return false;
          }
        }
        class du extends $l {
          static get pluginName() {
            return "BoldEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", { allowAttributes: "bold" }), t2.model.schema.setAttributeProperties("bold", { isFormatting: true, copyOnEnter: true }), t2.conversion.attributeToElement({ model: "bold", view: "strong", upcastAlso: ["b", (t3) => {
              const e2 = t3.getStyle("font-weight");
              return e2 ? "bold" == e2 || Number(e2) >= 600 ? { name: true, styles: ["font-weight"] } : void 0 : null;
            }] }), t2.commands.add("bold", new lu(t2, "bold")), t2.keystrokes.set("CTRL+B", "bold");
          }
        }
        class uu extends $l {
          init() {
            const t2 = this.editor, e2 = t2.t;
            t2.ui.componentFactory.add("bold", (n2) => {
              const i2 = t2.commands.get("bold"), o2 = new Nl(n2);
              return o2.set({ label: e2("Bold"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', keystroke: "CTRL+B", tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(i2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
                t2.execute("bold"), t2.editing.view.focus();
              }), o2;
            });
          }
        }
        class hu extends $l {
          static get pluginName() {
            return "ItalicEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", { allowAttributes: "italic" }), t2.model.schema.setAttributeProperties("italic", { isFormatting: true, copyOnEnter: true }), t2.conversion.attributeToElement({ model: "italic", view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), t2.commands.add("italic", new lu(t2, "italic")), t2.keystrokes.set("CTRL+I", "italic");
          }
        }
        class fu extends $l {
          init() {
            const t2 = this.editor, e2 = t2.t;
            t2.ui.componentFactory.add("italic", (n2) => {
              const i2 = t2.commands.get("italic"), o2 = new Nl(n2);
              return o2.set({ label: e2("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(i2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
                t2.execute("italic"), t2.editing.view.focus();
              }), o2;
            });
          }
        }
        function mu(t2) {
          const e2 = t2.next();
          return e2.done ? null : e2.value;
        }
        class gu extends td {
          refresh() {
            this.value = this._getValue(), this.isEnabled = this._checkEnabled();
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.schema, i2 = e2.document.selection, o2 = Array.from(i2.getSelectedBlocks()), r2 = void 0 === t2.forceValue ? !this.value : t2.forceValue;
            e2.change((t3) => {
              if (r2) {
                const e3 = o2.filter((t4) => pu(t4) || wu(n2, t4));
                this._applyQuote(t3, e3);
              } else
                this._removeQuote(t3, o2.filter(pu));
            });
          }
          _getValue() {
            const t2 = mu(this.editor.model.document.selection.getSelectedBlocks());
            return !(!t2 || !pu(t2));
          }
          _checkEnabled() {
            if (this.value)
              return true;
            const t2 = this.editor.model.document.selection, e2 = this.editor.model.schema, n2 = mu(t2.getSelectedBlocks());
            return !!n2 && wu(e2, n2);
          }
          _removeQuote(t2, e2) {
            bu(t2, e2).reverse().forEach((e3) => {
              if (e3.start.isAtStart && e3.end.isAtEnd)
                return void t2.unwrap(e3.start.parent);
              if (e3.start.isAtStart) {
                const n3 = t2.createPositionBefore(e3.start.parent);
                return void t2.move(e3, n3);
              }
              e3.end.isAtEnd || t2.split(e3.end);
              const n2 = t2.createPositionAfter(e3.end.parent);
              t2.move(e3, n2);
            });
          }
          _applyQuote(t2, e2) {
            const n2 = [];
            bu(t2, e2).reverse().forEach((e3) => {
              let i2 = pu(e3.start);
              i2 || (i2 = t2.createElement("blockQuote"), t2.wrap(e3, i2)), n2.push(i2);
            }), n2.reverse().reduce((e3, n3) => e3.nextSibling == n3 ? (t2.merge(t2.createPositionAfter(e3)), e3) : n3);
          }
        }
        function pu(t2) {
          return "blockQuote" == t2.parent.name ? t2.parent : null;
        }
        function bu(t2, e2) {
          let n2, i2 = 0;
          const o2 = [];
          for (; i2 < e2.length; ) {
            const r2 = e2[i2], s2 = e2[i2 + 1];
            n2 || (n2 = t2.createPositionBefore(r2)), s2 && r2.nextSibling == s2 || (o2.push(t2.createRange(n2, t2.createPositionAfter(r2))), n2 = null), i2++;
          }
          return o2;
        }
        function wu(t2, e2) {
          const n2 = t2.checkChild(e2.parent, "blockQuote"), i2 = t2.checkChild(["$root", "blockQuote"], e2);
          return n2 && i2;
        }
        class ku extends $l {
          static get pluginName() {
            return "BlockQuoteEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.model.schema;
            t2.commands.add("blockQuote", new gu(t2)), e2.register("blockQuote", { allowWhere: "$block", allowContentOf: "$root" }), e2.addChildCheck((t3, e3) => {
              if (t3.endsWith("blockQuote") && "blockQuote" == e3.name)
                return false;
            }), t2.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), t2.model.document.registerPostFixer((n2) => {
              const i2 = t2.model.document.differ.getChanges();
              for (const t3 of i2)
                if ("insert" == t3.type) {
                  const i3 = t3.position.nodeAfter;
                  if (!i3)
                    continue;
                  if (i3.is("blockQuote") && i3.isEmpty)
                    return n2.remove(i3), true;
                  if (i3.is("blockQuote") && !e2.checkChild(t3.position, i3))
                    return n2.unwrap(i3), true;
                  if (i3.is("element")) {
                    const t4 = n2.createRangeIn(i3);
                    for (const i4 of t4.getItems())
                      if (i4.is("blockQuote") && !e2.checkChild(n2.createPositionBefore(i4), i4))
                        return n2.unwrap(i4), true;
                  }
                } else if ("remove" == t3.type) {
                  const e3 = t3.position.parent;
                  if (e3.is("blockQuote") && e3.isEmpty)
                    return n2.remove(e3), true;
                }
              return false;
            });
          }
          afterInit() {
            const t2 = this.editor.commands.get("blockQuote");
            this.listenTo(this.editor.editing.view.document, "enter", (e2, n2) => {
              const i2 = this.editor.model.document, o2 = i2.selection.getLastPosition().parent;
              i2.selection.isCollapsed && o2.isEmpty && t2.value && (this.editor.execute("blockQuote"), this.editor.editing.view.scrollToTheSelection(), n2.preventDefault(), e2.stop());
            });
          }
        }
        n(43);
        class _u extends $l {
          init() {
            const t2 = this.editor, e2 = t2.t;
            t2.ui.componentFactory.add("blockQuote", (n2) => {
              const i2 = t2.commands.get("blockQuote"), o2 = new Nl(n2);
              return o2.set({ label: e2("Block quote"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(i2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
                t2.execute("blockQuote"), t2.editing.view.focus();
              }), o2;
            });
          }
        }
        class vu extends $l {
          static get pluginName() {
            return "CKFinderUI";
          }
          init() {
            const t2 = this.editor, e2 = t2.ui.componentFactory, n2 = t2.t;
            e2.add("ckfinder", (e3) => {
              const i2 = t2.commands.get("ckfinder"), o2 = new Nl(e3);
              return o2.set({ label: n2("Insert image or file"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', tooltip: true }), o2.bind("isEnabled").to(i2), o2.on("execute", () => {
                t2.execute("ckfinder"), t2.editing.view.focus();
              }), o2;
            });
          }
        }
        class yu extends ur {
          observe(t2) {
            this.listenTo(t2, "load", (t3, e2) => {
              "IMG" == e2.target.tagName && this._fireEvents(e2);
            }, { useCapture: true });
          }
          _fireEvents(t2) {
            this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t2));
          }
        }
        class xu {
          constructor() {
            this._stack = [];
          }
          add(t2, e2) {
            const n2 = this._stack, i2 = n2[0];
            this._insertDescriptor(t2);
            const o2 = n2[0];
            i2 === o2 || Au(i2, o2) || this.fire("change:top", { oldDescriptor: i2, newDescriptor: o2, writer: e2 });
          }
          remove(t2, e2) {
            const n2 = this._stack, i2 = n2[0];
            this._removeDescriptor(t2);
            const o2 = n2[0];
            i2 === o2 || Au(i2, o2) || this.fire("change:top", { oldDescriptor: i2, newDescriptor: o2, writer: e2 });
          }
          _insertDescriptor(t2) {
            const e2 = this._stack, n2 = e2.findIndex((e3) => e3.id === t2.id);
            if (Au(t2, e2[n2]))
              return;
            n2 > -1 && e2.splice(n2, 1);
            let i2 = 0;
            for (; e2[i2] && Tu(e2[i2], t2); )
              i2++;
            e2.splice(i2, 0, t2);
          }
          _removeDescriptor(t2) {
            const e2 = this._stack, n2 = e2.findIndex((e3) => e3.id === t2);
            n2 > -1 && e2.splice(n2, 1);
          }
        }
        function Au(t2, e2) {
          return t2 && e2 && t2.priority == e2.priority && Cu(t2.classes) == Cu(e2.classes);
        }
        function Tu(t2, e2) {
          return t2.priority > e2.priority || !(t2.priority < e2.priority) && Cu(t2.classes) > Cu(e2.classes);
        }
        function Cu(t2) {
          return Array.isArray(t2) ? t2.sort().join(",") : t2;
        }
        xn(xu, gn);
        function Pu(t2) {
          return !!t2.is("element") && !!t2.getCustomProperty("widget");
        }
        function Su(t2, e2, n2 = {}) {
          return e2.setAttribute("contenteditable", "false", t2), e2.addClass("ck-widget", t2), e2.setCustomProperty("widget", true, t2), t2.getFillerOffset = Nu, n2.label && function(t3, e3, n3) {
            n3.setCustomProperty("widgetLabel", e3, t3);
          }(t2, n2.label, e2), n2.hasSelectionHandle && function(t3, e3) {
            const n3 = e3.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(t4) {
              const e4 = this.toDomElement(t4), n4 = new El();
              return n4.set("content", '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'), n4.render(), e4.appendChild(n4.element), e4;
            });
            e3.insert(e3.createPositionAt(t3, 0), n3), e3.addClass(["ck-widget_with-selection-handle"], t3);
          }(t2, e2), function(t3, e3, n3, i3) {
            const o2 = new xu();
            o2.on("change:top", (e4, o3) => {
              o3.oldDescriptor && i3(t3, o3.oldDescriptor, o3.writer), o3.newDescriptor && n3(t3, o3.newDescriptor, o3.writer);
            }), e3.setCustomProperty("addHighlight", (t4, e4, n4) => o2.add(e4, n4), t3), e3.setCustomProperty("removeHighlight", (t4, e4, n4) => o2.remove(e4, n4), t3);
          }(t2, e2, (t3, e3, n3) => n3.addClass(i2(e3.classes), t3), (t3, e3, n3) => n3.removeClass(i2(e3.classes), t3)), t2;
          function i2(t3) {
            return Array.isArray(t3) ? t3 : [t3];
          }
        }
        function Mu(t2) {
          const e2 = t2.getCustomProperty("widgetLabel");
          return e2 ? "function" == typeof e2 ? e2() : e2 : "";
        }
        function Eu(t2, e2) {
          return e2.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t2), e2.setAttribute("contenteditable", t2.isReadOnly ? "false" : "true", t2), t2.on("change:isReadOnly", (n2, i2, o2) => {
            e2.setAttribute("contenteditable", o2 ? "false" : "true", t2);
          }), t2.on("change:isFocused", (n2, i2, o2) => {
            o2 ? e2.addClass("ck-editor__nested-editable_focused", t2) : e2.removeClass("ck-editor__nested-editable_focused", t2);
          }), t2;
        }
        function Iu(t2, e2) {
          const n2 = t2.getSelectedElement();
          if (n2 && e2.schema.isBlock(n2))
            return e2.createPositionAfter(n2);
          const i2 = t2.getSelectedBlocks().next().value;
          if (i2) {
            if (i2.isEmpty)
              return e2.createPositionAt(i2, 0);
            const n3 = e2.createPositionAfter(i2);
            return t2.focus.isTouching(n3) ? n3 : e2.createPositionBefore(i2);
          }
          return t2.focus;
        }
        function Nu() {
          return null;
        }
        function Ou(t2) {
          const e2 = t2.getSelectedElement();
          return e2 && function(t3) {
            return !!t3.getCustomProperty("image") && Pu(t3);
          }(e2) ? e2 : null;
        }
        function Ru(t2) {
          return !!t2 && t2.is("image");
        }
        function Du(t2, e2, n2 = {}) {
          const i2 = t2.createElement("image", n2), o2 = Iu(e2.document.selection, e2);
          e2.insertContent(i2, o2), i2.parent && t2.setSelection(i2, "on");
        }
        function Lu(t2) {
          const e2 = t2.schema, n2 = t2.document.selection;
          return function(t3, e3, n3) {
            const i2 = function(t4, e4) {
              const n4 = Iu(t4, e4).parent;
              if (n4.isEmpty && !n4.is("$root"))
                return n4.parent;
              return n4;
            }(t3, n3);
            return e3.checkChild(i2, "image");
          }(n2, e2, t2) && !function(t3, e3) {
            const n3 = t3.getSelectedElement();
            return n3 && e3.isObject(n3);
          }(n2, e2) && function(t3) {
            return [...t3.focus.getAncestors()].every((t4) => !t4.is("image"));
          }(n2);
        }
        function ju(t2) {
          return Array.from(t2.getChildren()).find((t3) => t3.is("img"));
        }
        function Vu(t2) {
          return (n2) => {
            n2.on(`attribute:${t2}:image`, e2);
          };
          function e2(t3, e3, n2) {
            if (!n2.consumable.consume(e3.item, t3.name))
              return;
            const i2 = n2.writer, o2 = ju(n2.mapper.toViewElement(e3.item));
            null !== e3.attributeNewValue ? i2.setAttribute(e3.attributeKey, e3.attributeNewValue, o2) : i2.removeAttribute(e3.attributeKey, o2);
          }
        }
        class zu extends td {
          refresh() {
            this.isEnabled = Lu(this.editor.model);
          }
          execute(t2) {
            const e2 = this.editor.model;
            e2.change((n2) => {
              const i2 = Array.isArray(t2.source) ? t2.source : [t2.source];
              for (const t3 of i2)
                Du(n2, e2, { src: t3 });
            });
          }
        }
        class Bu extends $l {
          static get pluginName() {
            return "ImageEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.model.schema, n2 = t2.t, i2 = t2.conversion;
            t2.editing.view.addObserver(yu), e2.register("image", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["alt", "src", "srcset"] }), i2.for("dataDowncast").elementToElement({ model: "image", view: (t3, e3) => Fu(e3) }), i2.for("editingDowncast").elementToElement({ model: "image", view: (t3, e3) => {
              return i3 = Fu(e3), o2 = e3, r2 = n2("image widget"), o2.setCustomProperty("image", true, i3), Su(i3, o2, { label: function() {
                const t4 = ju(i3).getAttribute("alt");
                return t4 ? `${t4} ${r2}` : r2;
              } });
              var i3, o2, r2;
            } }), i2.for("downcast").add(Vu("src")).add(Vu("alt")).add(function() {
              return (e3) => {
                e3.on("attribute:srcset:image", t3);
              };
              function t3(t4, e3, n3) {
                if (!n3.consumable.consume(e3.item, t4.name))
                  return;
                const i3 = n3.writer, o2 = ju(n3.mapper.toViewElement(e3.item));
                if (null === e3.attributeNewValue) {
                  const t5 = e3.attributeOldValue;
                  t5.data && (i3.removeAttribute("srcset", o2), i3.removeAttribute("sizes", o2), t5.width && i3.removeAttribute("width", o2));
                } else {
                  const t5 = e3.attributeNewValue;
                  t5.data && (i3.setAttribute("srcset", t5.data, o2), i3.setAttribute("sizes", "100vw", o2), t5.width && i3.setAttribute("width", t5.width, o2));
                }
              }
            }()), i2.for("upcast").elementToElement({ view: { name: "img", attributes: { src: true } }, model: (t3, e3) => e3.createElement("image", { src: t3.getAttribute("src") }) }).attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (t3) => {
              const e3 = { data: t3.getAttribute("srcset") };
              return t3.hasAttribute("width") && (e3.width = t3.getAttribute("width")), e3;
            } } }).add(function() {
              return (e3) => {
                e3.on("element:figure", t3);
              };
              function t3(t4, e3, n3) {
                if (!n3.consumable.test(e3.viewItem, { name: true, classes: "image" }))
                  return;
                const i3 = ju(e3.viewItem);
                if (!i3 || !i3.hasAttribute("src") || !n3.consumable.test(i3, { name: true }))
                  return;
                const o2 = n3.convertItem(i3, e3.modelCursor), r2 = mu(o2.modelRange.getItems());
                r2 && (n3.convertChildren(e3.viewItem, n3.writer.createPositionAt(r2, 0)), e3.modelRange = o2.modelRange, e3.modelCursor = o2.modelCursor);
              }
            }()), t2.commands.add("imageInsert", new zu(t2));
          }
        }
        function Fu(t2) {
          const e2 = t2.createEmptyElement("img"), n2 = t2.createContainerElement("figure", { class: "image" });
          return t2.insert(t2.createPositionAt(n2, 0), e2), n2;
        }
        function Uu(t2, e2, n2) {
          return n2.createRange(Hu(t2, e2, true, n2), Hu(t2, e2, false, n2));
        }
        function Hu(t2, e2, n2, i2) {
          let o2 = t2.textNode || (n2 ? t2.nodeBefore : t2.nodeAfter), r2 = null;
          for (; o2 && o2.getAttribute("linkHref") == e2; )
            r2 = o2, o2 = n2 ? o2.previousSibling : o2.nextSibling;
          return r2 ? i2.createPositionAt(r2, n2 ? "before" : "after") : t2;
        }
        class qu extends td {
          constructor(t2) {
            super(t2), this.manualDecorators = new An();
          }
          restoreManualDecoratorStates() {
            for (const t2 of this.manualDecorators)
              t2.value = this._getDecoratorStateFromModel(t2.id);
          }
          refresh() {
            const t2 = this.editor.model, e2 = t2.document;
            this.value = e2.selection.getAttribute("linkHref");
            for (const t3 of this.manualDecorators)
              t3.value = this._getDecoratorStateFromModel(t3.id);
            this.isEnabled = t2.schema.checkAttributeInSelection(e2.selection, "linkHref");
          }
          execute(t2, e2 = {}) {
            const n2 = this.editor.model, i2 = n2.document.selection, o2 = [], r2 = [];
            for (const t3 in e2)
              e2[t3] ? o2.push(t3) : r2.push(t3);
            n2.change((e3) => {
              if (i2.isCollapsed) {
                const s2 = i2.getFirstPosition();
                if (i2.hasAttribute("linkHref")) {
                  const a2 = Uu(s2, i2.getAttribute("linkHref"), n2);
                  e3.setAttribute("linkHref", t2, a2), o2.forEach((t3) => {
                    e3.setAttribute(t3, true, a2);
                  }), r2.forEach((t3) => {
                    e3.removeAttribute(t3, a2);
                  }), e3.setSelection(a2);
                } else if ("" !== t2) {
                  const r3 = Ln(i2.getAttributes());
                  r3.set("linkHref", t2), o2.forEach((t3) => {
                    r3.set(t3, true);
                  });
                  const a2 = e3.createText(t2, r3);
                  n2.insertContent(a2, s2), e3.setSelection(e3.createRangeOn(a2));
                }
              } else {
                const s2 = n2.schema.getValidRanges(i2.getRanges(), "linkHref");
                for (const n3 of s2)
                  e3.setAttribute("linkHref", t2, n3), o2.forEach((t3) => {
                    e3.setAttribute(t3, true, n3);
                  }), r2.forEach((t3) => {
                    e3.removeAttribute(t3, n3);
                  });
              }
            });
          }
          _getDecoratorStateFromModel(t2) {
            return this.editor.model.document.selection.getAttribute(t2);
          }
        }
        class Wu extends td {
          refresh() {
            this.isEnabled = this.editor.model.document.selection.hasAttribute("linkHref");
          }
          execute() {
            const t2 = this.editor, e2 = this.editor.model, n2 = e2.document.selection, i2 = t2.commands.get("link");
            e2.change((t3) => {
              const o2 = n2.isCollapsed ? [Uu(n2.getFirstPosition(), n2.getAttribute("linkHref"), e2)] : n2.getRanges();
              for (const e3 of o2)
                if (t3.removeAttribute("linkHref", e3), i2)
                  for (const n3 of i2.manualDecorators)
                    t3.removeAttribute(n3.id, e3);
            });
          }
        }
        var Yu = function(t2, e2, n2) {
          var i2 = t2.length;
          return n2 = void 0 === n2 ? i2 : n2, !e2 && n2 >= i2 ? t2 : ii(t2, e2, n2);
        }, Gu = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
        var $u = function(t2) {
          return Gu.test(t2);
        };
        var Qu = function(t2) {
          return t2.split("");
        }, Ku = "[\\ud800-\\udfff]", Ju = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", Zu = "\\ud83c[\\udffb-\\udfff]", Xu = "[^\\ud800-\\udfff]", th = "(?:\\ud83c[\\udde6-\\uddff]){2}", eh = "[\\ud800-\\udbff][\\udc00-\\udfff]", nh = "(?:" + Ju + "|" + Zu + ")?", ih = "[\\ufe0e\\ufe0f]?" + nh + ("(?:\\u200d(?:" + [Xu, th, eh].join("|") + ")[\\ufe0e\\ufe0f]?" + nh + ")*"), oh = "(?:" + [Xu + Ju + "?", Ju, th, eh, Ku].join("|") + ")", rh = RegExp(Zu + "(?=" + Zu + ")|" + oh + ih, "g");
        var sh = function(t2) {
          return t2.match(rh) || [];
        };
        var ah = function(t2) {
          return $u(t2) ? sh(t2) : Qu(t2);
        };
        var ch = function(t2) {
          return function(e2) {
            e2 = Zn(e2);
            var n2 = $u(e2) ? ah(e2) : void 0, i2 = n2 ? n2[0] : e2.charAt(0), o2 = n2 ? Yu(n2, 1).join("") : e2.slice(1);
            return i2[t2]() + o2;
          };
        }("toUpperCase");
        const lh = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, dh = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        function uh(t2, e2) {
          const n2 = e2.createAttributeElement("a", { href: t2 }, { priority: 5 });
          return e2.setCustomProperty("link", true, n2), n2;
        }
        function hh(t2) {
          return function(t3) {
            return t3.replace(lh, "").match(dh);
          }(t2 = String(t2)) ? t2 : "#";
        }
        class fh {
          constructor() {
            this._definitions = /* @__PURE__ */ new Set();
          }
          get length() {
            return this._definitions.size;
          }
          add(t2) {
            Array.isArray(t2) ? t2.forEach((t3) => this._definitions.add(t3)) : this._definitions.add(t2);
          }
          getDispatcher() {
            return (t2) => {
              t2.on("attribute:linkHref", (t3, e2, n2) => {
                if (!n2.consumable.test(e2.item, "attribute:linkHref"))
                  return;
                const i2 = n2.writer, o2 = i2.document.selection;
                for (const t4 of this._definitions) {
                  const r2 = i2.createAttributeElement("a", t4.attributes, { priority: 5 });
                  i2.setCustomProperty("link", true, r2), t4.callback(e2.attributeNewValue) ? e2.item.is("selection") ? i2.wrap(o2.getFirstRange(), r2) : i2.wrap(n2.mapper.toViewRange(e2.range), r2) : i2.unwrap(n2.mapper.toViewRange(e2.range), r2);
                }
              }, { priority: "high" });
            };
          }
        }
        class mh {
          constructor({ id: t2, label: e2, attributes: n2, defaultValue: i2 }) {
            this.id = t2, this.set("value"), this.defaultValue = i2, this.label = e2, this.attributes = n2;
          }
        }
        xn(mh, Ui);
        class gh {
          constructor(t2, e2, n2) {
            this.model = t2, this.attribute = n2, this._modelSelection = t2.document.selection, this._overrideUid = null, this._isNextGravityRestorationSkipped = false, e2.listenTo(this._modelSelection, "change:range", (t3, e3) => {
              this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = false : this._isGravityOverridden && (!e3.directChange && ph(this._modelSelection.getFirstPosition(), n2) || this._restoreGravity());
            });
          }
          handleForwardMovement(t2, e2) {
            const n2 = this.attribute;
            if (!(this._isGravityOverridden || t2.isAtStart && this._hasSelectionAttribute))
              return kh(t2, n2) && this._hasSelectionAttribute ? (this._preventCaretMovement(e2), this._removeSelectionAttribute(), true) : bh(t2, n2) || wh(t2, n2) && this._hasSelectionAttribute ? (this._preventCaretMovement(e2), this._overrideGravity(), true) : void 0;
          }
          handleBackwardMovement(t2, e2) {
            const n2 = this.attribute;
            return this._isGravityOverridden ? kh(t2, n2) && this._hasSelectionAttribute ? (this._preventCaretMovement(e2), this._restoreGravity(), this._removeSelectionAttribute(), true) : (this._preventCaretMovement(e2), this._restoreGravity(), t2.isAtStart && this._removeSelectionAttribute(), true) : kh(t2, n2) && !this._hasSelectionAttribute ? (this._preventCaretMovement(e2), this._setSelectionAttributeFromTheNodeBefore(t2), true) : t2.isAtEnd && wh(t2, n2) ? this._hasSelectionAttribute ? void (_h(t2, n2) && (this._skipNextAutomaticGravityRestoration(), this._overrideGravity())) : (this._preventCaretMovement(e2), this._setSelectionAttributeFromTheNodeBefore(t2), true) : t2.isAtStart ? this._hasSelectionAttribute ? (this._removeSelectionAttribute(), this._preventCaretMovement(e2), true) : void 0 : void (_h(t2, n2) && (this._skipNextAutomaticGravityRestoration(), this._overrideGravity()));
          }
          get _isGravityOverridden() {
            return !!this._overrideUid;
          }
          get _hasSelectionAttribute() {
            return this._modelSelection.hasAttribute(this.attribute);
          }
          _overrideGravity() {
            this._overrideUid = this.model.change((t2) => t2.overrideSelectionGravity());
          }
          _restoreGravity() {
            this.model.change((t2) => {
              t2.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
            });
          }
          _preventCaretMovement(t2) {
            t2.preventDefault();
          }
          _removeSelectionAttribute() {
            this.model.change((t2) => {
              t2.removeSelectionAttribute(this.attribute);
            });
          }
          _setSelectionAttributeFromTheNodeBefore(t2) {
            const e2 = this.attribute;
            this.model.change((n2) => {
              n2.setSelectionAttribute(this.attribute, t2.nodeBefore.getAttribute(e2));
            });
          }
          _skipNextAutomaticGravityRestoration() {
            this._isNextGravityRestorationSkipped = true;
          }
        }
        function ph(t2, e2) {
          return bh(t2, e2) || wh(t2, e2);
        }
        function bh(t2, e2) {
          const { nodeBefore: n2, nodeAfter: i2 } = t2, o2 = !!n2 && n2.hasAttribute(e2);
          return !!i2 && i2.hasAttribute(e2) && (!o2 || n2.getAttribute(e2) !== i2.getAttribute(e2));
        }
        function wh(t2, e2) {
          const { nodeBefore: n2, nodeAfter: i2 } = t2, o2 = !!n2 && n2.hasAttribute(e2), r2 = !!i2 && i2.hasAttribute(e2);
          return o2 && (!r2 || n2.getAttribute(e2) !== i2.getAttribute(e2));
        }
        function kh(t2, e2) {
          const { nodeBefore: n2, nodeAfter: i2 } = t2, o2 = !!n2 && n2.hasAttribute(e2);
          if (!!i2 && i2.hasAttribute(e2) && o2)
            return i2.getAttribute(e2) !== n2.getAttribute(e2);
        }
        function _h(t2, e2) {
          return ph(t2.getShiftedBy(-1), e2);
        }
        n(45);
        const vh = /^(https?:)?\/\//;
        class yh extends $l {
          static get pluginName() {
            return "LinkEditing";
          }
          constructor(t2) {
            super(t2), t2.config.define("link", { addTargetToExternalLinks: false });
          }
          init() {
            const t2 = this.editor, e2 = t2.locale;
            t2.model.schema.extend("$text", { allowAttributes: "linkHref" }), t2.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: uh }), t2.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t3, e3) => uh(hh(t3), e3) }), t2.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: (t3) => t3.getAttribute("href") } }), t2.commands.add("link", new qu(t2)), t2.commands.add("unlink", new Wu(t2));
            const n2 = function(t3, e3) {
              const n3 = { "Open in a new tab": t3("Open in a new tab"), Downloadable: t3("Downloadable") };
              return e3.forEach((t4) => (t4.label && n3[t4.label] && (t4.label = n3[t4.label]), t4)), e3;
            }(t2.t, function(t3) {
              const e3 = [];
              if (t3)
                for (const [n3, i2] of Object.entries(t3)) {
                  const t4 = Object.assign({}, i2, { id: "link" + ch(n3) });
                  e3.push(t4);
                }
              return e3;
            }(t2.config.get("link.decorators")));
            this._enableAutomaticDecorators(n2.filter((t3) => "automatic" === t3.mode)), this._enableManualDecorators(n2.filter((t3) => "manual" === t3.mode)), function({ view: t3, model: e3, emitter: n3, attribute: i2, locale: o2 }) {
              const r2 = new gh(e3, n3, i2), s2 = e3.document.selection;
              n3.listenTo(t3.document, "keydown", (t4, e4) => {
                if (!s2.isCollapsed)
                  return;
                if (e4.shiftKey || e4.altKey || e4.ctrlKey)
                  return;
                const n4 = e4.keyCode == go.arrowright, i3 = e4.keyCode == go.arrowleft;
                if (!n4 && !i3)
                  return;
                const a2 = s2.getFirstPosition(), c2 = o2.contentLanguageDirection;
                let l2;
                l2 = "ltr" === c2 && n4 || "rtl" === c2 && i3 ? r2.handleForwardMovement(a2, e4) : r2.handleBackwardMovement(a2, e4), l2 && t4.stop();
              }, { priority: un.get("high") + 1 });
            }({ view: t2.editing.view, model: t2.model, emitter: this, attribute: "linkHref", locale: e2 }), this._setupLinkHighlight(), this._enableInsertContentSelectionAttributesFixer();
          }
          _enableAutomaticDecorators(t2) {
            const e2 = this.editor, n2 = new fh();
            e2.config.get("link.addTargetToExternalLinks") && n2.add({ id: "linkIsExternal", mode: "automatic", callback: (t3) => vh.test(t3), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n2.add(t2), n2.length && e2.conversion.for("downcast").add(n2.getDispatcher());
          }
          _enableManualDecorators(t2) {
            if (!t2.length)
              return;
            const e2 = this.editor, n2 = e2.commands.get("link").manualDecorators;
            t2.forEach((t3) => {
              e2.model.schema.extend("$text", { allowAttributes: t3.id }), n2.add(new mh(t3)), e2.conversion.for("downcast").attributeToElement({ model: t3.id, view: (e3, i2) => {
                if (e3) {
                  const e4 = n2.get(t3.id).attributes, o2 = i2.createAttributeElement("a", e4, { priority: 5 });
                  return i2.setCustomProperty("link", true, o2), o2;
                }
              } }), e2.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: n2.get(t3.id).attributes }, model: { key: t3.id } });
            });
          }
          _setupLinkHighlight() {
            const t2 = this.editor, e2 = t2.editing.view, n2 = /* @__PURE__ */ new Set();
            e2.document.registerPostFixer((e3) => {
              const i2 = t2.model.document.selection;
              let o2 = false;
              if (i2.hasAttribute("linkHref")) {
                const r2 = Uu(i2.getFirstPosition(), i2.getAttribute("linkHref"), t2.model), s2 = t2.editing.mapper.toViewRange(r2);
                for (const t3 of s2.getItems())
                  t3.is("a") && !t3.hasClass("ck-link_selected") && (e3.addClass("ck-link_selected", t3), n2.add(t3), o2 = true);
              }
              return o2;
            }), t2.conversion.for("editingDowncast").add((t3) => {
              function i2() {
                e2.change((t4) => {
                  for (const e3 of n2.values())
                    t4.removeClass("ck-link_selected", e3), n2.delete(e3);
                });
              }
              t3.on("insert", i2, { priority: "highest" }), t3.on("remove", i2, { priority: "highest" }), t3.on("attribute", i2, { priority: "highest" }), t3.on("selection", i2, { priority: "highest" });
            });
          }
          _enableInsertContentSelectionAttributesFixer() {
            const t2 = this.editor.model, e2 = t2.document.selection;
            t2.on("insertContent", () => {
              const n2 = e2.anchor.nodeBefore, i2 = e2.anchor.nodeAfter;
              e2.hasAttribute("linkHref") && n2 && n2.hasAttribute("linkHref") && (i2 && i2.hasAttribute("linkHref") || t2.change((e3) => {
                [...t2.document.selection.getAttributeKeys()].filter((t3) => t3.startsWith("link")).forEach((t3) => e3.removeSelectionAttribute(t3));
              }));
            }, { priority: "low" });
          }
        }
        class xh extends Kd {
          static get pluginName() {
            return "Notification";
          }
          init() {
            this.on("show:warning", (t2, e2) => {
              window.alert(e2.message);
            }, { priority: "lowest" });
          }
          showSuccess(t2, e2 = {}) {
            this._showNotification({ message: t2, type: "success", namespace: e2.namespace, title: e2.title });
          }
          showInfo(t2, e2 = {}) {
            this._showNotification({ message: t2, type: "info", namespace: e2.namespace, title: e2.title });
          }
          showWarning(t2, e2 = {}) {
            this._showNotification({ message: t2, type: "warning", namespace: e2.namespace, title: e2.title });
          }
          _showNotification(t2) {
            const e2 = "show:" + t2.type + (t2.namespace ? ":" + t2.namespace : "");
            this.fire(e2, { message: t2.message, type: t2.type, title: t2.title || "" });
          }
        }
        class Ah extends td {
          constructor(t2) {
            super(t2), this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", () => this.refresh(), { priority: "low" });
          }
          refresh() {
            const t2 = this.editor.commands.get("imageInsert"), e2 = this.editor.commands.get("link");
            this.isEnabled = t2.isEnabled || e2.isEnabled;
          }
          execute() {
            const t2 = this.editor, e2 = this.editor.config.get("ckfinder.openerMethod") || "modal";
            if ("popup" != e2 && "modal" != e2)
              throw new hn.b('ckfinder-unknown-openerMethod: The openerMethod config option must by "popup" or "modal".', t2);
            const n2 = this.editor.config.get("ckfinder.options") || {};
            n2.chooseFiles = true;
            const i2 = n2.onInit;
            n2.language || (n2.language = t2.locale.uiLanguage), n2.onInit = (e3) => {
              i2 && i2(e3), e3.on("files:choose", (n3) => {
                const i3 = n3.data.files.toArray(), o2 = i3.filter((t3) => !t3.isImage()), r2 = i3.filter((t3) => t3.isImage());
                for (const e4 of o2)
                  t2.execute("link", e4.getUrl());
                const s2 = [];
                for (const t3 of r2) {
                  const n4 = t3.getUrl();
                  s2.push(n4 || e3.request("file:getProxyUrl", { file: t3 }));
                }
                s2.length && Th(t2, s2);
              }), e3.on("file:choose:resizedImage", (e4) => {
                const n3 = e4.data.resizedUrl;
                if (n3)
                  Th(t2, [n3]);
                else {
                  const e5 = t2.plugins.get("Notification"), n4 = t2.locale.t;
                  e5.showWarning(n4("Could not obtain resized image URL."), { title: n4("Selecting resized image failed"), namespace: "ckfinder" });
                }
              });
            }, window.CKFinder[e2](n2);
          }
        }
        function Th(t2, e2) {
          if (t2.commands.get("imageInsert").isEnabled)
            t2.execute("imageInsert", { source: e2 });
          else {
            const e3 = t2.plugins.get("Notification"), n2 = t2.locale.t;
            e3.showWarning(n2("Could not insert image at the current position."), { title: n2("Inserting image failed"), namespace: "ckfinder" });
          }
        }
        class Ch extends $l {
          static get pluginName() {
            return "CKFinderEditing";
          }
          static get requires() {
            return [xh, Bu, yh];
          }
          init() {
            const t2 = this.editor;
            t2.commands.add("ckfinder", new Ah(t2));
          }
        }
        const Ph = /^data:(\S*?);base64,/;
        class Sh {
          constructor(t2, e2, n2) {
            if (!t2)
              throw new hn.b("fileuploader-missing-file: File must be provided as the first argument", null);
            if (!e2)
              throw new hn.b("fileuploader-missing-token: Token must be provided as the second argument.", null);
            if (!n2)
              throw new hn.b("fileuploader-missing-api-address: Api address must be provided as the third argument.", null);
            this.file = function(t3) {
              if ("string" != typeof t3)
                return false;
              const e3 = t3.match(Ph);
              return !(!e3 || !e3.length);
            }(t2) ? function(t3, e3 = 512) {
              try {
                const n3 = t3.match(Ph)[1], i2 = atob(t3.replace(Ph, "")), o2 = [];
                for (let t4 = 0; t4 < i2.length; t4 += e3) {
                  const n4 = i2.slice(t4, t4 + e3), r2 = new Array(n4.length);
                  for (let t5 = 0; t5 < n4.length; t5++)
                    r2[t5] = n4.charCodeAt(t5);
                  o2.push(new Uint8Array(r2));
                }
                return new Blob(o2, { type: n3 });
              } catch (t4) {
                throw new hn.b("fileuploader-decoding-image-data-error: Problem with decoding Base64 image data.", null);
              }
            }(t2) : t2, this._token = e2, this._apiAddress = n2;
          }
          onProgress(t2) {
            return this.on("progress", (e2, n2) => t2(n2)), this;
          }
          onError(t2) {
            return this.once("error", (e2, n2) => t2(n2)), this;
          }
          abort() {
            this.xhr.abort();
          }
          send() {
            return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
          }
          _prepareRequest() {
            const t2 = new XMLHttpRequest();
            t2.open("POST", this._apiAddress), t2.setRequestHeader("Authorization", this._token.value), t2.responseType = "json", this.xhr = t2;
          }
          _attachXHRListeners() {
            const t2 = this, e2 = this.xhr;
            function n2(e3) {
              return () => t2.fire("error", e3);
            }
            e2.addEventListener("error", n2("Network Error")), e2.addEventListener("abort", n2("Abort")), e2.upload && e2.upload.addEventListener("progress", (t3) => {
              t3.lengthComputable && this.fire("progress", { total: t3.total, uploaded: t3.loaded });
            }), e2.addEventListener("load", () => {
              const t3 = e2.status, n3 = e2.response;
              if (t3 < 200 || t3 > 299)
                return this.fire("error", n3.message || n3.error);
            });
          }
          _sendRequest() {
            const t2 = new FormData(), e2 = this.xhr;
            return t2.append("file", this.file), new Promise((n2, i2) => {
              e2.addEventListener("load", () => {
                const t3 = e2.status, o2 = e2.response;
                return t3 < 200 || t3 > 299 ? o2.message ? i2(new hn.b("fileuploader-uploading-data-failed: Uploading file failed.", this, { message: o2.message })) : i2(o2.error) : n2(o2);
              }), e2.addEventListener("error", () => i2(new Error("Network Error"))), e2.addEventListener("abort", () => i2(new Error("Abort"))), e2.send(t2);
            });
          }
        }
        xn(Sh, gn);
        const Mh = { refreshInterval: 36e5, autoRefresh: true };
        class Eh {
          constructor(t2, e2 = Mh) {
            if (!t2)
              throw new hn.b("token-missing-token-url: A `tokenUrl` must be provided as the first constructor argument.", this);
            this.set("value", e2.initValue), this._refresh = "function" == typeof t2 ? t2 : () => {
              return e3 = t2, new Promise((t3, n2) => {
                const i2 = new XMLHttpRequest();
                i2.open("GET", e3), i2.addEventListener("load", () => {
                  const e4 = i2.status, o2 = i2.response;
                  return e4 < 200 || e4 > 299 ? n2(new hn.b("token-cannot-download-new-token: Cannot download new token from the provided url.", null)) : t3(o2);
                }), i2.addEventListener("error", () => n2(new Error("Network Error"))), i2.addEventListener("abort", () => n2(new Error("Abort"))), i2.send();
              });
              var e3;
            }, this._options = Object.assign({}, Mh, e2);
          }
          init() {
            return new Promise((t2, e2) => {
              this._options.autoRefresh && this._startRefreshing(), this.value ? t2(this) : this.refreshToken().then(t2).catch(e2);
            });
          }
          refreshToken() {
            return this._refresh().then((t2) => this.set("value", t2)).then(() => this);
          }
          destroy() {
            this._stopRefreshing();
          }
          _startRefreshing() {
            this._refreshInterval = setInterval(() => this.refreshToken(), this._options.refreshInterval);
          }
          _stopRefreshing() {
            clearInterval(this._refreshInterval);
          }
          static create(t2, e2 = Mh) {
            return new Eh(t2, e2).init();
          }
        }
        xn(Eh, Ui);
        var Ih = Eh;
        class Nh extends Kd {
          static get pluginName() {
            return "CloudServices";
          }
          init() {
            const t2 = this.context.config.get("cloudServices") || {};
            for (const e2 in t2)
              this[e2] = t2[e2];
            if (this.tokenUrl)
              return this.token = new Nh.Token(this.tokenUrl), this.token.init();
            this.token = null;
          }
        }
        Nh.Token = Ih;
        class Oh extends $l {
          static get requires() {
            return [Xd, Nh];
          }
          init() {
            const t2 = this.editor, e2 = t2.plugins.get(Nh), n2 = e2.token, i2 = e2.uploadUrl;
            n2 && (this._uploadGateway = new Oh._UploadGateway(n2, i2), t2.plugins.get(Xd).createUploadAdapter = (t3) => new Rh(this._uploadGateway, t3));
          }
        }
        class Rh {
          constructor(t2, e2) {
            this.uploadGateway = t2, this.loader = e2;
          }
          upload() {
            return this.loader.file.then((t2) => (this.fileUploader = this.uploadGateway.upload(t2), this.fileUploader.on("progress", (t3, e2) => {
              this.loader.uploadTotal = e2.total, this.loader.uploaded = e2.uploaded;
            }), this.fileUploader.send()));
          }
          abort() {
            this.fileUploader.abort();
          }
        }
        Oh._UploadGateway = class {
          constructor(t2, e2) {
            if (!t2)
              throw new hn.b("uploadgateway-missing-token: Token must be provided.", null);
            if (!e2)
              throw new hn.b("uploadgateway-missing-api-address: Api address must be provided.", null);
            this._token = t2, this._apiAddress = e2;
          }
          upload(t2) {
            return new Sh(t2, this._token, this._apiAddress);
          }
        };
        class Dh extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = "mousedown";
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        n(47);
        class Lh extends $l {
          static get pluginName() {
            return "Widget";
          }
          init() {
            const t2 = this.editor.editing.view, e2 = t2.document;
            this._previouslySelected = /* @__PURE__ */ new Set(), this.editor.editing.downcastDispatcher.on("selection", (t3, e3, n2) => {
              this._clearPreviouslySelectedWidgets(n2.writer);
              const i2 = n2.writer, o2 = i2.document.selection, r2 = o2.getSelectedElement();
              let s2 = null;
              for (const t4 of o2.getRanges())
                for (const e4 of t4) {
                  const t5 = e4.item;
                  Pu(t5) && !jh(t5, s2) && (i2.addClass("ck-widget_selected", t5), this._previouslySelected.add(t5), s2 = t5, t5 == r2 && i2.setSelection(o2.getRanges(), { fake: true, label: Mu(r2) }));
                }
            }, { priority: "low" }), t2.addObserver(Dh), this.listenTo(e2, "mousedown", (...t3) => this._onMousedown(...t3)), this.listenTo(e2, "keydown", (...t3) => this._onKeydown(...t3), { priority: "high" }), this.listenTo(e2, "delete", (t3, e3) => {
              this._handleDelete("forward" == e3.direction) && (e3.preventDefault(), t3.stop());
            }, { priority: "high" });
          }
          _onMousedown(t2, e2) {
            const n2 = this.editor, i2 = n2.editing.view, o2 = i2.document;
            let r2 = e2.target;
            if (function(t3) {
              for (; t3; ) {
                if (t3.is("editableElement") && !t3.is("rootElement"))
                  return true;
                if (Pu(t3))
                  return false;
                t3 = t3.parent;
              }
              return false;
            }(r2)) {
              if (ho.isSafari && e2.domEvent.detail >= 3) {
                const t3 = n2.editing.mapper.toModelElement(r2);
                this.editor.model.change((n3) => {
                  e2.preventDefault(), n3.setSelection(t3, "in");
                });
              }
              return;
            }
            if (!Pu(r2) && (r2 = r2.findAncestor(Pu), !r2))
              return;
            e2.preventDefault(), o2.isFocused || i2.focus();
            const s2 = n2.editing.mapper.toModelElement(r2);
            this._setSelectionOverElement(s2);
          }
          _onKeydown(t2, e2) {
            const n2 = e2.keyCode, i2 = "ltr" === this.editor.locale.contentLanguageDirection, o2 = n2 == go.arrowdown || n2 == go[i2 ? "arrowright" : "arrowleft"];
            let r2 = false;
            !function(t3) {
              return t3 == go.arrowright || t3 == go.arrowleft || t3 == go.arrowup || t3 == go.arrowdown;
            }(n2) ? n2 === go.enter && (r2 = this._handleEnterKey(e2.shiftKey)) : r2 = this._handleArrowKeys(o2), r2 && (e2.preventDefault(), t2.stop());
          }
          _handleDelete(t2) {
            if (this.editor.isReadOnly)
              return;
            const e2 = this.editor.model.document.selection;
            if (!e2.isCollapsed)
              return;
            const n2 = this._getObjectElementNextToSelection(t2);
            return n2 ? (this.editor.model.change((t3) => {
              let i2 = e2.anchor.parent;
              for (; i2.isEmpty; ) {
                const e3 = i2;
                i2 = e3.parent, t3.remove(e3);
              }
              this._setSelectionOverElement(n2);
            }), true) : void 0;
          }
          _handleArrowKeys(t2) {
            const e2 = this.editor.model, n2 = e2.schema, i2 = e2.document.selection, o2 = i2.getSelectedElement();
            if (o2 && n2.isObject(o2)) {
              const o3 = t2 ? i2.getLastPosition() : i2.getFirstPosition(), r3 = n2.getNearestSelectionRange(o3, t2 ? "forward" : "backward");
              return r3 && e2.change((t3) => {
                t3.setSelection(r3);
              }), true;
            }
            if (!i2.isCollapsed)
              return;
            const r2 = this._getObjectElementNextToSelection(t2);
            return r2 && n2.isObject(r2) ? (this._setSelectionOverElement(r2), true) : void 0;
          }
          _handleEnterKey(t2) {
            const e2 = this.editor.model, n2 = e2.document.selection.getSelectedElement();
            if (i2 = n2, o2 = e2.schema, i2 && o2.isObject(i2) && !o2.isInline(i2))
              return e2.change((i3) => {
                let o3 = i3.createPositionAt(n2, t2 ? "before" : "after");
                const r2 = i3.createElement("paragraph");
                if (e2.schema.isBlock(n2.parent)) {
                  const t3 = e2.schema.findAllowedParent(o3, r2);
                  o3 = i3.split(o3, t3).position;
                }
                i3.insert(r2, o3), i3.setSelection(r2, "in");
              }), true;
            var i2, o2;
          }
          _setSelectionOverElement(t2) {
            this.editor.model.change((e2) => {
              e2.setSelection(e2.createRangeOn(t2));
            });
          }
          _getObjectElementNextToSelection(t2) {
            const e2 = this.editor.model, n2 = e2.schema, i2 = e2.document.selection, o2 = e2.createSelection(i2);
            e2.modifySelection(o2, { direction: t2 ? "forward" : "backward" });
            const r2 = t2 ? o2.focus.nodeBefore : o2.focus.nodeAfter;
            return r2 && n2.isObject(r2) ? r2 : null;
          }
          _clearPreviouslySelectedWidgets(t2) {
            for (const e2 of this._previouslySelected)
              t2.removeClass("ck-widget_selected", e2);
            this._previouslySelected.clear();
          }
        }
        function jh(t2, e2) {
          return !!e2 && Array.from(t2.getAncestors()).includes(e2);
        }
        class Vh extends td {
          refresh() {
            const t2 = this.editor.model.document.selection.getSelectedElement();
            this.isEnabled = Ru(t2), Ru(t2) && t2.hasAttribute("alt") ? this.value = t2.getAttribute("alt") : this.value = false;
          }
          execute(t2) {
            const e2 = this.editor.model, n2 = e2.document.selection.getSelectedElement();
            e2.change((e3) => {
              e3.setAttribute("alt", t2.newValue, n2);
            });
          }
        }
        class zh extends $l {
          static get pluginName() {
            return "ImageTextAlternativeEditing";
          }
          init() {
            this.editor.commands.add("imageTextAlternative", new Vh(this.editor));
          }
        }
        n(49);
        class Bh extends cl {
          constructor(t2, e2) {
            super(t2);
            const n2 = "ck-labeled-field-view-" + dn(), i2 = "ck-labeled-field-view-status-" + dn();
            this.fieldView = e2(this, n2, i2), this.set("label"), this.set("isEnabled", true), this.set("errorText", null), this.set("infoText", null), this.set("class"), this.labelView = this._createLabelView(n2), this.statusView = this._createStatusView(i2), this.bind("_statusText").to(this, "errorText", this, "infoText", (t3, e3) => t3 || e3);
            const o2 = this.bindTemplate;
            this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", o2.to("class"), o2.if("isEnabled", "ck-disabled", (t3) => !t3)] }, children: [this.labelView, this.fieldView, this.statusView] });
          }
          _createLabelView(t2) {
            const e2 = new hl(this.locale);
            return e2.for = t2, e2.bind("text").to(this, "label"), e2;
          }
          _createStatusView(t2) {
            const e2 = new cl(this.locale), n2 = this.bindTemplate;
            return e2.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n2.if("errorText", "ck-labeled-field-view__status_error"), n2.if("_statusText", "ck-hidden", (t3) => !t3)], id: t2, role: n2.if("errorText", "alert") }, children: [{ text: n2.to("_statusText") }] }), e2;
          }
          focus() {
            this.fieldView.focus();
          }
        }
        n(51);
        class Fh extends cl {
          constructor(t2) {
            super(t2), this.set("value"), this.set("id"), this.set("placeholder"), this.set("isReadOnly", false), this.set("hasError", false), this.set("ariaDescribedById");
            const e2 = this.bindTemplate;
            this.setTemplate({ tag: "input", attributes: { type: "text", class: ["ck", "ck-input", "ck-input-text", e2.if("hasError", "ck-error")], id: e2.to("id"), placeholder: e2.to("placeholder"), readonly: e2.to("isReadOnly"), "aria-invalid": e2.if("hasError", true), "aria-describedby": e2.to("ariaDescribedById") }, on: { input: e2.to("input") } });
          }
          render() {
            super.render();
            const t2 = (t3) => {
              this.element.value = t3 || 0 === t3 ? t3 : "";
            };
            t2(this.value), this.on("change:value", (e2, n2, i2) => {
              t2(i2);
            });
          }
          select() {
            this.element.select();
          }
          focus() {
            this.element.focus();
          }
        }
        function Uh(t2, e2, n2) {
          const i2 = new Fh(t2.locale);
          return i2.set({ id: e2, ariaDescribedById: n2 }), i2.bind("isReadOnly").to(t2, "isEnabled", (t3) => !t3), i2.bind("hasError").to(t2, "errorText", (t3) => !!t3), i2.on("input", () => {
            t2.errorText = null;
          }), i2;
        }
        function Hh({ view: t2 }) {
          t2.listenTo(t2.element, "submit", (e2, n2) => {
            n2.preventDefault(), t2.fire("submit");
          }, { useCapture: true });
        }
        var qh = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', Wh = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        n(53);
        class Yh extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.locale.t;
            this.focusTracker = new Oc(), this.keystrokes = new Ac(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(e2("Save"), qh, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(e2("Cancel"), Wh, "ck-button-cancel", "cancel"), this._focusables = new Uc(), this._focusCycler = new kl({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
          }
          render() {
            super.render(), this.keystrokes.listenTo(this.element), Hh({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t2) => {
              this._focusables.add(t2), this.focusTracker.add(t2.element);
            });
          }
          _createButton(t2, e2, n2, i2) {
            const o2 = new Nl(this.locale);
            return o2.set({ label: t2, icon: e2, tooltip: true }), o2.extendTemplate({ attributes: { class: n2 } }), i2 && o2.delegate("execute").to(this, i2), o2;
          }
          _createLabeledInputView() {
            const t2 = this.locale.t, e2 = new Bh(this.locale, Uh);
            return e2.label = t2("Text alternative"), e2.fieldView.placeholder = t2("Text alternative"), e2;
          }
        }
        n(55);
        const Gh = pl("px"), $h = Xo.document.body;
        class Qh extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", false), this.set("withArrow", true), this.set("class"), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e2.to("position", (t3) => "ck-balloon-panel_" + t3), e2.if("isVisible", "ck-balloon-panel_visible"), e2.if("withArrow", "ck-balloon-panel_with-arrow"), e2.to("class")], style: { top: e2.to("top", Gh), left: e2.to("left", Gh) } }, children: this.content });
          }
          show() {
            this.isVisible = true;
          }
          hide() {
            this.isVisible = false;
          }
          attachTo(t2) {
            this.show();
            const e2 = Qh.defaultPositions, n2 = Object.assign({}, { element: this.element, positions: [e2.southArrowNorth, e2.southArrowNorthMiddleWest, e2.southArrowNorthMiddleEast, e2.southArrowNorthWest, e2.southArrowNorthEast, e2.northArrowSouth, e2.northArrowSouthMiddleWest, e2.northArrowSouthMiddleEast, e2.northArrowSouthWest, e2.northArrowSouthEast], limiter: $h, fitInViewport: true }, t2), i2 = Qh._getOptimalPosition(n2), o2 = parseInt(i2.left), r2 = parseInt(i2.top), s2 = i2.name;
            Object.assign(this, { top: r2, left: o2, position: s2 });
          }
          pin(t2) {
            this.unpin(), this._pinWhenIsVisibleCallback = () => {
              this.isVisible ? this._startPinning(t2) : this._stopPinning();
            }, this._startPinning(t2), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
          }
          unpin() {
            this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
          }
          _startPinning(t2) {
            this.attachTo(t2);
            const e2 = Kh(t2.target), n2 = t2.limiter ? Kh(t2.limiter) : $h;
            this.listenTo(Xo.document, "scroll", (i2, o2) => {
              const r2 = o2.target, s2 = e2 && r2.contains(e2), a2 = n2 && r2.contains(n2);
              !s2 && !a2 && e2 && n2 || this.attachTo(t2);
            }, { useCapture: true }), this.listenTo(Xo.window, "resize", () => {
              this.attachTo(t2);
            });
          }
          _stopPinning() {
            this.stopListening(Xo.document, "scroll"), this.stopListening(Xo.window, "resize");
          }
        }
        function Kh(t2) {
          return nn(t2) ? t2 : Qr(t2) ? t2.commonAncestorContainer : "function" == typeof t2 ? Kh(t2()) : null;
        }
        function Jh(t2, e2) {
          return t2.top - e2.height - Qh.arrowVerticalOffset;
        }
        function Zh(t2) {
          return t2.bottom + Qh.arrowVerticalOffset;
        }
        Qh.arrowHorizontalOffset = 25, Qh.arrowVerticalOffset = 10, Qh._getOptimalPosition = Tl, Qh.defaultPositions = { northWestArrowSouthWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left - Qh.arrowHorizontalOffset, name: "arrow_sw" }), northWestArrowSouthMiddleWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_smw" }), northWestArrowSouth: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left - e2.width / 2, name: "arrow_s" }), northWestArrowSouthMiddleEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_sme" }), northWestArrowSouthEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left - e2.width + Qh.arrowHorizontalOffset, name: "arrow_se" }), northArrowSouthWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left + t2.width / 2 - Qh.arrowHorizontalOffset, name: "arrow_sw" }), northArrowSouthMiddleWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left + t2.width / 2 - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_smw" }), northArrowSouth: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left + t2.width / 2 - e2.width / 2, name: "arrow_s" }), northArrowSouthMiddleEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left + t2.width / 2 - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_sme" }), northArrowSouthEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.left + t2.width / 2 - e2.width + Qh.arrowHorizontalOffset, name: "arrow_se" }), northEastArrowSouthWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.right - Qh.arrowHorizontalOffset, name: "arrow_sw" }), northEastArrowSouthMiddleWest: (t2, e2) => ({ top: Jh(t2, e2), left: t2.right - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_smw" }), northEastArrowSouth: (t2, e2) => ({ top: Jh(t2, e2), left: t2.right - e2.width / 2, name: "arrow_s" }), northEastArrowSouthMiddleEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.right - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_sme" }), northEastArrowSouthEast: (t2, e2) => ({ top: Jh(t2, e2), left: t2.right - e2.width + Qh.arrowHorizontalOffset, name: "arrow_se" }), southWestArrowNorthWest: (t2, e2) => ({ top: Zh(t2), left: t2.left - Qh.arrowHorizontalOffset, name: "arrow_nw" }), southWestArrowNorthMiddleWest: (t2, e2) => ({ top: Zh(t2), left: t2.left - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_nmw" }), southWestArrowNorth: (t2, e2) => ({ top: Zh(t2), left: t2.left - e2.width / 2, name: "arrow_n" }), southWestArrowNorthMiddleEast: (t2, e2) => ({ top: Zh(t2), left: t2.left - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_nme" }), southWestArrowNorthEast: (t2, e2) => ({ top: Zh(t2), left: t2.left - e2.width + Qh.arrowHorizontalOffset, name: "arrow_ne" }), southArrowNorthWest: (t2, e2) => ({ top: Zh(t2), left: t2.left + t2.width / 2 - Qh.arrowHorizontalOffset, name: "arrow_nw" }), southArrowNorthMiddleWest: (t2, e2) => ({ top: Zh(t2), left: t2.left + t2.width / 2 - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_nmw" }), southArrowNorth: (t2, e2) => ({ top: Zh(t2), left: t2.left + t2.width / 2 - e2.width / 2, name: "arrow_n" }), southArrowNorthMiddleEast: (t2, e2) => ({ top: Zh(t2), left: t2.left + t2.width / 2 - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_nme" }), southArrowNorthEast: (t2, e2) => ({ top: Zh(t2), left: t2.left + t2.width / 2 - e2.width + Qh.arrowHorizontalOffset, name: "arrow_ne" }), southEastArrowNorthWest: (t2, e2) => ({ top: Zh(t2), left: t2.right - Qh.arrowHorizontalOffset, name: "arrow_nw" }), southEastArrowNorthMiddleWest: (t2, e2) => ({ top: Zh(t2), left: t2.right - 0.25 * e2.width - Qh.arrowHorizontalOffset, name: "arrow_nmw" }), southEastArrowNorth: (t2, e2) => ({ top: Zh(t2), left: t2.right - e2.width / 2, name: "arrow_n" }), southEastArrowNorthMiddleEast: (t2, e2) => ({ top: Zh(t2), left: t2.right - 0.75 * e2.width + Qh.arrowHorizontalOffset, name: "arrow_nme" }), southEastArrowNorthEast: (t2, e2) => ({ top: Zh(t2), left: t2.right - e2.width + Qh.arrowHorizontalOffset, name: "arrow_ne" }) };
        n(57), n(59);
        const Xh = pl("px");
        class tf extends $l {
          static get pluginName() {
            return "ContextualBalloon";
          }
          constructor(t2) {
            super(t2), this.positionLimiter = () => {
              const t3 = this.editor.editing.view, e2 = t3.document.selection.editableElement;
              return e2 ? t3.domConverter.mapViewToDom(e2.root) : null;
            }, this.set("visibleView", null), this.view = new Qh(t2.locale), t2.ui.view.body.add(this.view), t2.ui.focusTracker.add(this.view.element), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this.set("_numberOfStacks", 0), this.set("_singleViewMode", false), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
          }
          hasView(t2) {
            return Array.from(this._viewToStack.keys()).includes(t2);
          }
          add(t2) {
            if (this.hasView(t2.view))
              throw new hn.b("contextualballoon-add-view-exist: Cannot add configuration of the same view twice.", [this, t2]);
            const e2 = t2.stackId || "main";
            if (!this._idToStack.has(e2))
              return this._idToStack.set(e2, /* @__PURE__ */ new Map([[t2.view, t2]])), this._viewToStack.set(t2.view, this._idToStack.get(e2)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !t2.singleViewMode || this.showStack(e2));
            const n2 = this._idToStack.get(e2);
            t2.singleViewMode && this.showStack(e2), n2.set(t2.view, t2), this._viewToStack.set(t2.view, n2), n2 === this._visibleStack && this._showView(t2);
          }
          remove(t2) {
            if (!this.hasView(t2))
              throw new hn.b("contextualballoon-remove-view-not-exist: Cannot remove the configuration of a non-existent view.", [this, t2]);
            const e2 = this._viewToStack.get(t2);
            this._singleViewMode && this.visibleView === t2 && (this._singleViewMode = false), this.visibleView === t2 && (1 === e2.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e2.values())[e2.size - 2])), 1 === e2.size ? (this._idToStack.delete(this._getStackId(e2)), this._numberOfStacks = this._idToStack.size) : e2.delete(t2), this._viewToStack.delete(t2);
          }
          updatePosition(t2) {
            t2 && (this._visibleStack.get(this.visibleView).position = t2), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
          }
          showStack(t2) {
            this.visibleStack = t2;
            const e2 = this._idToStack.get(t2);
            if (!e2)
              throw new hn.b("contextualballoon-showstack-stack-not-exist: Cannot show a stack that does not exist.", this);
            this._visibleStack !== e2 && this._showView(Array.from(e2.values()).pop());
          }
          get _visibleStack() {
            return this._viewToStack.get(this.visibleView);
          }
          _getStackId(t2) {
            return Array.from(this._idToStack.entries()).find((e2) => e2[1] === t2)[0];
          }
          _showNextStack() {
            const t2 = Array.from(this._idToStack.values());
            let e2 = t2.indexOf(this._visibleStack) + 1;
            t2[e2] || (e2 = 0), this.showStack(this._getStackId(t2[e2]));
          }
          _showPrevStack() {
            const t2 = Array.from(this._idToStack.values());
            let e2 = t2.indexOf(this._visibleStack) - 1;
            t2[e2] || (e2 = t2.length - 1), this.showStack(this._getStackId(t2[e2]));
          }
          _createRotatorView() {
            const t2 = new ef(this.editor.locale), e2 = this.editor.locale.t;
            return this.view.content.add(t2), t2.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t3, e3) => !e3 && t3 > 1), t2.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), t2.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t3, n2) => {
              if (n2 < 2)
                return "";
              const i2 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
              return e2("%0 of %1", [i2, n2]);
            }), t2.buttonNextView.on("execute", () => {
              t2.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
            }), t2.buttonPrevView.on("execute", () => {
              t2.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
            }), t2;
          }
          _createFakePanelsView() {
            const t2 = new nf(this.editor.locale, this.view);
            return t2.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t3, e2) => !e2 && t3 >= 2 ? Math.min(t3 - 1, 2) : 0), t2.listenTo(this.view, "change:top", () => t2.updatePosition()), t2.listenTo(this.view, "change:left", () => t2.updatePosition()), this.editor.ui.view.body.add(t2), t2;
          }
          _showView({ view: t2, balloonClassName: e2 = "", withArrow: n2 = true, singleViewMode: i2 = false }) {
            this.view.class = e2, this.view.withArrow = n2, this._rotatorView.showView(t2), this.visibleView = t2, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i2 && (this._singleViewMode = true);
          }
          _getBalloonPosition() {
            let t2 = Array.from(this._visibleStack.values()).pop().position;
            return t2 && !t2.limiter && (t2 = Object.assign({}, t2, { limiter: this.positionLimiter })), t2;
          }
        }
        class ef extends cl {
          constructor(t2) {
            super(t2);
            const e2 = t2.t, n2 = this.bindTemplate;
            this.set("isNavigationVisible", true), this.focusTracker = new Oc(), this.buttonPrevView = this._createButtonView(e2("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(e2("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n2.to("isNavigationVisible", (t3) => t3 ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n2.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
          }
          render() {
            super.render(), this.focusTracker.add(this.element);
          }
          showView(t2) {
            this.hideView(), this.content.add(t2);
          }
          hideView() {
            this.content.clear();
          }
          _createButtonView(t2, e2) {
            const n2 = new Nl(this.locale);
            return n2.set({ label: t2, icon: e2, tooltip: true }), n2;
          }
        }
        class nf extends cl {
          constructor(t2, e2) {
            super(t2);
            const n2 = this.bindTemplate;
            this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e2, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n2.to("numberOfPanels", (t3) => t3 ? "" : "ck-hidden")], style: { top: n2.to("top", Xh), left: n2.to("left", Xh), width: n2.to("width", Xh), height: n2.to("height", Xh) } }, children: this.content }), this.on("change:numberOfPanels", (t3, e3, n3, i2) => {
              n3 > i2 ? this._addPanels(n3 - i2) : this._removePanels(i2 - n3), this.updatePosition();
            });
          }
          _addPanels(t2) {
            for (; t2--; ) {
              const t3 = new cl();
              t3.setTemplate({ tag: "div" }), this.content.add(t3), this.registerChild(t3);
            }
          }
          _removePanels(t2) {
            for (; t2--; ) {
              const t3 = this.content.last;
              this.content.remove(t3), this.deregisterChild(t3), t3.destroy();
            }
          }
          updatePosition() {
            if (this.numberOfPanels) {
              const { top: t2, left: e2 } = this._balloonPanelView, { width: n2, height: i2 } = new Zr(this._balloonPanelView.element);
              Object.assign(this, { top: t2, left: e2, width: n2, height: i2 });
            }
          }
        }
        function of(t2) {
          const e2 = t2.editing.view, n2 = Qh.defaultPositions;
          return { target: e2.domConverter.viewToDom(e2.document.selection.getSelectedElement()), positions: [n2.northArrowSouth, n2.northArrowSouthWest, n2.northArrowSouthEast, n2.southArrowNorth, n2.southArrowNorthWest, n2.southArrowNorthEast] };
        }
        class rf extends $l {
          static get requires() {
            return [tf];
          }
          static get pluginName() {
            return "ImageTextAlternativeUI";
          }
          init() {
            this._createButton(), this._createForm();
          }
          destroy() {
            super.destroy(), this._form.destroy();
          }
          _createButton() {
            const t2 = this.editor, e2 = t2.t;
            t2.ui.componentFactory.add("imageTextAlternative", (n2) => {
              const i2 = t2.commands.get("imageTextAlternative"), o2 = new Nl(n2);
              return o2.set({ label: e2("Change image text alternative"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', tooltip: true }), o2.bind("isEnabled").to(i2, "isEnabled"), this.listenTo(o2, "execute", () => {
                this._showForm();
              }), o2;
            });
          }
          _createForm() {
            const t2 = this.editor, e2 = t2.editing.view.document;
            this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new Yh(t2.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
              t2.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(true);
            }), this.listenTo(this._form, "cancel", () => {
              this._hideForm(true);
            }), this._form.keystrokes.set("Esc", (t3, e3) => {
              this._hideForm(true), e3();
            }), this.listenTo(t2.ui, "update", () => {
              Ou(e2.selection) ? this._isVisible && function(t3) {
                const e3 = t3.plugins.get("ContextualBalloon");
                if (Ou(t3.editing.view.document.selection)) {
                  const n2 = of(t3);
                  e3.updatePosition(n2);
                }
              }(t2) : this._hideForm(true);
            }), zl({ emitter: this._form, activator: () => this._isVisible, contextElements: [this._balloon.view.element], callback: () => this._hideForm() });
          }
          _showForm() {
            if (this._isVisible)
              return;
            const t2 = this.editor, e2 = t2.commands.get("imageTextAlternative"), n2 = this._form.labeledInput;
            this._isInBalloon || this._balloon.add({ view: this._form, position: of(t2) }), n2.fieldView.value = n2.fieldView.element.value = e2.value || "", this._form.labeledInput.fieldView.select();
          }
          _hideForm(t2) {
            this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t2 && this.editor.editing.view.focus());
          }
          get _isVisible() {
            return this._balloon.visibleView === this._form;
          }
          get _isInBalloon() {
            return this._balloon.hasView(this._form);
          }
        }
        class sf extends $l {
          static get requires() {
            return [zh, rf];
          }
          static get pluginName() {
            return "ImageTextAlternative";
          }
        }
        n(61);
        class af extends $l {
          static get requires() {
            return [Bu, Lh, sf];
          }
          static get pluginName() {
            return "Image";
          }
        }
        class cf extends cl {
          constructor(t2) {
            super(t2), this.buttonView = new Nl(t2), this._fileInputView = new lf(t2), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
              this._fileInputView.open();
            });
          }
          focus() {
            this.buttonView.focus();
          }
        }
        class lf extends cl {
          constructor(t2) {
            super(t2), this.set("acceptedType"), this.set("allowMultipleFiles", false);
            const e2 = this.bindTemplate;
            this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e2.to("acceptedType"), multiple: e2.to("allowMultipleFiles") }, on: { change: e2.to(() => {
              this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
            }) } });
          }
          open() {
            this.element.click();
          }
        }
        function df(t2) {
          const e2 = t2.map((t3) => t3.replace("+", "\\+"));
          return new RegExp(`^image\\/(${e2.join("|")})$`);
        }
        class uf extends $l {
          init() {
            const t2 = this.editor, e2 = t2.t;
            t2.ui.componentFactory.add("imageUpload", (n2) => {
              const i2 = new cf(n2), o2 = t2.commands.get("imageUpload"), r2 = t2.config.get("image.upload.types"), s2 = df(r2);
              return i2.set({ acceptedType: r2.map((t3) => "image/" + t3).join(","), allowMultipleFiles: true }), i2.buttonView.set({ label: e2("Insert image"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', tooltip: true }), i2.buttonView.bind("isEnabled").to(o2), i2.on("done", (e3, n3) => {
                const i3 = Array.from(n3).filter((t3) => s2.test(t3.type));
                i3.length && t2.execute("imageUpload", { file: i3 });
              }), i2;
            });
          }
        }
        n(63), n(65), n(67);
        class hf extends $l {
          constructor(t2) {
            super(t2), this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>');
          }
          init() {
            this.editor.editing.downcastDispatcher.on("attribute:uploadStatus:image", (...t2) => this.uploadStatusChange(...t2));
          }
          uploadStatusChange(t2, e2, n2) {
            const i2 = this.editor, o2 = e2.item, r2 = o2.getAttribute("uploadId");
            if (!n2.consumable.consume(e2.item, t2.name))
              return;
            const s2 = i2.plugins.get(Xd), a2 = r2 ? e2.attributeNewValue : null, c2 = this.placeholder, l2 = i2.editing.mapper.toViewElement(o2), d2 = n2.writer;
            if ("reading" == a2)
              return ff(l2, d2), void mf(c2, l2, d2);
            if ("uploading" == a2) {
              const t3 = s2.loaders.get(r2);
              return ff(l2, d2), void (t3 ? (gf(l2, d2), function(t4, e3, n3, i3) {
                const o3 = function(t5) {
                  const e4 = t5.createUIElement("div", { class: "ck-progress-bar" });
                  return t5.setCustomProperty("progressBar", true, e4), e4;
                }(e3);
                e3.insert(e3.createPositionAt(t4, "end"), o3), n3.on("change:uploadedPercent", (t5, e4, n4) => {
                  i3.change((t6) => {
                    t6.setStyle("width", n4 + "%", o3);
                  });
                });
              }(l2, d2, t3, i2.editing.view), function(t4, e3, n3) {
                if (n3.data) {
                  const i3 = ju(t4);
                  e3.setAttribute("src", n3.data, i3);
                }
              }(l2, d2, t3)) : mf(c2, l2, d2));
            }
            "complete" == a2 && s2.loaders.get(r2) && function(t3, e3, n3) {
              const i3 = e3.createUIElement("div", { class: "ck-image-upload-complete-icon" });
              e3.insert(e3.createPositionAt(t3, "end"), i3), setTimeout(() => {
                n3.change((t4) => t4.remove(t4.createRangeOn(i3)));
              }, 3e3);
            }(l2, d2, i2.editing.view), function(t3, e3) {
              bf(t3, e3, "progressBar");
            }(l2, d2), gf(l2, d2), function(t3, e3) {
              e3.removeClass("ck-appear", t3);
            }(l2, d2);
          }
        }
        function ff(t2, e2) {
          t2.hasClass("ck-appear") || e2.addClass("ck-appear", t2);
        }
        function mf(t2, e2, n2) {
          e2.hasClass("ck-image-upload-placeholder") || n2.addClass("ck-image-upload-placeholder", e2);
          const i2 = ju(e2);
          i2.getAttribute("src") !== t2 && n2.setAttribute("src", t2, i2), pf(e2, "placeholder") || n2.insert(n2.createPositionAfter(i2), function(t3) {
            const e3 = t3.createUIElement("div", { class: "ck-upload-placeholder-loader" });
            return t3.setCustomProperty("placeholder", true, e3), e3;
          }(n2));
        }
        function gf(t2, e2) {
          t2.hasClass("ck-image-upload-placeholder") && e2.removeClass("ck-image-upload-placeholder", t2), bf(t2, e2, "placeholder");
        }
        function pf(t2, e2) {
          for (const n2 of t2.getChildren())
            if (n2.getCustomProperty(e2))
              return n2;
        }
        function bf(t2, e2, n2) {
          const i2 = pf(t2, n2);
          i2 && e2.remove(e2.createRangeOn(i2));
        }
        class wf {
          constructor(t2) {
            this.document = t2;
          }
          createDocumentFragment(t2) {
            return new xo(this.document, t2);
          }
          createElement(t2, e2, n2) {
            return new Oi(this.document, t2, e2, n2);
          }
          createText(t2) {
            return new Rn(this.document, t2);
          }
          clone(t2, e2 = false) {
            return t2._clone(e2);
          }
          appendChild(t2, e2) {
            return e2._appendChild(t2);
          }
          insertChild(t2, e2, n2) {
            return n2._insertChild(t2, e2);
          }
          removeChildren(t2, e2, n2) {
            return n2._removeChildren(t2, e2);
          }
          remove(t2) {
            const e2 = t2.parent;
            return e2 ? this.removeChildren(e2.getChildIndex(t2), 1, e2) : [];
          }
          replace(t2, e2) {
            const n2 = t2.parent;
            if (n2) {
              const i2 = n2.getChildIndex(t2);
              return this.removeChildren(i2, 1, n2), this.insertChild(i2, e2, n2), true;
            }
            return false;
          }
          unwrapElement(t2) {
            const e2 = t2.parent;
            if (e2) {
              const n2 = e2.getChildIndex(t2);
              this.remove(t2), this.insertChild(n2, t2.getChildren(), e2);
            }
          }
          rename(t2, e2) {
            const n2 = new Oi(this.document, t2, e2.getAttributes(), e2.getChildren());
            return this.replace(e2, n2) ? n2 : null;
          }
          setAttribute(t2, e2, n2) {
            n2._setAttribute(t2, e2);
          }
          removeAttribute(t2, e2) {
            e2._removeAttribute(t2);
          }
          addClass(t2, e2) {
            e2._addClass(t2);
          }
          removeClass(t2, e2) {
            e2._removeClass(t2);
          }
          setStyle(t2, e2, n2) {
            y(t2) && void 0 === n2 && (n2 = e2), n2._setStyle(t2, e2);
          }
          removeStyle(t2, e2) {
            e2._removeStyle(t2);
          }
          setCustomProperty(t2, e2, n2) {
            n2._setCustomProperty(t2, e2);
          }
          removeCustomProperty(t2, e2) {
            return e2._removeCustomProperty(t2);
          }
          createPositionAt(t2, e2) {
            return Zi._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return Zi._createAfter(t2);
          }
          createPositionBefore(t2) {
            return Zi._createBefore(t2);
          }
          createRange(t2, e2) {
            return new Xi(t2, e2);
          }
          createRangeOn(t2) {
            return Xi._createOn(t2);
          }
          createRangeIn(t2) {
            return Xi._createIn(t2);
          }
          createSelection(t2, e2, n2) {
            return new no(t2, e2, n2);
          }
        }
        class kf extends td {
          refresh() {
            this.isEnabled = Lu(this.editor.model);
          }
          execute(t2) {
            const e2 = this.editor, n2 = e2.model, i2 = e2.plugins.get(Xd);
            n2.change((e3) => {
              const o2 = Array.isArray(t2.file) ? t2.file : [t2.file];
              for (const t3 of o2)
                _f(e3, n2, i2, t3);
            });
          }
        }
        function _f(t2, e2, n2, i2) {
          const o2 = n2.createLoader(i2);
          o2 && Du(t2, e2, { uploadId: o2.id });
        }
        class vf extends $l {
          static get requires() {
            return [Xd, xh, Xl];
          }
          static get pluginName() {
            return "ImageUploadEditing";
          }
          constructor(t2) {
            super(t2), t2.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } });
          }
          init() {
            const t2 = this.editor, e2 = t2.model.document, n2 = t2.model.schema, i2 = t2.conversion, o2 = t2.plugins.get(Xd), r2 = df(t2.config.get("image.upload.types"));
            n2.extend("image", { allowAttributes: ["uploadId", "uploadStatus"] }), t2.commands.add("imageUpload", new kf(t2)), i2.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(t2.editing.view.document, "clipboardInput", (e3, n3) => {
              if (i3 = n3.dataTransfer, Array.from(i3.types).includes("text/html") && "" !== i3.getData("text/html"))
                return;
              var i3;
              const o3 = Array.from(n3.dataTransfer.files).filter((t3) => !!t3 && r2.test(t3.type)), s2 = n3.targetRanges.map((e4) => t2.editing.mapper.toModelRange(e4));
              t2.model.change((n4) => {
                n4.setSelection(s2), o3.length && (e3.stop(), t2.model.enqueueChange("default", () => {
                  t2.execute("imageUpload", { file: o3 });
                }));
              });
            }), this.listenTo(t2.plugins.get(Xl), "inputTransformation", (e3, n3) => {
              const i3 = Array.from(t2.editing.view.createRangeIn(n3.content)).filter((t3) => {
                return !(!(e4 = t3.item).is("element", "img") || !e4.getAttribute("src")) && (e4.getAttribute("src").match(/^data:image\/\w+;base64,/g) || e4.getAttribute("src").match(/^blob:/g)) && !t3.item.getAttribute("uploadProcessed");
                var e4;
              }).map((t3) => {
                return { promise: (e4 = t3.item, new Promise((t4, n4) => {
                  const i4 = e4.getAttribute("src");
                  fetch(i4).then((t5) => t5.blob()).then((e5) => {
                    const n5 = function(t5, e6) {
                      return t5.type ? t5.type : e6.match(/data:(image\/\w+);base64/) ? e6.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
                    }(e5, i4), o3 = n5.replace("image/", ""), r4 = new File([e5], "image." + o3, { type: n5 });
                    t4(r4);
                  }).catch(n4);
                })), imageElement: t3.item };
                var e4;
              });
              if (!i3.length)
                return;
              const r3 = new wf(t2.editing.view.document);
              for (const t3 of i3) {
                r3.setAttribute("uploadProcessed", true, t3.imageElement);
                const e4 = o2.createLoader(t3.promise);
                e4 && (r3.setAttribute("src", "", t3.imageElement), r3.setAttribute("uploadId", e4.id, t3.imageElement));
              }
            }), t2.editing.view.document.on("dragover", (t3, e3) => {
              e3.preventDefault();
            }), e2.on("change", () => {
              const n3 = e2.differ.getChanges({ includeChangesInGraveyard: true });
              for (const e3 of n3)
                if ("insert" == e3.type && "$text" != e3.name) {
                  const n4 = e3.position.nodeAfter, i3 = "$graveyard" == e3.position.root.rootName;
                  for (const e4 of yf(t2, n4)) {
                    const t3 = e4.getAttribute("uploadId");
                    if (!t3)
                      continue;
                    const n5 = o2.loaders.get(t3);
                    n5 && (i3 ? n5.abort() : "idle" == n5.status && this._readAndUpload(n5, e4));
                  }
                }
            });
          }
          _readAndUpload(t2, e2) {
            const n2 = this.editor, i2 = n2.model, o2 = n2.locale.t, r2 = n2.plugins.get(Xd), s2 = n2.plugins.get(xh);
            return i2.enqueueChange("transparent", (t3) => {
              t3.setAttribute("uploadStatus", "reading", e2);
            }), t2.read().then(() => {
              const o3 = t2.upload();
              if (ho.isSafari) {
                const t3 = ju(n2.editing.mapper.toViewElement(e2));
                n2.editing.view.once("render", () => {
                  if (!t3.parent)
                    return;
                  const e3 = n2.editing.view.domConverter.mapViewToDom(t3.parent);
                  if (!e3)
                    return;
                  const i3 = e3.style.display;
                  e3.style.display = "none", e3._ckHack = e3.offsetHeight, e3.style.display = i3;
                });
              }
              return i2.enqueueChange("transparent", (t3) => {
                t3.setAttribute("uploadStatus", "uploading", e2);
              }), o3;
            }).then((t3) => {
              i2.enqueueChange("transparent", (n3) => {
                n3.setAttributes({ uploadStatus: "complete", src: t3.default }, e2), this._parseAndSetSrcsetAttributeOnImage(t3, e2, n3);
              }), a2();
            }).catch((n3) => {
              if ("error" !== t2.status && "aborted" !== t2.status)
                throw n3;
              "error" == t2.status && n3 && s2.showWarning(n3, { title: o2("Upload failed"), namespace: "upload" }), a2(), i2.enqueueChange("transparent", (t3) => {
                t3.remove(e2);
              });
            });
            function a2() {
              i2.enqueueChange("transparent", (t3) => {
                t3.removeAttribute("uploadId", e2), t3.removeAttribute("uploadStatus", e2);
              }), r2.destroyLoader(t2);
            }
          }
          _parseAndSetSrcsetAttributeOnImage(t2, e2, n2) {
            let i2 = 0;
            const o2 = Object.keys(t2).filter((t3) => {
              const e3 = parseInt(t3, 10);
              if (!isNaN(e3))
                return i2 = Math.max(i2, e3), true;
            }).map((e3) => `${t2[e3]} ${e3}w`).join(", ");
            "" != o2 && n2.setAttribute("srcset", { data: o2, width: i2 }, e2);
          }
        }
        function yf(t2, e2) {
          return Array.from(t2.model.createRangeOn(e2)).filter((t3) => t3.item.is("image")).map((t3) => t3.item);
        }
        class xf extends $l {
          static get pluginName() {
            return "ImageUpload";
          }
          static get requires() {
            return [vf, uf, hf];
          }
        }
        class Af extends td {
          refresh() {
            const t2 = this.editor.model, e2 = mu(t2.document.selection.getSelectedBlocks());
            this.value = !!e2 && e2.is("paragraph"), this.isEnabled = !!e2 && Tf(e2, t2.schema);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.document;
            e2.change((i2) => {
              const o2 = (t2.selection || n2.selection).getSelectedBlocks();
              for (const t3 of o2)
                !t3.is("paragraph") && Tf(t3, e2.schema) && i2.rename(t3, "paragraph");
            });
          }
        }
        function Tf(t2, e2) {
          return e2.checkChild(t2.parent, "paragraph") && !e2.isObject(t2);
        }
        class Cf extends $l {
          static get pluginName() {
            return "Paragraph";
          }
          init() {
            const t2 = this.editor, e2 = t2.model, n2 = t2.data;
            t2.commands.add("paragraph", new Af(t2)), e2.schema.register("paragraph", { inheritAllFrom: "$block" }), t2.conversion.elementToElement({ model: "paragraph", view: "p" }), t2.conversion.for("upcast").elementToElement({ model: (t3, e3) => Cf.paragraphLikeElements.has(t3.name) ? t3.isEmpty ? null : e3.createElement("paragraph") : null, converterPriority: "low" }), n2.upcastDispatcher.on("element", (t3, e3, n3) => {
              n3.consumable.test(e3.viewItem, { name: e3.viewItem.name }) && Sf(e3.viewItem, e3.modelCursor, n3.schema) && Object.assign(e3, Pf(e3.viewItem, e3.modelCursor, n3));
            }, { priority: "low" }), n2.upcastDispatcher.on("text", (t3, e3, n3) => {
              e3.modelRange || Sf(e3.viewItem, e3.modelCursor, n3.schema) && Object.assign(e3, Pf(e3.viewItem, e3.modelCursor, n3));
            }, { priority: "lowest" }), e2.document.registerPostFixer((t3) => this._autoparagraphEmptyRoots(t3)), t2.data.on("ready", () => {
              e2.enqueueChange("transparent", (t3) => this._autoparagraphEmptyRoots(t3));
            }, { priority: "lowest" });
          }
          _autoparagraphEmptyRoots(t2) {
            const e2 = this.editor.model;
            for (const n2 of e2.document.getRootNames()) {
              const i2 = e2.document.getRoot(n2);
              if (i2.isEmpty && "$graveyard" != i2.rootName && e2.schema.checkChild(i2, "paragraph"))
                return t2.insertElement("paragraph", i2), true;
            }
          }
        }
        function Pf(t2, e2, n2) {
          const i2 = n2.writer.createElement("paragraph");
          return n2.writer.insert(i2, e2), n2.convertItem(t2, n2.writer.createPositionAt(i2, 0));
        }
        function Sf(t2, e2, n2) {
          const i2 = n2.createContext(e2);
          return !!n2.checkChild(i2, "paragraph") && !!n2.checkChild(i2.push("paragraph"), t2);
        }
        Cf.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td"]);
        class Mf extends td {
          constructor(t2, e2) {
            super(t2), this.modelElements = e2;
          }
          refresh() {
            const t2 = mu(this.editor.model.document.selection.getSelectedBlocks());
            this.value = !!t2 && this.modelElements.includes(t2.name) && t2.name, this.isEnabled = !!t2 && this.modelElements.some((e2) => Ef(t2, e2, this.editor.model.schema));
          }
          execute(t2) {
            const e2 = this.editor.model, n2 = e2.document, i2 = t2.value;
            e2.change((t3) => {
              const o2 = Array.from(n2.selection.getSelectedBlocks()).filter((t4) => Ef(t4, i2, e2.schema));
              for (const e3 of o2)
                e3.is(i2) || t3.rename(e3, i2);
            });
          }
        }
        function Ef(t2, e2, n2) {
          return n2.checkChild(t2.parent, e2) && !n2.isObject(t2);
        }
        class If extends $l {
          static get pluginName() {
            return "HeadingEditing";
          }
          constructor(t2) {
            super(t2), t2.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
          }
          static get requires() {
            return [Cf];
          }
          init() {
            const t2 = this.editor, e2 = t2.config.get("heading.options"), n2 = [];
            for (const i2 of e2)
              "paragraph" !== i2.model && (t2.model.schema.register(i2.model, { inheritAllFrom: "$block" }), t2.conversion.elementToElement(i2), n2.push(i2.model));
            this._addDefaultH1Conversion(t2), t2.commands.add("heading", new Mf(t2, n2));
          }
          afterInit() {
            const t2 = this.editor, e2 = t2.commands.get("enter"), n2 = t2.config.get("heading.options");
            e2 && this.listenTo(e2, "afterExecute", (e3, i2) => {
              const o2 = t2.model.document.selection.getFirstPosition().parent;
              n2.some((t3) => o2.is(t3.model)) && !o2.is("paragraph") && 0 === o2.childCount && i2.writer.rename(o2, "paragraph");
            });
          }
          _addDefaultH1Conversion(t2) {
            t2.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: un.get("low") + 1 });
          }
        }
        class Nf {
          constructor(t2, e2) {
            e2 && ji(this, e2), t2 && this.set(t2);
          }
        }
        xn(Nf, Ui);
        n(11);
        class Of extends $l {
          init() {
            const t2 = this.editor, e2 = t2.t, n2 = function(t3) {
              const e3 = t3.t, n3 = { Paragraph: e3("Paragraph"), "Heading 1": e3("Heading 1"), "Heading 2": e3("Heading 2"), "Heading 3": e3("Heading 3"), "Heading 4": e3("Heading 4"), "Heading 5": e3("Heading 5"), "Heading 6": e3("Heading 6") };
              return t3.config.get("heading.options").map((t4) => {
                const e4 = n3[t4.title];
                return e4 && e4 != t4.title && (t4.title = e4), t4;
              });
            }(t2), i2 = e2("Choose heading"), o2 = e2("Heading");
            t2.ui.componentFactory.add("heading", (e3) => {
              const r2 = {}, s2 = new An(), a2 = t2.commands.get("heading"), c2 = t2.commands.get("paragraph"), l2 = [a2];
              for (const t3 of n2) {
                const e4 = { type: "button", model: new Nf({ label: t3.title, class: t3.class, withText: true }) };
                "paragraph" === t3.model ? (e4.model.bind("isOn").to(c2, "value"), e4.model.set("commandName", "paragraph"), l2.push(c2)) : (e4.model.bind("isOn").to(a2, "value", (e5) => e5 === t3.model), e4.model.set({ commandName: "heading", commandValue: t3.model })), s2.add(e4), r2[t3.model] = t3.title;
              }
              const d2 = Bl(e3);
              return Fl(d2, s2), d2.buttonView.set({ isOn: false, withText: true, tooltip: o2 }), d2.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), d2.bind("isEnabled").toMany(l2, "isEnabled", (...t3) => t3.some((t4) => t4)), d2.buttonView.bind("label").to(a2, "value", c2, "value", (t3, e4) => {
                const n3 = t3 || e4 && "paragraph";
                return r2[n3] ? r2[n3] : i2;
              }), this.listenTo(d2, "execute", (e4) => {
                t2.execute(e4.source.commandName, e4.source.commandValue ? { value: e4.source.commandValue } : void 0), t2.editing.view.focus();
              }), d2;
            });
          }
        }
        function Rf(t2) {
          for (const e2 of t2.getChildren())
            if (e2 && e2.is("caption"))
              return e2;
          return null;
        }
        function Df(t2) {
          const e2 = t2.parent;
          return "figcaption" == t2.name && e2 && "figure" == e2.name && e2.hasClass("image") ? { name: true } : null;
        }
        class Lf extends $l {
          static get pluginName() {
            return "ImageCaptionEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.editing.view, n2 = t2.model.schema, i2 = t2.data, o2 = t2.editing, r2 = t2.t;
            n2.register("caption", { allowIn: "image", allowContentOf: "$block", isLimit: true }), t2.model.document.registerPostFixer((t3) => this._insertMissingModelCaptionElement(t3)), t2.conversion.for("upcast").elementToElement({ view: Df, model: "caption" });
            i2.downcastDispatcher.on("insert:caption", jf((t3) => t3.createContainerElement("figcaption"), false));
            const s2 = function(t3, e3) {
              return (n3) => {
                const i3 = n3.createEditableElement("figcaption");
                return n3.setCustomProperty("imageCaption", true, i3), Lc({ view: t3, element: i3, text: e3 }), Eu(i3, n3);
              };
            }(e2, r2("Enter image caption"));
            o2.downcastDispatcher.on("insert:caption", jf(s2)), o2.downcastDispatcher.on("insert", this._fixCaptionVisibility((t3) => t3.item), { priority: "high" }), o2.downcastDispatcher.on("remove", this._fixCaptionVisibility((t3) => t3.position.parent), { priority: "high" }), e2.document.registerPostFixer((t3) => this._updateCaptionVisibility(t3));
          }
          _updateCaptionVisibility(t2) {
            const e2 = this.editor.editing.mapper, n2 = this._lastSelectedCaption;
            let i2;
            const o2 = this.editor.model.document.selection, r2 = o2.getSelectedElement();
            if (r2 && r2.is("image")) {
              const t3 = Rf(r2);
              i2 = e2.toViewElement(t3);
            }
            const s2 = Vf(o2.getFirstPosition().parent);
            if (s2 && (i2 = e2.toViewElement(s2)), i2)
              return n2 ? (n2 === i2 || (zf(n2, t2), this._lastSelectedCaption = i2), Bf(i2, t2)) : (this._lastSelectedCaption = i2, Bf(i2, t2));
            if (n2) {
              const e3 = zf(n2, t2);
              return this._lastSelectedCaption = null, e3;
            }
            return false;
          }
          _fixCaptionVisibility(t2) {
            return (e2, n2, i2) => {
              const o2 = Vf(t2(n2)), r2 = this.editor.editing.mapper, s2 = i2.writer;
              if (o2) {
                const t3 = r2.toViewElement(o2);
                t3 && (o2.childCount ? s2.removeClass("ck-hidden", t3) : s2.addClass("ck-hidden", t3));
              }
            };
          }
          _insertMissingModelCaptionElement(t2) {
            const e2 = this.editor.model, n2 = e2.document.differ.getChanges(), i2 = [];
            for (const t3 of n2)
              if ("insert" == t3.type && "$text" != t3.name) {
                const n3 = t3.position.nodeAfter;
                if (n3.is("image") && !Rf(n3) && i2.push(n3), !n3.is("image") && n3.childCount)
                  for (const t4 of e2.createRangeIn(n3).getItems())
                    t4.is("image") && !Rf(t4) && i2.push(t4);
              }
            for (const e3 of i2)
              t2.appendElement("caption", e3);
            return !!i2.length;
          }
        }
        function jf(t2, e2 = true) {
          return (n2, i2, o2) => {
            const r2 = i2.item;
            if ((r2.childCount || e2) && Ru(r2.parent)) {
              if (!o2.consumable.consume(i2.item, "insert"))
                return;
              const e3 = o2.mapper.toViewElement(i2.range.start.parent), n3 = t2(o2.writer), s2 = o2.writer;
              r2.childCount || s2.addClass("ck-hidden", n3), function(t3, e4, n4, i3) {
                const o3 = i3.writer.createPositionAt(n4, "end");
                i3.writer.insert(o3, t3), i3.mapper.bindElements(e4, t3);
              }(n3, i2.item, e3, o2);
            }
          };
        }
        function Vf(t2) {
          const e2 = t2.getAncestors({ includeSelf: true }).find((t3) => "caption" == t3.name);
          return e2 && e2.parent && "image" == e2.parent.name ? e2 : null;
        }
        function zf(t2, e2) {
          return !t2.childCount && !t2.hasClass("ck-hidden") && (e2.addClass("ck-hidden", t2), true);
        }
        function Bf(t2, e2) {
          return !!t2.hasClass("ck-hidden") && (e2.removeClass("ck-hidden", t2), true);
        }
        n(70);
        class Ff extends td {
          constructor(t2, e2) {
            super(t2), this.defaultStyle = false, this.styles = e2.reduce((t3, e3) => (t3[e3.name] = e3, e3.isDefault && (this.defaultStyle = e3.name), t3), {});
          }
          refresh() {
            const t2 = this.editor.model.document.selection.getSelectedElement();
            if (this.isEnabled = Ru(t2), t2)
              if (t2.hasAttribute("imageStyle")) {
                const e2 = t2.getAttribute("imageStyle");
                this.value = !!this.styles[e2] && e2;
              } else
                this.value = this.defaultStyle;
            else
              this.value = false;
          }
          execute(t2) {
            const e2 = t2.value, n2 = this.editor.model, i2 = n2.document.selection.getSelectedElement();
            n2.change((t3) => {
              this.styles[e2].isDefault ? t3.removeAttribute("imageStyle", i2) : t3.setAttribute("imageStyle", e2, i2);
            });
          }
        }
        function Uf(t2, e2) {
          for (const n2 of e2)
            if (n2.name === t2)
              return n2;
        }
        var Hf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm2.5 3V12h11V7.5h-11zM4.061 6H15.94c.586 0 1.061.407 1.061.91v5.68c0 .503-.475.91-1.061.91H4.06c-.585 0-1.06-.407-1.06-.91V6.91C3 6.406 3.475 6 4.061 6zM2 16.5V15h16v1.5z"/></svg>', qf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M18 4.5V3H2v1.5h16zm0 3V6h-5.674v1.5H18zm0 3V9h-5.674v1.5H18zm0 3V12h-5.674v1.5H18zm-8.5-6V12h-6V7.5h6zm.818-1.5H2.682C2.305 6 2 6.407 2 6.91v5.68c0 .503.305.91.682.91h7.636c.377 0 .682-.407.682-.91V6.91c0-.503-.305-.91-.682-.91zM18 16.5V15H2v1.5h16z"/></svg>', Wf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm4.5 3V12h7V7.5h-7zM5.758 6h8.484c.419 0 .758.407.758.91v5.681c0 .502-.34.909-.758.909H5.758c-.419 0-.758-.407-.758-.91V6.91c0-.503.34-.91.758-.91zM2 16.5V15h16v1.5z"/></svg>', Yf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm0 3V6h5.674v1.5zm0 3V9h5.674v1.5zm0 3V12h5.674v1.5zm8.5-6V12h6V7.5h-6zM9.682 6h7.636c.377 0 .682.407.682.91v5.68c0 .503-.305.91-.682.91H9.682c-.377 0-.682-.407-.682-.91V6.91c0-.503.305-.91.682-.91zM2 16.5V15h16v1.5z"/></svg>';
        const Gf = { full: { name: "full", title: "Full size image", icon: Hf, isDefault: true }, side: { name: "side", title: "Side image", icon: Yf, className: "image-style-side" }, alignLeft: { name: "alignLeft", title: "Left aligned image", icon: qf, className: "image-style-align-left" }, alignCenter: { name: "alignCenter", title: "Centered image", icon: Wf, className: "image-style-align-center" }, alignRight: { name: "alignRight", title: "Right aligned image", icon: Yf, className: "image-style-align-right" } }, $f = { full: Hf, left: qf, right: Yf, center: Wf };
        function Qf(t2 = []) {
          return t2.map(Kf);
        }
        function Kf(t2) {
          if ("string" == typeof t2) {
            const e2 = t2;
            Gf[e2] ? t2 = Object.assign({}, Gf[e2]) : (console.warn(Object(hn.a)("image-style-not-found: There is no such image style of given name."), { name: e2 }), t2 = { name: e2 });
          } else if (Gf[t2.name]) {
            const e2 = Gf[t2.name], n2 = Object.assign({}, t2);
            for (const i2 in e2)
              t2.hasOwnProperty(i2) || (n2[i2] = e2[i2]);
            t2 = n2;
          }
          return "string" == typeof t2.icon && $f[t2.icon] && (t2.icon = $f[t2.icon]), t2;
        }
        class Jf extends $l {
          static get pluginName() {
            return "ImageStyleEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.model.schema, n2 = t2.data, i2 = t2.editing;
            t2.config.define("image.styles", ["full", "side"]);
            const o2 = Qf(t2.config.get("image.styles"));
            e2.extend("image", { allowAttributes: "imageStyle" });
            const r2 = function(t3) {
              return (e3, n3, i3) => {
                if (!i3.consumable.consume(n3.item, e3.name))
                  return;
                const o3 = Uf(n3.attributeNewValue, t3), r3 = Uf(n3.attributeOldValue, t3), s2 = i3.mapper.toViewElement(n3.item), a2 = i3.writer;
                r3 && a2.removeClass(r3.className, s2), o3 && a2.addClass(o3.className, s2);
              };
            }(o2);
            i2.downcastDispatcher.on("attribute:imageStyle:image", r2), n2.downcastDispatcher.on("attribute:imageStyle:image", r2), n2.upcastDispatcher.on("element:figure", function(t3) {
              const e3 = t3.filter((t4) => !t4.isDefault);
              return (t4, n3, i3) => {
                if (!n3.modelRange)
                  return;
                const o3 = n3.viewItem, r3 = mu(n3.modelRange.getItems());
                if (i3.schema.checkAttribute(r3, "imageStyle"))
                  for (const t5 of e3)
                    i3.consumable.consume(o3, { classes: t5.className }) && i3.writer.setAttribute("imageStyle", t5.name, r3);
              };
            }(o2), { priority: "low" }), t2.commands.add("imageStyle", new Ff(t2, o2));
          }
        }
        n(72);
        class Zf extends $l {
          static get pluginName() {
            return "ImageStyleUI";
          }
          get localizedDefaultStylesTitles() {
            const t2 = this.editor.t;
            return { "Full size image": t2("Full size image"), "Side image": t2("Side image"), "Left aligned image": t2("Left aligned image"), "Centered image": t2("Centered image"), "Right aligned image": t2("Right aligned image") };
          }
          init() {
            const t2 = function(t3, e2) {
              for (const n2 of t3)
                e2[n2.title] && (n2.title = e2[n2.title]);
              return t3;
            }(Qf(this.editor.config.get("image.styles")), this.localizedDefaultStylesTitles);
            for (const e2 of t2)
              this._createButton(e2);
          }
          _createButton(t2) {
            const e2 = this.editor, n2 = "imageStyle:" + t2.name;
            e2.ui.componentFactory.add(n2, (n3) => {
              const i2 = e2.commands.get("imageStyle"), o2 = new Nl(n3);
              return o2.set({ label: t2.title, icon: t2.icon, tooltip: true, isToggleable: true }), o2.bind("isEnabled").to(i2, "isEnabled"), o2.bind("isOn").to(i2, "value", (e3) => e3 === t2.name), this.listenTo(o2, "execute", () => {
                e2.execute("imageStyle", { value: t2.name }), e2.editing.view.focus();
              }), o2;
            });
          }
        }
        class Xf extends $l {
          static get requires() {
            return [tf];
          }
          static get pluginName() {
            return "WidgetToolbarRepository";
          }
          init() {
            const t2 = this.editor;
            if (t2.plugins.has("BalloonToolbar")) {
              const e2 = t2.plugins.get("BalloonToolbar");
              this.listenTo(e2, "show", (e3) => {
                (function(t3) {
                  const e4 = t3.getSelectedElement();
                  return !(!e4 || !Pu(e4));
                })(t2.editing.view.document.selection) && e3.stop();
              }, { priority: "high" });
            }
            this._toolbarDefinitions = /* @__PURE__ */ new Map(), this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
              this._updateToolbarsVisibility();
            }), this.listenTo(t2.ui, "update", () => {
              this._updateToolbarsVisibility();
            }), this.listenTo(t2.ui.focusTracker, "change:isFocused", () => {
              this._updateToolbarsVisibility();
            }, { priority: "low" });
          }
          destroy() {
            super.destroy();
            for (const t2 of this._toolbarDefinitions.values())
              t2.view.destroy();
          }
          register(t2, { ariaLabel: e2, items: n2, getRelatedElement: i2, balloonClassName: o2 = "ck-toolbar-container" }) {
            const r2 = this.editor, s2 = r2.t, a2 = new Ul(r2.locale);
            if (a2.ariaLabel = e2 || s2("Widget toolbar"), this._toolbarDefinitions.has(t2))
              throw new hn.b("widget-toolbar-duplicated: Toolbar with the given id was already added.", this, { toolbarId: t2 });
            a2.fillFromConfig(n2, r2.ui.componentFactory), this._toolbarDefinitions.set(t2, { view: a2, getRelatedElement: i2, balloonClassName: o2 });
          }
          _updateToolbarsVisibility() {
            let t2 = 0, e2 = null, n2 = null;
            for (const i2 of this._toolbarDefinitions.values()) {
              const o2 = i2.getRelatedElement(this.editor.editing.view.document.selection);
              if (this.isEnabled && o2)
                if (this.editor.ui.focusTracker.isFocused) {
                  const r2 = o2.getAncestors().length;
                  r2 > t2 && (t2 = r2, e2 = o2, n2 = i2);
                } else
                  this._isToolbarVisible(i2) && this._hideToolbar(i2);
              else
                this._isToolbarInBalloon(i2) && this._hideToolbar(i2);
            }
            n2 && this._showToolbar(n2, e2);
          }
          _hideToolbar(t2) {
            this._balloon.remove(t2.view), this.stopListening(this._balloon, "change:visibleView");
          }
          _showToolbar(t2, e2) {
            this._isToolbarVisible(t2) ? tm(this.editor, e2) : this._isToolbarInBalloon(t2) || (this._balloon.add({ view: t2.view, position: em(this.editor, e2), balloonClassName: t2.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t3 of this._toolbarDefinitions.values())
                if (this._isToolbarVisible(t3)) {
                  const e3 = t3.getRelatedElement(this.editor.editing.view.document.selection);
                  tm(this.editor, e3);
                }
            }));
          }
          _isToolbarVisible(t2) {
            return this._balloon.visibleView === t2.view;
          }
          _isToolbarInBalloon(t2) {
            return this._balloon.hasView(t2.view);
          }
        }
        function tm(t2, e2) {
          const n2 = t2.plugins.get("ContextualBalloon"), i2 = em(t2, e2);
          n2.updatePosition(i2);
        }
        function em(t2, e2) {
          const n2 = t2.editing.view, i2 = Qh.defaultPositions;
          return { target: n2.domConverter.mapViewToDom(e2), positions: [i2.northArrowSouth, i2.northArrowSouthWest, i2.northArrowSouthEast, i2.southArrowNorth, i2.southArrowNorthWest, i2.southArrowNorthEast] };
        }
        class nm extends td {
          constructor(t2) {
            super(t2), this._childCommands = [];
          }
          refresh() {
          }
          execute(...t2) {
            this._getFirstEnabledCommand().execute(t2);
          }
          registerChildCommand(t2) {
            this._childCommands.push(t2), t2.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
          }
          _checkEnabled() {
            this.isEnabled = !!this._getFirstEnabledCommand();
          }
          _getFirstEnabledCommand() {
            return this._childCommands.find((t2) => t2.isEnabled);
          }
        }
        class im extends $l {
          static get pluginName() {
            return "IndentEditing";
          }
          init() {
            const t2 = this.editor;
            t2.commands.add("indent", new nm(t2)), t2.commands.add("outdent", new nm(t2));
          }
        }
        var om = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95L5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', rm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class sm extends $l {
          static get pluginName() {
            return "IndentUI";
          }
          init() {
            const t2 = this.editor, e2 = t2.locale, n2 = t2.t, i2 = "ltr" == e2.uiLanguageDirection ? om : rm, o2 = "ltr" == e2.uiLanguageDirection ? rm : om;
            this._defineButton("indent", n2("Increase indent"), i2), this._defineButton("outdent", n2("Decrease indent"), o2);
          }
          _defineButton(t2, e2, n2) {
            const i2 = this.editor;
            i2.ui.componentFactory.add(t2, (o2) => {
              const r2 = i2.commands.get(t2), s2 = new Nl(o2);
              return s2.set({ label: e2, icon: n2, tooltip: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), this.listenTo(s2, "execute", () => {
                i2.execute(t2), i2.editing.view.focus();
              }), s2;
            });
          }
        }
        class am extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = "click";
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        n(74);
        class cm extends cl {
          constructor(t2, e2) {
            super(t2);
            const n2 = t2.t;
            this.focusTracker = new Oc(), this.keystrokes = new Ac(), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n2("Save"), qh, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n2("Cancel"), Wh, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e2), this.children = this._createFormChildren(e2.manualDecorators), this._focusables = new Uc(), this._focusCycler = new kl({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
            const i2 = ["ck", "ck-link-form"];
            e2.manualDecorators.length && i2.push("ck-link-form_layout-vertical"), this.setTemplate({ tag: "form", attributes: { class: i2, tabindex: "-1" }, children: this.children });
          }
          getDecoratorSwitchesState() {
            return Array.from(this._manualDecoratorSwitches).reduce((t2, e2) => (t2[e2.name] = e2.isOn, t2), {});
          }
          render() {
            super.render(), Hh({ view: this }), [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t2) => {
              this._focusables.add(t2), this.focusTracker.add(t2.element);
            }), this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createUrlInput() {
            const t2 = this.locale.t, e2 = new Bh(this.locale, Uh);
            return e2.label = t2("Link URL"), e2.fieldView.placeholder = "https://example.com", e2;
          }
          _createButton(t2, e2, n2, i2) {
            const o2 = new Nl(this.locale);
            return o2.set({ label: t2, icon: e2, tooltip: true }), o2.extendTemplate({ attributes: { class: n2 } }), i2 && o2.delegate("execute").to(this, i2), o2;
          }
          _createManualDecoratorSwitches(t2) {
            const e2 = this.createCollection();
            for (const n2 of t2.manualDecorators) {
              const i2 = new Vl(this.locale);
              i2.set({ name: n2.id, label: n2.label, withText: true }), i2.bind("isOn").toMany([n2, t2], "value", (t3, e3) => void 0 === e3 && void 0 === t3 ? n2.defaultValue : t3), i2.on("execute", () => {
                n2.set("value", !i2.isOn);
              }), e2.add(i2);
            }
            return e2;
          }
          _createFormChildren(t2) {
            const e2 = this.createCollection();
            if (e2.add(this.urlInputView), t2.length) {
              const t3 = new cl();
              t3.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t4) => ({ tag: "li", children: [t4], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), e2.add(t3);
            }
            return e2.add(this.saveButtonView), e2.add(this.cancelButtonView), e2;
          }
        }
        n(76);
        class lm extends cl {
          constructor(t2) {
            super(t2);
            const e2 = t2.t;
            this.focusTracker = new Oc(), this.keystrokes = new Ac(), this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e2("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e2("Edit link"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>', "edit"), this.set("href"), this._focusables = new Uc(), this._focusCycler = new kl({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
          }
          render() {
            super.render(), [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t2) => {
              this._focusables.add(t2), this.focusTracker.add(t2.element);
            }), this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createButton(t2, e2, n2) {
            const i2 = new Nl(this.locale);
            return i2.set({ label: t2, icon: e2, tooltip: true }), i2.delegate("execute").to(this, n2), i2;
          }
          _createPreviewButton() {
            const t2 = new Nl(this.locale), e2 = this.bindTemplate, n2 = this.t;
            return t2.set({ withText: true, tooltip: n2("Open link in new tab") }), t2.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e2.to("href", (t3) => t3 && hh(t3)), target: "_blank", rel: "noopener noreferrer" } }), t2.bind("label").to(this, "href", (t3) => t3 || n2("This link has no URL")), t2.bind("isEnabled").to(this, "href", (t3) => !!t3), t2.template.tag = "a", t2.template.eventListeners = {}, t2;
          }
        }
        class dm extends $l {
          static get requires() {
            return [tf];
          }
          static get pluginName() {
            return "LinkUI";
          }
          init() {
            const t2 = this.editor;
            t2.editing.view.addObserver(am), this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._balloon = t2.plugins.get(tf), this._createToolbarLinkButton(), this._enableUserBalloonInteractions();
          }
          destroy() {
            super.destroy(), this.formView.destroy();
          }
          _createActionsView() {
            const t2 = this.editor, e2 = new lm(t2.locale), n2 = t2.commands.get("link"), i2 = t2.commands.get("unlink");
            return e2.bind("href").to(n2, "value"), e2.editButtonView.bind("isEnabled").to(n2), e2.unlinkButtonView.bind("isEnabled").to(i2), this.listenTo(e2, "edit", () => {
              this._addFormView();
            }), this.listenTo(e2, "unlink", () => {
              t2.execute("unlink"), this._hideUI();
            }), e2.keystrokes.set("Esc", (t3, e3) => {
              this._hideUI(), e3();
            }), e2.keystrokes.set("Ctrl+K", (t3, e3) => {
              this._addFormView(), e3();
            }), e2;
          }
          _createFormView() {
            const t2 = this.editor, e2 = t2.commands.get("link"), n2 = new cm(t2.locale, e2);
            return n2.urlInputView.fieldView.bind("value").to(e2, "value"), n2.urlInputView.bind("isReadOnly").to(e2, "isEnabled", (t3) => !t3), n2.saveButtonView.bind("isEnabled").to(e2), this.listenTo(n2, "submit", () => {
              t2.execute("link", n2.urlInputView.fieldView.element.value, n2.getDecoratorSwitchesState()), this._closeFormView();
            }), this.listenTo(n2, "cancel", () => {
              this._closeFormView();
            }), n2.keystrokes.set("Esc", (t3, e3) => {
              this._closeFormView(), e3();
            }), n2;
          }
          _createToolbarLinkButton() {
            const t2 = this.editor, e2 = t2.commands.get("link"), n2 = t2.t;
            t2.keystrokes.set("Ctrl+K", (t3, e3) => {
              e3(), this._showUI(true);
            }), t2.ui.componentFactory.add("link", (t3) => {
              const i2 = new Nl(t3);
              return i2.isEnabled = true, i2.label = n2("Link"), i2.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', i2.keystroke = "Ctrl+K", i2.tooltip = true, i2.isToggleable = true, i2.bind("isEnabled").to(e2, "isEnabled"), i2.bind("isOn").to(e2, "value", (t4) => !!t4), this.listenTo(i2, "execute", () => this._showUI(true)), i2;
            });
          }
          _enableUserBalloonInteractions() {
            const t2 = this.editor.editing.view.document;
            this.listenTo(t2, "click", () => {
              this._getSelectedLinkElement() && this._showUI();
            }), this.editor.keystrokes.set("Tab", (t3, e2) => {
              this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e2());
            }, { priority: "high" }), this.editor.keystrokes.set("Esc", (t3, e2) => {
              this._isUIVisible && (this._hideUI(), e2());
            }), zl({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: [this._balloon.view.element], callback: () => this._hideUI() });
          }
          _addActionsView() {
            this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
          }
          _addFormView() {
            if (this._isFormInPanel)
              return;
            const t2 = this.editor.commands.get("link");
            this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.urlInputView.fieldView.element.value = t2.value || "";
          }
          _closeFormView() {
            const t2 = this.editor.commands.get("link");
            t2.restoreManualDecoratorStates(), void 0 !== t2.value ? this._removeFormView() : this._hideUI();
          }
          _removeFormView() {
            this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus());
          }
          _showUI(t2 = false) {
            this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t2 && this._balloon.showStack("main")) : (this._addActionsView(), t2 && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
          }
          _hideUI() {
            if (!this._isUIInPanel)
              return;
            const t2 = this.editor;
            this.stopListening(t2.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t2.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView);
          }
          _startUpdatingUI() {
            const t2 = this.editor, e2 = t2.editing.view.document;
            let n2 = this._getSelectedLinkElement(), i2 = r2();
            const o2 = () => {
              const t3 = this._getSelectedLinkElement(), e3 = r2();
              n2 && !t3 || !n2 && e3 !== i2 ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n2 = t3, i2 = e3;
            };
            function r2() {
              return e2.selection.focus.getAncestors().reverse().find((t3) => t3.is("element"));
            }
            this.listenTo(t2.ui, "update", o2), this.listenTo(this._balloon, "change:visibleView", o2);
          }
          get _isFormInPanel() {
            return this._balloon.hasView(this.formView);
          }
          get _areActionsInPanel() {
            return this._balloon.hasView(this.actionsView);
          }
          get _areActionsVisible() {
            return this._balloon.visibleView === this.actionsView;
          }
          get _isUIInPanel() {
            return this._isFormInPanel || this._areActionsInPanel;
          }
          get _isUIVisible() {
            return this._balloon.visibleView == this.formView || this._areActionsVisible;
          }
          _getBalloonPositionData() {
            const t2 = this.editor.editing.view, e2 = t2.document, n2 = this._getSelectedLinkElement();
            return { target: n2 ? t2.domConverter.mapViewToDom(n2) : t2.domConverter.viewRangeToDom(e2.selection.getFirstRange()) };
          }
          _getSelectedLinkElement() {
            const t2 = this.editor.editing.view, e2 = t2.document.selection;
            if (e2.isCollapsed)
              return um(e2.getFirstPosition());
            {
              const n2 = e2.getFirstRange().getTrimmed(), i2 = um(n2.start), o2 = um(n2.end);
              return i2 && i2 == o2 && t2.createRangeIn(i2).getTrimmed().isEqual(n2) ? i2 : null;
            }
          }
        }
        function um(t2) {
          return t2.getAncestors().find((t3) => {
            return (e2 = t3).is("attributeElement") && !!e2.getCustomProperty("link");
            var e2;
          });
        }
        class hm extends td {
          constructor(t2, e2) {
            super(t2), this.type = e2;
          }
          refresh() {
            this.value = this._getValue(), this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t2 = this.editor.model, e2 = t2.document, n2 = Array.from(e2.selection.getSelectedBlocks()).filter((e3) => mm(e3, t2.schema)), i2 = true === this.value;
            t2.change((t3) => {
              if (i2) {
                let e3 = n2[n2.length - 1].nextSibling, i3 = Number.POSITIVE_INFINITY, o2 = [];
                for (; e3 && "listItem" == e3.name && 0 !== e3.getAttribute("listIndent"); ) {
                  const t4 = e3.getAttribute("listIndent");
                  t4 < i3 && (i3 = t4);
                  const n3 = t4 - i3;
                  o2.push({ element: e3, listIndent: n3 }), e3 = e3.nextSibling;
                }
                o2 = o2.reverse();
                for (const e4 of o2)
                  t3.setAttribute("listIndent", e4.listIndent, e4.element);
              }
              if (!i2) {
                let t4 = Number.POSITIVE_INFINITY;
                for (const e3 of n2)
                  e3.is("listItem") && e3.getAttribute("listIndent") < t4 && (t4 = e3.getAttribute("listIndent"));
                t4 = 0 === t4 ? 1 : t4, fm(n2, true, t4), fm(n2, false, t4);
              }
              for (const e3 of n2.reverse())
                i2 && "listItem" == e3.name ? t3.rename(e3, "paragraph") : i2 || "listItem" == e3.name ? i2 || "listItem" != e3.name || e3.getAttribute("listType") == this.type || t3.setAttribute("listType", this.type, e3) : (t3.setAttributes({ listType: this.type, listIndent: 0 }, e3), t3.rename(e3, "listItem"));
            });
          }
          _getValue() {
            const t2 = mu(this.editor.model.document.selection.getSelectedBlocks());
            return !!t2 && t2.is("listItem") && t2.getAttribute("listType") == this.type;
          }
          _checkEnabled() {
            if (this.value)
              return true;
            const t2 = this.editor.model.document.selection, e2 = this.editor.model.schema, n2 = mu(t2.getSelectedBlocks());
            return !!n2 && mm(n2, e2);
          }
        }
        function fm(t2, e2, n2) {
          const i2 = e2 ? t2[0] : t2[t2.length - 1];
          if (i2.is("listItem")) {
            let o2 = i2[e2 ? "previousSibling" : "nextSibling"], r2 = i2.getAttribute("listIndent");
            for (; o2 && o2.is("listItem") && o2.getAttribute("listIndent") >= n2; )
              r2 > o2.getAttribute("listIndent") && (r2 = o2.getAttribute("listIndent")), o2.getAttribute("listIndent") == r2 && t2[e2 ? "unshift" : "push"](o2), o2 = o2[e2 ? "previousSibling" : "nextSibling"];
          }
        }
        function mm(t2, e2) {
          return e2.checkChild(t2.parent, "listItem") && !e2.isObject(t2);
        }
        class gm extends td {
          constructor(t2, e2) {
            super(t2), this._indentBy = "forward" == e2 ? 1 : -1;
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t2 = this.editor.model, e2 = t2.document;
            let n2 = Array.from(e2.selection.getSelectedBlocks());
            t2.change((t3) => {
              const e3 = n2[n2.length - 1];
              let i2 = e3.nextSibling;
              for (; i2 && "listItem" == i2.name && i2.getAttribute("listIndent") > e3.getAttribute("listIndent"); )
                n2.push(i2), i2 = i2.nextSibling;
              this._indentBy < 0 && (n2 = n2.reverse());
              for (const e4 of n2) {
                const n3 = e4.getAttribute("listIndent") + this._indentBy;
                n3 < 0 ? t3.rename(e4, "paragraph") : t3.setAttribute("listIndent", n3, e4);
              }
            });
          }
          _checkEnabled() {
            const t2 = mu(this.editor.model.document.selection.getSelectedBlocks());
            if (!t2 || !t2.is("listItem"))
              return false;
            if (this._indentBy > 0) {
              const e2 = t2.getAttribute("listIndent"), n2 = t2.getAttribute("listType");
              let i2 = t2.previousSibling;
              for (; i2 && i2.is("listItem") && i2.getAttribute("listIndent") >= e2; ) {
                if (i2.getAttribute("listIndent") == e2)
                  return i2.getAttribute("listType") == n2;
                i2 = i2.previousSibling;
              }
              return false;
            }
            return true;
          }
        }
        function pm(t2, e2) {
          const n2 = e2.mapper, i2 = e2.writer, o2 = "numbered" == t2.getAttribute("listType") ? "ol" : "ul", r2 = function(t3) {
            const e3 = t3.createContainerElement("li");
            return e3.getFillerOffset = ym, e3;
          }(i2), s2 = i2.createContainerElement(o2, null);
          return i2.insert(i2.createPositionAt(s2, 0), r2), n2.bindElements(t2, r2), r2;
        }
        function bm(t2, e2, n2, i2) {
          const o2 = e2.parent, r2 = n2.mapper, s2 = n2.writer;
          let a2 = r2.toViewPosition(i2.createPositionBefore(t2));
          const c2 = _m(t2.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t2.getAttribute("listIndent") }), l2 = t2.previousSibling;
          if (c2 && c2.getAttribute("listIndent") == t2.getAttribute("listIndent")) {
            const t3 = r2.toViewElement(c2);
            a2 = s2.breakContainer(s2.createPositionAfter(t3));
          } else
            a2 = l2 && "listItem" == l2.name ? r2.toViewPosition(i2.createPositionAt(l2, "end")) : r2.toViewPosition(i2.createPositionBefore(t2));
          if (a2 = km(a2), s2.insert(a2, o2), l2 && "listItem" == l2.name) {
            const t3 = r2.toViewElement(l2), n3 = s2.createRange(s2.createPositionAt(t3, 0), a2).getWalker({ ignoreElementEnd: true });
            for (const t4 of n3)
              if (t4.item.is("li")) {
                const i3 = s2.breakContainer(s2.createPositionBefore(t4.item)), o3 = t4.item.parent, r3 = s2.createPositionAt(e2, "end");
                wm(s2, r3.nodeBefore, r3.nodeAfter), s2.move(s2.createRangeOn(o3), r3), n3.position = i3;
              }
          } else {
            const n3 = o2.nextSibling;
            if (n3 && (n3.is("ul") || n3.is("ol"))) {
              let i3 = null;
              for (const e3 of n3.getChildren()) {
                const n4 = r2.toModelElement(e3);
                if (!(n4 && n4.getAttribute("listIndent") > t2.getAttribute("listIndent")))
                  break;
                i3 = e3;
              }
              i3 && (s2.breakContainer(s2.createPositionAfter(i3)), s2.move(s2.createRangeOn(i3.parent), s2.createPositionAt(e2, "end")));
            }
          }
          wm(s2, o2, o2.nextSibling), wm(s2, o2.previousSibling, o2);
        }
        function wm(t2, e2, n2) {
          return !e2 || !n2 || "ul" != e2.name && "ol" != e2.name || e2.name != n2.name || e2.getAttribute("class") !== n2.getAttribute("class") ? null : t2.mergeContainers(t2.createPositionAfter(e2));
        }
        function km(t2) {
          return t2.getLastMatchingPosition((t3) => t3.item.is("uiElement"));
        }
        function _m(t2, e2) {
          const n2 = !!e2.sameIndent, i2 = !!e2.smallerIndent, o2 = e2.listIndent;
          let r2 = t2;
          for (; r2 && "listItem" == r2.name; ) {
            const t3 = r2.getAttribute("listIndent");
            if (n2 && o2 == t3 || i2 && o2 > t3)
              return r2;
            r2 = r2.previousSibling;
          }
          return null;
        }
        function vm(t2, e2, n2, i2) {
          t2.ui.componentFactory.add(e2, (o2) => {
            const r2 = t2.commands.get(e2), s2 = new Nl(o2);
            return s2.set({ label: n2, icon: i2, tooltip: true, isToggleable: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), s2.on("execute", () => {
              t2.execute(e2), t2.editing.view.focus();
            }), s2;
          });
        }
        function ym() {
          const t2 = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
          return this.isEmpty || t2 ? 0 : Li.call(this);
        }
        function xm(t2) {
          return (e2, n2, i2) => {
            const o2 = i2.consumable;
            if (!o2.test(n2.item, "insert") || !o2.test(n2.item, "attribute:listType") || !o2.test(n2.item, "attribute:listIndent"))
              return;
            o2.consume(n2.item, "insert"), o2.consume(n2.item, "attribute:listType"), o2.consume(n2.item, "attribute:listIndent");
            const r2 = n2.item;
            bm(r2, pm(r2, i2), i2, t2);
          };
        }
        function Am(t2, e2, n2) {
          if (!n2.consumable.consume(e2.item, "attribute:listType"))
            return;
          const i2 = n2.mapper.toViewElement(e2.item), o2 = n2.writer;
          o2.breakContainer(o2.createPositionBefore(i2)), o2.breakContainer(o2.createPositionAfter(i2));
          const r2 = i2.parent, s2 = "numbered" == e2.attributeNewValue ? "ol" : "ul";
          o2.rename(s2, r2);
        }
        function Tm(t2, e2, n2) {
          const i2 = n2.mapper.toViewElement(e2.item).parent, o2 = n2.writer;
          wm(o2, i2, i2.nextSibling), wm(o2, i2.previousSibling, i2);
          for (const t3 of e2.item.getChildren())
            n2.consumable.consume(t3, "insert");
        }
        function Cm(t2, e2, n2) {
          if ("listItem" != e2.item.name) {
            let t3 = n2.mapper.toViewPosition(e2.range.start);
            const i2 = n2.writer, o2 = [];
            for (; ("ul" == t3.parent.name || "ol" == t3.parent.name) && (t3 = i2.breakContainer(t3), "li" == t3.parent.name); ) {
              const e3 = t3, n3 = i2.createPositionAt(t3.parent, "end");
              if (!e3.isEqual(n3)) {
                const t4 = i2.remove(i2.createRange(e3, n3));
                o2.push(t4);
              }
              t3 = i2.createPositionAfter(t3.parent);
            }
            if (o2.length > 0) {
              for (let e3 = 0; e3 < o2.length; e3++) {
                const n3 = t3.nodeBefore;
                if (t3 = i2.insert(t3, o2[e3]).end, e3 > 0) {
                  const e4 = wm(i2, n3, n3.nextSibling);
                  e4 && e4.parent == n3 && t3.offset--;
                }
              }
              wm(i2, t3.nodeBefore, t3.nodeAfter);
            }
          }
        }
        function Pm(t2, e2, n2) {
          const i2 = n2.mapper.toViewPosition(e2.position), o2 = i2.nodeBefore, r2 = i2.nodeAfter;
          wm(n2.writer, o2, r2);
        }
        function Sm(t2, e2, n2) {
          if (n2.consumable.consume(e2.viewItem, { name: true })) {
            const t3 = n2.writer, i2 = t3.createElement("listItem"), o2 = function(t4) {
              let e3 = 0, n3 = t4.parent;
              for (; n3; ) {
                if (n3.is("li"))
                  e3++;
                else {
                  const t5 = n3.previousSibling;
                  t5 && t5.is("li") && e3++;
                }
                n3 = n3.parent;
              }
              return e3;
            }(e2.viewItem);
            t3.setAttribute("listIndent", o2, i2);
            const r2 = e2.viewItem.parent && "ol" == e2.viewItem.parent.name ? "numbered" : "bulleted";
            t3.setAttribute("listType", r2, i2);
            const s2 = n2.splitToAllowedParent(i2, e2.modelCursor);
            if (!s2)
              return;
            t3.insert(i2, s2.position);
            const a2 = function(t4, e3, n3) {
              const { writer: i3, schema: o3 } = n3;
              let r3 = i3.createPositionAfter(t4);
              for (const s3 of e3)
                if ("ul" == s3.name || "ol" == s3.name)
                  r3 = n3.convertItem(s3, r3).modelCursor;
                else {
                  const e4 = n3.convertItem(s3, i3.createPositionAt(t4, "end")), a3 = e4.modelRange.start.nodeAfter;
                  a3 && a3.is("element") && !o3.checkChild(t4, a3.name) && (t4 = e4.modelCursor.parent.is("listItem") ? e4.modelCursor.parent : Om(e4.modelCursor), r3 = i3.createPositionAfter(t4));
                }
              return r3;
            }(i2, e2.viewItem.getChildren(), n2);
            e2.modelRange = t3.createRange(e2.modelCursor, a2), s2.cursorParent ? e2.modelCursor = t3.createPositionAt(s2.cursorParent, 0) : e2.modelCursor = e2.modelRange.end;
          }
        }
        function Mm(t2, e2, n2) {
          if (n2.consumable.test(e2.viewItem, { name: true })) {
            const t3 = Array.from(e2.viewItem.getChildren());
            for (const e3 of t3) {
              !(e3.is("li") || Dm(e3)) && e3._remove();
            }
          }
        }
        function Em(t2, e2, n2) {
          if (n2.consumable.test(e2.viewItem, { name: true })) {
            if (0 === e2.viewItem.childCount)
              return;
            const t3 = [...e2.viewItem.getChildren()];
            let n3 = false, i2 = true;
            for (const e3 of t3)
              n3 && !Dm(e3) && e3._remove(), e3.is("text") ? (i2 && (e3._data = e3.data.replace(/^\s+/, "")), e3.nextSibling && !Dm(e3.nextSibling) || (e3._data = e3.data.replace(/\s+$/, ""))) : Dm(e3) && (n3 = true), i2 = false;
          }
        }
        function Im(t2) {
          return (e2, n2) => {
            if (n2.isPhantom)
              return;
            const i2 = n2.modelPosition.nodeBefore;
            if (i2 && i2.is("listItem")) {
              const e3 = n2.mapper.toViewElement(i2), o2 = e3.getAncestors().find(Dm), r2 = t2.createPositionAt(e3, 0).getWalker();
              for (const t3 of r2) {
                if ("elementStart" == t3.type && t3.item.is("li")) {
                  n2.viewPosition = t3.previousPosition;
                  break;
                }
                if ("elementEnd" == t3.type && t3.item == o2) {
                  n2.viewPosition = t3.nextPosition;
                  break;
                }
              }
            }
          };
        }
        function Nm(t2, [e2, n2]) {
          let i2, o2 = e2.is("documentFragment") ? e2.getChild(0) : e2;
          if (i2 = n2 ? this.createSelection(n2) : this.document.selection, o2 && o2.is("listItem")) {
            const t3 = i2.getFirstPosition();
            let e3 = null;
            if (t3.parent.is("listItem") ? e3 = t3.parent : t3.nodeBefore && t3.nodeBefore.is("listItem") && (e3 = t3.nodeBefore), e3) {
              const t4 = e3.getAttribute("listIndent");
              if (t4 > 0)
                for (; o2 && o2.is("listItem"); )
                  o2._setAttribute("listIndent", o2.getAttribute("listIndent") + t4), o2 = o2.nextSibling;
            }
          }
        }
        function Om(t2) {
          const e2 = new bs({ startPosition: t2 });
          let n2;
          do {
            n2 = e2.next();
          } while (!n2.value.item.is("listItem"));
          return n2.value.item;
        }
        function Rm(t2, e2, n2, i2, o2, r2) {
          const s2 = _m(e2.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t2, foo: "b" }), a2 = o2.mapper, c2 = o2.writer, l2 = s2 ? s2.getAttribute("listIndent") : null;
          let d2;
          if (s2)
            if (l2 == t2) {
              const t3 = a2.toViewElement(s2).parent;
              d2 = c2.createPositionAfter(t3);
            } else {
              const t3 = r2.createPositionAt(s2, "end");
              d2 = a2.toViewPosition(t3);
            }
          else
            d2 = n2;
          d2 = km(d2);
          for (const t3 of [...i2.getChildren()])
            Dm(t3) && (d2 = c2.move(c2.createRangeOn(t3), d2).end, wm(c2, t3, t3.nextSibling), wm(c2, t3.previousSibling, t3));
        }
        function Dm(t2) {
          return t2.is("ol") || t2.is("ul");
        }
        class Lm extends $l {
          static get pluginName() {
            return "ListEditing";
          }
          static get requires() {
            return [Cf];
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
            const e2 = t2.data, n2 = t2.editing;
            var i2;
            t2.model.document.registerPostFixer((e3) => function(t3, e4) {
              const n3 = t3.document.differ.getChanges(), i3 = /* @__PURE__ */ new Map();
              let o3 = false;
              for (const i4 of n3)
                if ("insert" == i4.type && "listItem" == i4.name)
                  r3(i4.position);
                else if ("insert" == i4.type && "listItem" != i4.name) {
                  if ("$text" != i4.name) {
                    const n4 = i4.position.nodeAfter;
                    n4.hasAttribute("listIndent") && (e4.removeAttribute("listIndent", n4), o3 = true), n4.hasAttribute("listType") && (e4.removeAttribute("listType", n4), o3 = true);
                    for (const e5 of Array.from(t3.createRangeIn(n4)).filter((t4) => t4.item.is("listItem")))
                      r3(e5.previousPosition);
                  }
                  r3(i4.position.getShiftedBy(i4.length));
                } else
                  "remove" == i4.type && "listItem" == i4.name ? r3(i4.position) : ("attribute" == i4.type && "listIndent" == i4.attributeKey || "attribute" == i4.type && "listType" == i4.attributeKey) && r3(i4.range.start);
              for (const t4 of i3.values())
                s2(t4), a2(t4);
              return o3;
              function r3(t4) {
                const e5 = t4.nodeBefore;
                if (e5 && e5.is("listItem")) {
                  let t5 = e5;
                  if (i3.has(t5))
                    return;
                  for (let e6 = t5.previousSibling; e6 && e6.is("listItem"); e6 = t5.previousSibling)
                    if (t5 = e6, i3.has(t5))
                      return;
                  i3.set(e5, t5);
                } else {
                  const e6 = t4.nodeAfter;
                  e6 && e6.is("listItem") && i3.set(e6, e6);
                }
              }
              function s2(t4) {
                let n4 = 0, i4 = null;
                for (; t4 && t4.is("listItem"); ) {
                  const r4 = t4.getAttribute("listIndent");
                  if (r4 > n4) {
                    let s3;
                    null === i4 ? (i4 = r4 - n4, s3 = n4) : (i4 > r4 && (i4 = r4), s3 = r4 - i4), e4.setAttribute("listIndent", s3, t4), o3 = true;
                  } else
                    i4 = null, n4 = t4.getAttribute("listIndent") + 1;
                  t4 = t4.nextSibling;
                }
              }
              function a2(t4) {
                let n4 = [], i4 = null;
                for (; t4 && t4.is("listItem"); ) {
                  const r4 = t4.getAttribute("listIndent");
                  if (i4 && i4.getAttribute("listIndent") > r4 && (n4 = n4.slice(0, r4 + 1)), 0 != r4)
                    if (n4[r4]) {
                      const i5 = n4[r4];
                      t4.getAttribute("listType") != i5 && (e4.setAttribute("listType", i5, t4), o3 = true);
                    } else
                      n4[r4] = t4.getAttribute("listType");
                  i4 = t4, t4 = t4.nextSibling;
                }
              }
            }(t2.model, e3)), n2.mapper.registerViewToModelLength("li", jm), e2.mapper.registerViewToModelLength("li", jm), n2.mapper.on("modelToViewPosition", Im(n2.view)), n2.mapper.on("viewToModelPosition", (i2 = t2.model, (t3, e3) => {
              const n3 = e3.viewPosition, o3 = n3.parent, r3 = e3.mapper;
              if ("ul" == o3.name || "ol" == o3.name) {
                if (n3.isAtEnd) {
                  const t4 = r3.toModelElement(n3.nodeBefore), o4 = r3.getModelLength(n3.nodeBefore);
                  e3.modelPosition = i2.createPositionBefore(t4).getShiftedBy(o4);
                } else {
                  const t4 = r3.toModelElement(n3.nodeAfter);
                  e3.modelPosition = i2.createPositionBefore(t4);
                }
                t3.stop();
              } else if ("li" == o3.name && n3.nodeBefore && ("ul" == n3.nodeBefore.name || "ol" == n3.nodeBefore.name)) {
                const s2 = r3.toModelElement(o3);
                let a2 = 1, c2 = n3.nodeBefore;
                for (; c2 && Dm(c2); )
                  a2 += r3.getModelLength(c2), c2 = c2.previousSibling;
                e3.modelPosition = i2.createPositionBefore(s2).getShiftedBy(a2), t3.stop();
              }
            })), e2.mapper.on("modelToViewPosition", Im(n2.view)), t2.conversion.for("editingDowncast").add((e3) => {
              e3.on("insert", Cm, { priority: "high" }), e3.on("insert:listItem", xm(t2.model)), e3.on("attribute:listType:listItem", Am, { priority: "high" }), e3.on("attribute:listType:listItem", Tm, { priority: "low" }), e3.on("attribute:listIndent:listItem", function(t3) {
                return (e4, n3, i3) => {
                  if (!i3.consumable.consume(n3.item, "attribute:listIndent"))
                    return;
                  const o3 = i3.mapper.toViewElement(n3.item), r3 = i3.writer;
                  r3.breakContainer(r3.createPositionBefore(o3)), r3.breakContainer(r3.createPositionAfter(o3));
                  const s2 = o3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2);
                  r3.remove(c2), a2 && a2.nextSibling && wm(r3, a2, a2.nextSibling), Rm(n3.attributeOldValue + 1, n3.range.start, c2.start, o3, i3, t3), bm(n3.item, o3, i3, t3);
                  for (const t4 of n3.item.getChildren())
                    i3.consumable.consume(t4, "insert");
                };
              }(t2.model)), e3.on("remove:listItem", function(t3) {
                return (e4, n3, i3) => {
                  const o3 = i3.mapper.toViewPosition(n3.position).getLastMatchingPosition((t4) => !t4.item.is("li")).nodeAfter, r3 = i3.writer;
                  r3.breakContainer(r3.createPositionBefore(o3)), r3.breakContainer(r3.createPositionAfter(o3));
                  const s2 = o3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2), l2 = r3.remove(c2);
                  a2 && a2.nextSibling && wm(r3, a2, a2.nextSibling), Rm(i3.mapper.toModelElement(o3).getAttribute("listIndent") + 1, n3.position, c2.start, o3, i3, t3);
                  for (const t4 of r3.createRangeIn(l2).getItems())
                    i3.mapper.unbindViewElement(t4);
                  e4.stop();
                };
              }(t2.model)), e3.on("remove", Pm, { priority: "low" });
            }), t2.conversion.for("dataDowncast").add((e3) => {
              e3.on("insert", Cm, { priority: "high" }), e3.on("insert:listItem", xm(t2.model));
            }), t2.conversion.for("upcast").add((t3) => {
              t3.on("element:ul", Mm, { priority: "high" }), t3.on("element:ol", Mm, { priority: "high" }), t3.on("element:li", Em, { priority: "high" }), t3.on("element:li", Sm);
            }), t2.model.on("insertContent", Nm, { priority: "high" }), t2.commands.add("numberedList", new hm(t2, "numbered")), t2.commands.add("bulletedList", new hm(t2, "bulleted")), t2.commands.add("indentList", new gm(t2, "forward")), t2.commands.add("outdentList", new gm(t2, "backward"));
            const o2 = n2.view.document;
            this.listenTo(o2, "enter", (t3, e3) => {
              const n3 = this.editor.model.document, i3 = n3.selection.getLastPosition().parent;
              n3.selection.isCollapsed && "listItem" == i3.name && i3.isEmpty && (this.editor.execute("outdentList"), e3.preventDefault(), t3.stop());
            }), this.listenTo(o2, "delete", (t3, e3) => {
              if ("backward" !== e3.direction)
                return;
              const n3 = this.editor.model.document.selection;
              if (!n3.isCollapsed)
                return;
              const i3 = n3.getFirstPosition();
              if (!i3.isAtStart)
                return;
              const o3 = i3.parent;
              "listItem" === o3.name && (o3.previousSibling && "listItem" === o3.previousSibling.name || (this.editor.execute("outdentList"), e3.preventDefault(), t3.stop()));
            }, { priority: "high" });
            const r2 = (t3) => (e3, n3) => {
              this.editor.commands.get(t3).isEnabled && (this.editor.execute(t3), n3());
            };
            t2.keystrokes.set("Tab", r2("indentList")), t2.keystrokes.set("Shift+Tab", r2("outdentList"));
          }
          afterInit() {
            const t2 = this.editor.commands, e2 = t2.get("indent"), n2 = t2.get("outdent");
            e2 && e2.registerChildCommand(t2.get("indentList")), n2 && n2.registerChildCommand(t2.get("outdentList"));
          }
        }
        function jm(t2) {
          let e2 = 1;
          for (const n2 of t2.getChildren())
            if ("ul" == n2.name || "ol" == n2.name)
              for (const t3 of n2.getChildren())
                e2 += jm(t3);
          return e2;
        }
        class Vm extends $l {
          init() {
            const t2 = this.editor.t;
            vm(this.editor, "numberedList", t2("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), vm(this.editor, "bulletedList", t2("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
          }
        }
        function zm(t2, e2) {
          return (t3) => {
            t3.on("attribute:url:media", n2);
          };
          function n2(n3, i2, o2) {
            if (!o2.consumable.consume(i2.item, n3.name))
              return;
            const r2 = i2.attributeNewValue, s2 = o2.writer, a2 = o2.mapper.toViewElement(i2.item);
            s2.remove(s2.createRangeIn(a2));
            const c2 = t2.getMediaViewElement(s2, r2, e2);
            s2.insert(s2.createPositionAt(a2, 0), c2);
          }
        }
        function Bm(t2, e2, n2, i2) {
          const o2 = t2.createContainerElement("figure", { class: "media" });
          return o2.getFillerOffset = Hm, t2.insert(t2.createPositionAt(o2, 0), e2.getMediaViewElement(t2, n2, i2)), o2;
        }
        function Fm(t2) {
          const e2 = t2.getSelectedElement();
          return e2 && e2.is("media") ? e2 : null;
        }
        function Um(t2, e2, n2) {
          t2.change((i2) => {
            const o2 = i2.createElement("media", { url: e2 });
            t2.insertContent(o2, n2), i2.setSelection(o2, "on");
          });
        }
        function Hm() {
          return null;
        }
        class qm extends td {
          refresh() {
            const t2 = this.editor.model, e2 = t2.document.selection, n2 = t2.schema, i2 = e2.getFirstPosition(), o2 = Fm(e2);
            let r2 = i2.parent;
            r2 != r2.root && (r2 = r2.parent), this.value = o2 ? o2.getAttribute("url") : null, this.isEnabled = n2.checkChild(r2, "media");
          }
          execute(t2) {
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = Fm(n2);
            if (i2)
              e2.change((e3) => {
                e3.setAttribute("url", t2, i2);
              });
            else {
              const i3 = Iu(n2, e2);
              Um(e2, t2, i3);
            }
          }
        }
        class Wm {
          constructor(t2, e2) {
            const n2 = e2.providers, i2 = e2.extraProviders || [], o2 = new Set(e2.removeProviders), r2 = n2.concat(i2).filter((t3) => {
              const e3 = t3.name;
              return e3 ? !o2.has(e3) : (console.warn(Object(hn.a)("media-embed-no-provider-name: The configured media provider has no name and cannot be used."), { provider: t3 }), false);
            });
            this.locale = t2, this.providerDefinitions = r2;
          }
          hasMedia(t2) {
            return !!this._getMedia(t2);
          }
          getMediaViewElement(t2, e2, n2) {
            return this._getMedia(e2).getViewElement(t2, n2);
          }
          _getMedia(t2) {
            if (!t2)
              return new Ym(this.locale);
            t2 = t2.trim();
            for (const e2 of this.providerDefinitions) {
              const n2 = e2.html;
              let i2 = e2.url;
              Array.isArray(i2) || (i2 = [i2]);
              for (const e3 of i2) {
                const i3 = this._getUrlMatches(t2, e3);
                if (i3)
                  return new Ym(this.locale, t2, i3, n2);
              }
            }
            return null;
          }
          _getUrlMatches(t2, e2) {
            let n2 = t2.match(e2);
            if (n2)
              return n2;
            let i2 = t2.replace(/^https?:\/\//, "");
            return n2 = i2.match(e2), n2 || (i2 = i2.replace(/^www\./, ""), n2 = i2.match(e2), n2 || null);
          }
        }
        class Ym {
          constructor(t2, e2, n2, i2) {
            this.url = this._getValidUrl(e2), this._t = t2.t, this._match = n2, this._previewRenderer = i2;
          }
          getViewElement(t2, e2) {
            const n2 = {};
            if (e2.renderForEditingView || e2.renderMediaPreview && this.url && this._previewRenderer) {
              this.url && (n2["data-oembed-url"] = this.url), e2.renderForEditingView && (n2.class = "ck-media__wrapper");
              const i2 = this._getPreviewHtml(e2);
              return t2.createUIElement("div", n2, function(t3) {
                const e3 = this.toDomElement(t3);
                return e3.innerHTML = i2, e3;
              });
            }
            return this.url && (n2.url = this.url), t2.createEmptyElement("oembed", n2);
          }
          _getPreviewHtml(t2) {
            return this._previewRenderer ? this._previewRenderer(this._match) : this.url && t2.renderForEditingView ? this._getPlaceholderHtml() : "";
          }
          _getPlaceholderHtml() {
            const t2 = new Il(), e2 = new El();
            return t2.text = this._t("Open media in new tab"), e2.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', e2.viewBox = "0 0 64 42", new Hc({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [e2] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }, t2] }] }).render().outerHTML;
          }
          _getValidUrl(t2) {
            return t2 ? t2.match(/^https?/) ? t2 : "https://" + t2 : null;
          }
        }
        n(78);
        class Gm extends $l {
          static get pluginName() {
            return "MediaEmbedEditing";
          }
          constructor(t2) {
            super(t2), t2.config.define("mediaEmbed", { providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: (t3) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (t3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)/, /^youtube\.com\/embed\/([\w-]+)/, /^youtu\.be\/([\w-]+)/], html: (t3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${t3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>` }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (t3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: /^google\.com\/maps/ }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new Wm(t2.locale, t2.config.get("mediaEmbed"));
          }
          init() {
            const t2 = this.editor, e2 = t2.model.schema, n2 = t2.t, i2 = t2.conversion, o2 = t2.config.get("mediaEmbed.previewsInData"), r2 = this.registry;
            t2.commands.add("mediaEmbed", new qm(t2)), e2.register("media", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["url"] }), i2.for("dataDowncast").elementToElement({ model: "media", view: (t3, e3) => {
              const n3 = t3.getAttribute("url");
              return Bm(e3, r2, n3, { renderMediaPreview: n3 && o2 });
            } }), i2.for("dataDowncast").add(zm(r2, { renderMediaPreview: o2 })), i2.for("editingDowncast").elementToElement({ model: "media", view: (t3, e3) => {
              const i3 = t3.getAttribute("url"), o3 = Bm(e3, r2, i3, { renderForEditingView: true });
              return s2 = o3, a2 = e3, c2 = n2("media widget"), a2.setCustomProperty("media", true, s2), Su(s2, a2, { label: c2 });
              var s2, a2, c2;
            } }), i2.for("editingDowncast").add(zm(r2, { renderForEditingView: true })), i2.for("upcast").elementToElement({ view: { name: "oembed", attributes: { url: true } }, model: (t3, e3) => {
              const n3 = t3.getAttribute("url");
              if (r2.hasMedia(n3))
                return e3.createElement("media", { url: n3 });
            } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t3, e3) => {
              const n3 = t3.getAttribute("data-oembed-url");
              if (r2.hasMedia(n3))
                return e3.createElement("media", { url: n3 });
            } });
          }
        }
        const $m = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:/?#[\]@!$&'()*+,;=]+$/;
        class Qm extends $l {
          static get requires() {
            return [Xl, Qd];
          }
          static get pluginName() {
            return "AutoMediaEmbed";
          }
          constructor(t2) {
            super(t2), this._timeoutId = null, this._positionToInsert = null;
          }
          init() {
            const t2 = this.editor, e2 = t2.model.document;
            this.listenTo(t2.plugins.get(Xl), "inputTransformation", () => {
              const t3 = e2.selection.getFirstRange(), n2 = ac.fromPosition(t3.start);
              n2.stickiness = "toPrevious";
              const i2 = ac.fromPosition(t3.end);
              i2.stickiness = "toNext", e2.once("change:data", () => {
                this._embedMediaBetweenPositions(n2, i2), n2.detach(), i2.detach();
              }, { priority: "high" });
            }), t2.commands.get("undo").on("execute", () => {
              this._timeoutId && (Xo.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
            }, { priority: "high" });
          }
          _embedMediaBetweenPositions(t2, e2) {
            const n2 = this.editor, i2 = n2.plugins.get(Gm).registry, o2 = new Rs(t2, e2), r2 = o2.getWalker({ ignoreElementEnd: true });
            let s2 = "";
            for (const t3 of r2)
              t3.item.is("textProxy") && (s2 += t3.item.data);
            if (s2 = s2.trim(), !s2.match($m))
              return;
            if (!i2.hasMedia(s2))
              return;
            n2.commands.get("mediaEmbed").isEnabled && (this._positionToInsert = ac.fromPosition(t2), this._timeoutId = Xo.window.setTimeout(() => {
              n2.model.change((t3) => {
                let e3;
                this._timeoutId = null, t3.remove(o2), "$graveyard" !== this._positionToInsert.root.rootName && (e3 = this._positionToInsert), Um(n2.model, s2, e3), this._positionToInsert.detach(), this._positionToInsert = null;
              });
            }, 100));
          }
        }
        n(80);
        class Km extends cl {
          constructor(t2, e2) {
            super(e2);
            const n2 = e2.t;
            this.focusTracker = new Oc(), this.keystrokes = new Ac(), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n2("Save"), qh, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n2("Cancel"), Wh, "ck-button-cancel", "cancel"), this._focusables = new Uc(), this._focusCycler = new kl({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this._validators = t2, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] });
          }
          render() {
            super.render(), Hh({ view: this }), [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((t3) => {
              this._focusables.add(t3), this.focusTracker.add(t3.element);
            }), this.keystrokes.listenTo(this.element);
            const t2 = (t3) => t3.stopPropagation();
            this.keystrokes.set("arrowright", t2), this.keystrokes.set("arrowleft", t2), this.keystrokes.set("arrowup", t2), this.keystrokes.set("arrowdown", t2), this.listenTo(this.urlInputView.element, "selectstart", (t3, e2) => {
              e2.stopPropagation();
            }, { priority: "high" });
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          get url() {
            return this.urlInputView.fieldView.element.value.trim();
          }
          set url(t2) {
            this.urlInputView.fieldView.element.value = t2.trim();
          }
          isValid() {
            this.resetFormStatus();
            for (const t2 of this._validators) {
              const e2 = t2(this);
              if (e2)
                return this.urlInputView.errorText = e2, false;
            }
            return true;
          }
          resetFormStatus() {
            this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
          }
          _createUrlInput() {
            const t2 = this.locale.t, e2 = new Bh(this.locale, Uh), n2 = e2.fieldView;
            return this._urlInputViewInfoDefault = t2("Paste the media URL in the input."), this._urlInputViewInfoTip = t2("Tip: Paste the URL into the content to embed faster."), e2.label = t2("Media URL"), e2.infoText = this._urlInputViewInfoDefault, n2.placeholder = "https://example.com", n2.on("input", () => {
              e2.infoText = n2.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
            }), e2;
          }
          _createButton(t2, e2, n2, i2) {
            const o2 = new Nl(this.locale);
            return o2.set({ label: t2, icon: e2, tooltip: true }), o2.extendTemplate({ attributes: { class: n2 } }), i2 && o2.delegate("execute").to(this, i2), o2;
          }
        }
        class Jm extends $l {
          static get requires() {
            return [Gm];
          }
          static get pluginName() {
            return "MediaEmbedUI";
          }
          init() {
            const t2 = this.editor, e2 = t2.commands.get("mediaEmbed"), n2 = t2.plugins.get(Gm).registry;
            this.form = new Km(function(t3, e3) {
              return [(e4) => {
                if (!e4.url.length)
                  return t3("The URL must not be empty.");
              }, (n3) => {
                if (!e3.hasMedia(n3.url))
                  return t3("This media URL is not supported.");
              }];
            }(t2.t, n2), t2.locale), t2.ui.componentFactory.add("mediaEmbed", (n3) => {
              const i2 = Bl(n3);
              return this._setUpDropdown(i2, this.form, e2, t2), this._setUpForm(this.form, i2, e2), i2;
            });
          }
          _setUpDropdown(t2, e2, n2) {
            const i2 = this.editor, o2 = i2.t, r2 = t2.buttonView;
            function s2() {
              i2.editing.view.focus(), t2.isOpen = false;
            }
            t2.bind("isEnabled").to(n2), t2.panelView.children.add(e2), r2.set({ label: o2("Insert media"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 01.593-.351l5.133 2.824a.4.4 0 010 .7l-5.133 2.824a.4.4 0 01-.593-.35V7.176v.001z"/></svg>\n', tooltip: true }), r2.on("open", () => {
              e2.url = n2.value || "", e2.urlInputView.fieldView.select(), e2.focus();
            }, { priority: "low" }), t2.on("submit", () => {
              e2.isValid() && (i2.execute("mediaEmbed", e2.url), s2());
            }), t2.on("change:isOpen", () => e2.resetFormStatus()), t2.on("cancel", () => s2());
          }
          _setUpForm(t2, e2, n2) {
            t2.delegate("submit", "cancel").to(e2), t2.urlInputView.bind("value").to(n2, "value"), t2.urlInputView.bind("isReadOnly").to(n2, "isEnabled", (t3) => !t3), t2.saveButtonView.bind("isEnabled").to(n2);
          }
        }
        n(82);
        function Zm(t2, e2) {
          if (!t2.childCount)
            return;
          const n2 = new wf(t2.document), i2 = function(t3, e3) {
            const n3 = e3.createRangeIn(t3), i3 = new jn({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }), o3 = [];
            for (const t4 of n3)
              if ("elementStart" === t4.type && i3.match(t4.item)) {
                const e4 = tg(t4.item);
                o3.push({ element: t4.item, id: e4.id, order: e4.order, indent: e4.indent });
              }
            return o3;
          }(t2, n2);
          if (!i2.length)
            return;
          let o2 = null, r2 = 1;
          i2.forEach((t3, s2) => {
            const a2 = function(t4, e3) {
              if (!t4)
                return true;
              if (t4.id !== e3.id)
                return true;
              const n3 = e3.element.previousSibling;
              if (!n3)
                return true;
              return i3 = n3, !(i3.is("ol") || i3.is("ul"));
              var i3;
            }(i2[s2 - 1], t3), c2 = a2 ? null : i2[s2 - 1], l2 = (u2 = t3, (d2 = c2) ? u2.indent - d2.indent : u2.indent - 1);
            var d2, u2;
            if (a2 && (o2 = null, r2 = 1), !o2 || 0 !== l2) {
              const i3 = function(t4, e3) {
                const n3 = new RegExp(`@list l${t4.id}:level${t4.indent}\\s*({[^}]*)`, "gi"), i4 = /mso-level-number-format:([^;]*);/gi, o3 = n3.exec(e3);
                let r3 = "decimal";
                if (o3 && o3[1]) {
                  const t5 = i4.exec(o3[1]);
                  t5 && t5[1] && (r3 = t5[1].trim());
                }
                return { type: "bullet" !== r3 && "image" !== r3 ? "ol" : "ul", style: r3 };
              }(t3, e2);
              if (o2) {
                if (t3.indent > r2) {
                  const t4 = o2.getChild(o2.childCount - 1), e3 = t4.getChild(t4.childCount - 1);
                  o2 = Xm(i3, e3, n2), r2 += 1;
                } else if (t3.indent < r2) {
                  const e3 = r2 - t3.indent;
                  o2 = function(t4, e4) {
                    const n3 = t4.getAncestors({ parentFirst: true });
                    let i4 = null, o3 = 0;
                    for (const t5 of n3)
                      if ("ul" !== t5.name && "ol" !== t5.name || o3++, o3 === e4) {
                        i4 = t5;
                        break;
                      }
                    return i4;
                  }(o2, e3), r2 = parseInt(t3.indent);
                }
              } else
                o2 = Xm(i3, t3.element, n2);
              t3.indent <= r2 && (o2.is(i3.type) || (o2 = n2.rename(i3.type, o2)));
            }
            const h2 = function(t4, e3) {
              return function(t5, e4) {
                const n3 = new jn({ name: "span", styles: { "mso-list": "Ignore" } }), i3 = e4.createRangeIn(t5);
                for (const t6 of i3)
                  "elementStart" === t6.type && n3.match(t6.item) && e4.remove(t6.item);
              }(t4, e3), e3.rename("li", t4);
            }(t3.element, n2);
            n2.appendChild(h2, o2);
          });
        }
        function Xm(t2, e2, n2) {
          const i2 = e2.parent, o2 = n2.createElement(t2.type), r2 = i2.getChildIndex(e2) + 1;
          return n2.insertChild(r2, o2, i2), o2;
        }
        function tg(t2) {
          const e2 = {}, n2 = t2.getStyle("mso-list");
          if (n2) {
            const t3 = n2.match(/(^|\s+)l(\d+)/i), i2 = n2.match(/\s*lfo(\d+)/i), o2 = n2.match(/\s*level(\d+)/i);
            t3 && i2 && o2 && (e2.id = t3[2], e2.order = i2[1], e2.indent = o2[1]);
          }
          return e2;
        }
        const eg = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
        class ng {
          constructor(t2) {
            this.document = t2;
          }
          isActive(t2) {
            return eg.test(t2);
          }
          execute(t2) {
            const e2 = new wf(this.document);
            !function(t3, e3) {
              for (const n2 of t3.getChildren())
                if (n2.is("b") && "normal" === n2.getStyle("font-weight")) {
                  const i2 = t3.getChildIndex(n2);
                  e3.remove(n2), e3.insertChild(i2, n2.getChildren(), t3);
                }
            }(t2.content, e2), function(t3, e3) {
              for (const n2 of e3.createRangeIn(t3)) {
                const t4 = n2.item;
                if (t4.is("li")) {
                  const n3 = t4.getChild(0);
                  n3.is("p") && e3.unwrapElement(n3);
                }
              }
            }(t2.content, e2);
          }
        }
        function ig(t2) {
          return t2.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t3, e2) => 1 === e2.length ? " " : Array(e2.length + 1).join("\xA0 ").substr(0, e2.length));
        }
        function og(t2) {
          const e2 = new DOMParser(), n2 = function(t3) {
            return ig(ig(t3)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[\s]*?)[\r\n]+(\s*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, "\xA0</").replace(/ <o:p><\/o:p>/g, "\xA0<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>(\s*[\r\n]\s*)</g, "><");
          }(function(t3) {
            const e3 = t3.match(/<\/body>(.*?)(<\/html>|$)/);
            e3 && e3[1] && (t3 = t3.slice(0, e3.index) + t3.slice(e3.index).replace(e3[1], ""));
            return t3;
          }(t2 = t2.replace(/<!--\[if gte vml 1]>/g, ""))), i2 = e2.parseFromString(n2, "text/html");
          !function(t3) {
            t3.querySelectorAll("span[style*=spacerun]").forEach((t4) => {
              const e3 = t4.innerText.length || 0;
              t4.innerHTML = Array(e3 + 1).join("\xA0 ").substr(0, e3);
            });
          }(i2);
          const o2 = i2.body.innerHTML, r2 = function(t3) {
            const e3 = new oo(new Ei()), n3 = new ir(e3, { blockFillerMode: "nbsp" }), i3 = t3.createDocumentFragment(), o3 = t3.body.childNodes;
            for (; o3.length > 0; )
              i3.appendChild(o3[0]);
            return n3.domToView(i3);
          }(i2), s2 = function(t3) {
            const e3 = [], n3 = [], i3 = Array.from(t3.getElementsByTagName("style"));
            for (const t4 of i3)
              t4.sheet && t4.sheet.cssRules && t4.sheet.cssRules.length && (e3.push(t4.sheet), n3.push(t4.innerHTML));
            return { styles: e3, stylesString: n3.join(" ") };
          }(i2);
          return { body: r2, bodyString: o2, styles: s2.styles, stylesString: s2.stylesString };
        }
        function rg(t2, e2) {
          if (!t2.childCount)
            return;
          const n2 = new wf();
          !function(t3, e3, n3) {
            const i3 = n3.createRangeIn(e3), o2 = new jn({ name: "img" }), r2 = [];
            for (const e4 of i3)
              if (o2.match(e4.item)) {
                const n4 = e4.item, i4 = n4.getAttribute("v:shapes") ? n4.getAttribute("v:shapes").split(" ") : [];
                i4.length && i4.every((e5) => t3.indexOf(e5) > -1) ? r2.push(n4) : n4.getAttribute("src") || r2.push(n4);
              }
            for (const t4 of r2)
              n3.remove(t4);
          }(function(t3, e3) {
            const n3 = e3.createRangeIn(t3), i3 = new jn({ name: /v:(.+)/ }), o2 = [];
            for (const t4 of n3) {
              const e4 = t4.item, n4 = e4.previousSibling && e4.previousSibling.name || null;
              i3.match(e4) && e4.getAttribute("o:gfxdata") && "v:shapetype" !== n4 && o2.push(t4.item.getAttribute("id"));
            }
            return o2;
          }(t2, n2), t2, n2), function(t3, e3) {
            const n3 = e3.createRangeIn(t3), i3 = new jn({ name: /v:(.+)/ }), o2 = [];
            for (const t4 of n3)
              i3.match(t4.item) && o2.push(t4.item);
            for (const t4 of o2)
              e3.remove(t4);
          }(t2, n2);
          const i2 = function(t3, e3) {
            const n3 = e3.createRangeIn(t3), i3 = new jn({ name: "img" }), o2 = [];
            for (const t4 of n3)
              i3.match(t4.item) && t4.item.getAttribute("src").startsWith("file://") && o2.push(t4.item);
            return o2;
          }(t2, n2);
          i2.length && function(t3, e3, n3) {
            if (t3.length === e3.length)
              for (let o2 = 0; o2 < t3.length; o2++) {
                const r2 = `data:${e3[o2].type};base64,${i3 = e3[o2].hex, btoa(i3.match(/\w{2}/g).map((t4) => String.fromCharCode(parseInt(t4, 16))).join(""))}`;
                n3.setAttribute("src", r2, t3[o2]);
              }
            var i3;
          }(i2, function(t3) {
            if (!t3)
              return [];
            const e3 = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, n3 = new RegExp("(?:(" + e3.source + "))([\\da-fA-F\\s]+)\\}", "g"), i3 = t3.match(n3), o2 = [];
            if (i3)
              for (const t4 of i3) {
                let n4 = false;
                t4.includes("\\pngblip") ? n4 = "image/png" : t4.includes("\\jpegblip") && (n4 = "image/jpeg"), n4 && o2.push({ hex: t4.replace(e3, "").replace(/[^\da-fA-F]/g, ""), type: n4 });
              }
            return o2;
          }(e2), n2);
        }
        const sg = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, ag = /xmlns:o="urn:schemas-microsoft-com/i;
        class cg {
          isActive(t2) {
            return sg.test(t2) || ag.test(t2);
          }
          execute(t2) {
            const { body: e2, stylesString: n2 } = og(t2.dataTransfer.getData("text/html"));
            Zm(e2, n2), rg(e2, t2.dataTransfer.getData("text/rtf")), t2.content = e2;
          }
        }
        function lg(t2, e2) {
          let n2 = e2.parent;
          for (; n2; ) {
            if (n2.name === t2)
              return n2;
            n2 = n2.parent;
          }
        }
        function dg(t2, e2, n2, i2, o2 = 1) {
          e2 > o2 ? i2.setAttribute(t2, e2, n2) : i2.removeAttribute(t2, n2);
        }
        function ug(t2, e2, n2 = {}) {
          const i2 = t2.createElement("tableCell", n2);
          t2.insertElement("paragraph", i2), t2.insert(i2, e2);
        }
        function hg(t2, e2) {
          const n2 = e2.parent.parent, i2 = parseInt(n2.getAttribute("headingColumns") || 0), { column: o2 } = t2.getCellLocation(e2);
          return !!i2 && o2 < i2;
        }
        function fg() {
          return (t2) => {
            t2.on("element:table", (t3, e2, n2) => {
              const i2 = e2.viewItem;
              if (!n2.consumable.test(i2, { name: true }))
                return;
              const { rows: o2, headingRows: r2, headingColumns: s2 } = function(t4) {
                const e3 = { headingRows: 0, headingColumns: 0 }, n3 = [], i3 = [];
                let o3;
                for (const r3 of Array.from(t4.getChildren()))
                  if ("tbody" === r3.name || "thead" === r3.name || "tfoot" === r3.name) {
                    "thead" !== r3.name || o3 || (o3 = r3);
                    const t5 = Array.from(r3.getChildren()).filter((t6) => t6.is("element", "tr"));
                    for (const r4 of t5)
                      if ("thead" === r4.parent.name && r4.parent === o3)
                        e3.headingRows++, n3.push(r4);
                      else {
                        i3.push(r4);
                        const t6 = gg(r4);
                        t6 > e3.headingColumns && (e3.headingColumns = t6);
                      }
                  }
                return e3.rows = [...n3, ...i3], e3;
              }(i2), a2 = {};
              s2 && (a2.headingColumns = s2), r2 && (a2.headingRows = r2);
              const c2 = n2.writer.createElement("table", a2), l2 = n2.splitToAllowedParent(c2, e2.modelCursor);
              if (l2) {
                if (n2.writer.insert(c2, l2.position), n2.consumable.consume(i2, { name: true }), o2.length)
                  o2.forEach((t4) => n2.convertItem(t4, n2.writer.createPositionAt(c2, "end")));
                else {
                  const t4 = n2.writer.createElement("tableRow");
                  n2.writer.insert(t4, n2.writer.createPositionAt(c2, "end")), ug(n2.writer, n2.writer.createPositionAt(t4, "end"));
                }
                e2.modelRange = n2.writer.createRange(n2.writer.createPositionBefore(c2), n2.writer.createPositionAfter(c2)), l2.cursorParent ? e2.modelCursor = n2.writer.createPositionAt(l2.cursorParent, 0) : e2.modelCursor = e2.modelRange.end;
              }
            });
          };
        }
        function mg(t2) {
          return (e2) => {
            e2.on("element:" + t2, (t3, e3, n2) => {
              const i2 = e3.viewItem;
              if (!n2.consumable.test(i2, { name: true }))
                return;
              const o2 = n2.writer.createElement("tableCell"), r2 = n2.splitToAllowedParent(o2, e3.modelCursor);
              if (!r2)
                return;
              n2.writer.insert(o2, r2.position), n2.consumable.consume(i2, { name: true });
              const s2 = n2.writer.createPositionAt(o2, 0);
              n2.convertChildren(i2, s2), o2.childCount || n2.writer.insertElement("paragraph", s2), e3.modelRange = n2.writer.createRange(n2.writer.createPositionBefore(o2), n2.writer.createPositionAfter(o2)), e3.modelCursor = e3.modelRange.end;
            });
          };
        }
        function gg(t2) {
          let e2 = 0, n2 = 0;
          const i2 = Array.from(t2.getChildren()).filter((t3) => "th" === t3.name || "td" === t3.name);
          for (; n2 < i2.length && "th" === i2[n2].name; ) {
            const t3 = i2[n2];
            e2 += parseInt(t3.getAttribute("colspan") || 1), n2++;
          }
          return e2;
        }
        class pg {
          constructor(t2, e2 = {}) {
            this.table = t2, this.startRow = e2.startRow || 0, this.endRow = "number" == typeof e2.endRow ? e2.endRow : void 0, this.includeSpanned = !!e2.includeSpanned, this.column = "number" == typeof e2.column ? e2.column : void 0, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            const t2 = this.table.getChild(this._row);
            if (!t2 || this._isOverEndRow())
              return { done: true };
            let e2, n2, i2;
            if (this._isSpanned(this._row, this._column))
              e2 = this._getSpanned(this._row, this._column), n2 = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn(), i2 = this._formatOutValue(e2, this._column, true);
            else {
              if (e2 = t2.getChild(this._cellIndex), !e2)
                return this._row++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
              const o2 = parseInt(e2.getAttribute("colspan") || 1), r2 = parseInt(e2.getAttribute("rowspan") || 1);
              (o2 > 1 || r2 > 1) && this._recordSpans(this._row, this._column, r2, o2, e2), this._nextCellAtColumn = this._column + o2, n2 = this._shouldSkipRow() || this._shouldSkipColumn(), i2 = this._formatOutValue(e2, this._column, false, r2, o2);
            }
            return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, n2 ? this.next() : i2;
          }
          skipRow(t2) {
            this._skipRows.add(t2);
          }
          _isOverEndRow() {
            return void 0 !== this.endRow && this._row > this.endRow;
          }
          _formatOutValue(t2, e2, n2, i2 = 1, o2 = 1) {
            return { done: false, value: { cell: t2, row: this._row, column: e2, isSpanned: n2, rowspan: i2, colspan: o2, cellIndex: this._cellIndex } };
          }
          _shouldSkipRow() {
            const t2 = this._row < this.startRow, e2 = this._skipRows.has(this._row);
            return t2 || e2;
          }
          _shouldSkipColumn() {
            return void 0 !== this.column && this.column != this._column;
          }
          _isSpanned(t2, e2) {
            if (!this._spannedCells.has(t2))
              return false;
            return this._spannedCells.get(t2).has(e2);
          }
          _getSpanned(t2, e2) {
            return this._spannedCells.get(t2).get(e2);
          }
          _recordSpans(t2, e2, n2, i2, o2) {
            for (let n3 = e2 + 1; n3 <= e2 + i2 - 1; n3++)
              this._markSpannedCell(t2, n3, o2);
            for (let r2 = t2 + 1; r2 < t2 + n2; r2++)
              for (let t3 = e2; t3 <= e2 + i2 - 1; t3++)
                this._markSpannedCell(r2, t3, o2);
          }
          _markSpannedCell(t2, e2, n2) {
            this._spannedCells.has(t2) || this._spannedCells.set(t2, /* @__PURE__ */ new Map()), this._spannedCells.get(t2).set(e2, n2);
          }
        }
        function bg(t2) {
          return !!t2.getCustomProperty("table") && Pu(t2);
        }
        function wg(t2) {
          const e2 = t2.getSelectedElement();
          return e2 && bg(e2) ? e2 : null;
        }
        function kg(t2) {
          const e2 = lg("table", t2.getFirstPosition());
          return e2 && bg(e2.parent) ? e2.parent : null;
        }
        function _g(t2) {
          const e2 = [];
          for (const i2 of (n2 = t2.getRanges(), Array.from(n2).sort(Cg))) {
            const t3 = i2.getContainedElement();
            t3 && t3.is("tableCell") && e2.push(t3);
          }
          var n2;
          return e2;
        }
        function vg(t2) {
          const e2 = [];
          for (const n2 of t2.getRanges()) {
            const t3 = lg("tableCell", n2.start);
            t3 && e2.push(t3);
          }
          return e2;
        }
        function yg(t2) {
          const e2 = _g(t2);
          return e2.length ? e2 : vg(t2);
        }
        function xg(t2) {
          return Tg(t2.map((t3) => t3.parent.index));
        }
        function Ag(t2) {
          const e2 = lg("table", t2[0]);
          return Tg([...new pg(e2)].filter((e3) => t2.includes(e3.cell)).map((t3) => t3.column));
        }
        function Tg(t2) {
          const e2 = t2.sort((t3, e3) => t3 - e3);
          return { first: e2[0], last: e2[e2.length - 1] };
        }
        function Cg(t2, e2) {
          const n2 = t2.start, i2 = e2.start;
          return n2.isBefore(i2) ? -1 : 1;
        }
        function Pg(t2 = {}) {
          return (e2) => e2.on("insert:table", (e3, n2, i2) => {
            const o2 = n2.item;
            if (!i2.consumable.consume(o2, "insert"))
              return;
            i2.consumable.consume(o2, "attribute:headingRows:table"), i2.consumable.consume(o2, "attribute:headingColumns:table");
            const r2 = t2 && t2.asWidget, s2 = i2.writer.createContainerElement("figure", { class: "table" }), a2 = i2.writer.createContainerElement("table");
            let c2;
            var l2, d2;
            i2.writer.insert(i2.writer.createPositionAt(s2, 0), a2), r2 && (l2 = s2, (d2 = i2.writer).setCustomProperty("table", true, l2), c2 = Su(l2, d2, { hasSelectionHandle: true }));
            const u2 = new pg(o2), h2 = { headingRows: o2.getAttribute("headingRows") || 0, headingColumns: o2.getAttribute("headingColumns") || 0 }, f2 = /* @__PURE__ */ new Map();
            for (const e4 of u2) {
              const { row: n3, cell: r3 } = e4, s3 = Vg(jg(n3, h2), a2, i2), c3 = o2.getChild(n3), l3 = f2.get(n3) || Dg(c3, n3, s3, i2);
              f2.set(n3, l3), i2.consumable.consume(r3, "insert"), Rg(e4, h2, i2.writer.createPositionAt(l3, "end"), i2, t2);
            }
            const m2 = i2.mapper.toViewPosition(n2.range.start);
            i2.mapper.bindElements(o2, r2 ? c2 : s2), i2.writer.insert(m2, r2 ? c2 : s2);
          });
        }
        function Sg(t2 = {}) {
          return (e2) => e2.on("insert:tableRow", (e3, n2, i2) => {
            const o2 = n2.item;
            if (!i2.consumable.consume(o2, "insert"))
              return;
            const r2 = o2.parent, s2 = Ug(i2.mapper.toViewElement(r2)), a2 = r2.getChildIndex(o2), c2 = new pg(r2, { startRow: a2, endRow: a2 }), l2 = { headingRows: r2.getAttribute("headingRows") || 0, headingColumns: r2.getAttribute("headingColumns") || 0 }, d2 = /* @__PURE__ */ new Map();
            for (const e4 of c2) {
              const n3 = Vg(jg(a2, l2), s2, i2), r3 = d2.get(a2) || Dg(o2, a2, n3, i2);
              d2.set(a2, r3), i2.consumable.consume(e4.cell, "insert"), Rg(e4, l2, i2.writer.createPositionAt(r3, "end"), i2, t2);
            }
          });
        }
        function Mg(t2 = {}) {
          return (e2) => e2.on("insert:tableCell", (e3, n2, i2) => {
            const o2 = n2.item;
            if (!i2.consumable.consume(o2, "insert"))
              return;
            const r2 = o2.parent, s2 = r2.parent, a2 = s2.getChildIndex(r2), c2 = new pg(s2, { startRow: a2, endRow: a2 }), l2 = { headingRows: s2.getAttribute("headingRows") || 0, headingColumns: s2.getAttribute("headingColumns") || 0 };
            for (const e4 of c2)
              if (e4.cell === o2) {
                const n3 = i2.mapper.toViewElement(r2);
                return void Rg(e4, l2, i2.writer.createPositionAt(n3, r2.getChildIndex(o2)), i2, t2);
              }
          });
        }
        function Eg(t2 = {}) {
          const e2 = !!t2.asWidget;
          return (t3) => t3.on("attribute:headingRows:table", (t4, n2, i2) => {
            const o2 = n2.item;
            if (!i2.consumable.consume(n2.item, t4.name))
              return;
            const r2 = Ug(i2.mapper.toViewElement(o2)), s2 = n2.attributeOldValue, a2 = n2.attributeNewValue;
            if (a2 > s2) {
              const t5 = Array.from(o2.getChildren()).filter(({ index: t6 }) => c2(t6, s2 - 1, a2));
              Fg(t5, Vg("thead", r2, i2), i2, "end");
              for (const n3 of t5)
                for (const t6 of n3.getChildren())
                  Ng(t6, "th", i2, e2);
            } else {
              Fg(Array.from(o2.getChildren()).filter(({ index: t6 }) => c2(t6, a2 - 1, s2)).reverse(), Vg("tbody", r2, i2), i2, 0);
              const t5 = new pg(o2, { startRow: a2 ? a2 - 1 : a2, endRow: s2 - 1 }), n3 = { headingRows: o2.getAttribute("headingRows") || 0, headingColumns: o2.getAttribute("headingColumns") || 0 };
              for (const o3 of t5)
                Og(o3, n3, i2, e2);
            }
            function c2(t5, e3, n3) {
              return t5 > e3 && t5 < n3;
            }
            Bg("thead", r2, i2), Bg("tbody", r2, i2);
          });
        }
        function Ig(t2 = {}) {
          const e2 = !!t2.asWidget;
          return (t3) => t3.on("attribute:headingColumns:table", (t4, n2, i2) => {
            const o2 = n2.item;
            if (!i2.consumable.consume(n2.item, t4.name))
              return;
            const r2 = { headingRows: o2.getAttribute("headingRows") || 0, headingColumns: o2.getAttribute("headingColumns") || 0 }, s2 = n2.attributeOldValue, a2 = n2.attributeNewValue, c2 = (s2 > a2 ? s2 : a2) - 1;
            for (const t5 of new pg(o2))
              t5.column > c2 || Og(t5, r2, i2, e2);
          });
        }
        function Ng(t2, e2, n2, i2) {
          const o2 = n2.writer, r2 = n2.mapper.toViewElement(t2);
          if (!r2)
            return;
          let s2;
          if (i2) {
            s2 = Eu(o2.createEditableElement(e2, r2.getAttributes()), o2), o2.insert(o2.createPositionAfter(r2), s2), o2.move(o2.createRangeIn(r2), o2.createPositionAt(s2, 0)), o2.remove(o2.createRangeOn(r2));
          } else
            s2 = o2.rename(e2, r2);
          n2.mapper.unbindViewElement(r2), n2.mapper.bindElements(t2, s2);
        }
        function Og(t2, e2, n2, i2) {
          const { cell: o2 } = t2, r2 = Lg(t2, e2), s2 = n2.mapper.toViewElement(o2);
          s2 && s2.name !== r2 && Ng(o2, r2, n2, i2);
        }
        function Rg(t2, e2, n2, i2, o2) {
          const r2 = o2 && o2.asWidget, s2 = Lg(t2, e2), a2 = r2 ? Eu(i2.writer.createEditableElement(s2), i2.writer) : i2.writer.createContainerElement(s2), c2 = t2.cell, l2 = c2.getChild(0), d2 = 1 === c2.childCount && "paragraph" === l2.name;
          if (i2.writer.insert(n2, a2), d2 && ![...l2.getAttributeKeys()].length) {
            const t3 = c2.getChild(0), e3 = i2.writer.createPositionAt(a2, "end");
            if (i2.consumable.consume(t3, "insert"), o2.asWidget) {
              const n3 = i2.writer.createContainerElement("span", { style: "display:inline-block" });
              i2.mapper.bindElements(t3, n3), i2.writer.insert(e3, n3), i2.mapper.bindElements(c2, a2);
            } else
              i2.mapper.bindElements(c2, a2), i2.mapper.bindElements(t3, a2);
          } else
            i2.mapper.bindElements(c2, a2);
        }
        function Dg(t2, e2, n2, i2) {
          i2.consumable.consume(t2, "insert");
          const o2 = i2.writer.createContainerElement("tr");
          i2.mapper.bindElements(t2, o2);
          const r2 = t2.parent.getAttribute("headingRows") || 0, s2 = r2 > 0 && e2 >= r2 ? e2 - r2 : e2, a2 = i2.writer.createPositionAt(n2, s2);
          return i2.writer.insert(a2, o2), o2;
        }
        function Lg(t2, e2) {
          const { row: n2, column: i2 } = t2, { headingColumns: o2, headingRows: r2 } = e2;
          return r2 && r2 > n2 || o2 && o2 > i2 ? "th" : "td";
        }
        function jg(t2, e2) {
          return t2 < e2.headingRows ? "thead" : "tbody";
        }
        function Vg(t2, e2, n2) {
          const i2 = zg(t2, e2);
          return i2 || function(t3, e3, n3) {
            const i3 = n3.writer.createContainerElement(t3), o2 = n3.writer.createPositionAt(e3, "tbody" == t3 ? "end" : 0);
            return n3.writer.insert(o2, i3), i3;
          }(t2, e2, n2);
        }
        function zg(t2, e2) {
          for (const n2 of e2.getChildren())
            if (n2.name == t2)
              return n2;
        }
        function Bg(t2, e2, n2) {
          const i2 = zg(t2, e2);
          i2 && 0 === i2.childCount && n2.writer.remove(n2.writer.createRangeOn(i2));
        }
        function Fg(t2, e2, n2, i2) {
          for (const o2 of t2) {
            const t3 = n2.mapper.toViewElement(o2);
            t3 && n2.writer.move(n2.writer.createRangeOn(t3), n2.writer.createPositionAt(e2, i2));
          }
        }
        function Ug(t2) {
          for (const e2 of t2.getChildren())
            if ("table" === e2.name)
              return e2;
        }
        class Hg extends td {
          refresh() {
            const t2 = this.editor.model, e2 = t2.document.selection, n2 = t2.schema, i2 = function(t3) {
              const e3 = t3.parent;
              return e3 === e3.root ? e3 : e3.parent;
            }(e2.getFirstPosition());
            this.isEnabled = n2.checkChild(i2, "table");
          }
          execute(t2 = {}) {
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = this.editor.plugins.get("TableUtils"), o2 = parseInt(t2.rows) || 2, r2 = parseInt(t2.columns) || 2, s2 = Iu(n2, e2);
            e2.change((t3) => {
              const n3 = i2.createTable(t3, o2, r2);
              e2.insertContent(n3, s2), t3.setSelection(t3.createPositionAt(n3.getNodeByPath([0, 0, 0]), 0));
            });
          }
        }
        class qg extends td {
          constructor(t2, e2 = {}) {
            super(t2), this.order = e2.order || "below";
          }
          refresh() {
            const t2 = lg("table", this.editor.model.document.selection.getFirstPosition());
            this.isEnabled = !!t2;
          }
          execute() {
            const t2 = this.editor, e2 = t2.model.document.selection, n2 = t2.plugins.get("TableUtils"), i2 = "above" === this.order, o2 = i2 ? e2.getFirstPosition() : e2.getLastPosition(), r2 = ((i2 ? e2.getFirstRange() : e2.getLastRange()).getContainedElement() || lg("tableCell", o2)).parent, s2 = r2.parent, a2 = s2.getChildIndex(r2);
            n2.insertRows(s2, { rows: 1, at: "below" === this.order ? a2 + 1 : a2 });
          }
        }
        class Wg extends td {
          constructor(t2, e2 = {}) {
            super(t2), this.order = e2.order || "right";
          }
          refresh() {
            const t2 = lg("table", this.editor.model.document.selection.getFirstPosition());
            this.isEnabled = !!t2;
          }
          execute() {
            const t2 = this.editor, e2 = t2.model.document.selection, n2 = t2.plugins.get("TableUtils"), i2 = "left" === this.order, o2 = i2 ? e2.getFirstPosition() : e2.getLastPosition(), r2 = (i2 ? e2.getFirstRange() : e2.getLastRange()).getContainedElement() || lg("tableCell", o2), s2 = r2.parent.parent, { column: a2 } = n2.getCellLocation(r2);
            n2.insertColumns(s2, { columns: 1, at: i2 ? a2 : a2 + 1 });
          }
        }
        class Yg extends td {
          constructor(t2, e2 = {}) {
            super(t2), this.direction = e2.direction || "horizontally";
          }
          refresh() {
            const t2 = yg(this.editor.model.document.selection);
            this.isEnabled = 1 === t2.length;
          }
          execute() {
            const t2 = yg(this.editor.model.document.selection)[0], e2 = "horizontally" === this.direction, n2 = this.editor.plugins.get("TableUtils");
            e2 ? n2.splitCellHorizontally(t2, 2) : n2.splitCellVertically(t2, 2);
          }
        }
        class Gg extends td {
          constructor(t2, e2) {
            super(t2), this.direction = e2.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction;
          }
          refresh() {
            const t2 = this._getMergeableCell();
            this.value = t2, this.isEnabled = !!t2;
          }
          execute() {
            const t2 = this.editor.model, e2 = vg(t2.document.selection)[0], n2 = this.value, i2 = this.direction;
            t2.change((t3) => {
              const o2 = "right" == i2 || "down" == i2, r2 = o2 ? e2 : n2, s2 = o2 ? n2 : e2, a2 = s2.parent;
              !function(t4, e3, n3) {
                $g(t4) || ($g(e3) && n3.remove(n3.createRangeIn(e3)), n3.move(n3.createRangeIn(t4), n3.createPositionAt(e3, "end")));
                n3.remove(t4);
              }(s2, r2, t3);
              const c2 = this.isHorizontal ? "colspan" : "rowspan", l2 = parseInt(e2.getAttribute(c2) || 1), d2 = parseInt(n2.getAttribute(c2) || 1);
              t3.setAttribute(c2, l2 + d2, r2), t3.setSelection(t3.createRangeIn(r2)), a2.childCount || function(t4, e3) {
                const n3 = t4.parent, i3 = n3.getChildIndex(t4);
                for (const { cell: t5, row: o3, rowspan: r3 } of new pg(n3, { endRow: i3 })) {
                  o3 + r3 - 1 >= i3 && dg("rowspan", r3 - 1, t5, e3);
                }
                e3.remove(t4);
              }(a2, t3);
            });
          }
          _getMergeableCell() {
            const t2 = vg(this.editor.model.document.selection)[0];
            if (!t2)
              return;
            const e2 = this.editor.plugins.get("TableUtils"), n2 = this.isHorizontal ? function(t3, e3, n3) {
              const i3 = t3.parent.parent, o3 = "right" == e3 ? t3.nextSibling : t3.previousSibling, r2 = (i3.getAttribute("headingColumns") || 0) > 0;
              if (!o3)
                return;
              const s2 = "right" == e3 ? t3 : o3, a2 = "right" == e3 ? o3 : t3, { column: c2 } = n3.getCellLocation(s2), { column: l2 } = n3.getCellLocation(a2), d2 = parseInt(s2.getAttribute("colspan") || 1), u2 = hg(n3, s2), h2 = hg(n3, a2);
              if (r2 && u2 != h2)
                return;
              return c2 + d2 === l2 ? o3 : void 0;
            }(t2, this.direction, e2) : function(t3, e3) {
              const n3 = t3.parent, i3 = n3.parent, o3 = i3.getChildIndex(n3);
              if ("down" == e3 && o3 === i3.childCount - 1 || "up" == e3 && 0 === o3)
                return;
              const r2 = parseInt(t3.getAttribute("rowspan") || 1), s2 = i3.getAttribute("headingRows") || 0, a2 = "down" == e3 && o3 + r2 === s2, c2 = "up" == e3 && o3 === s2;
              if (s2 && (a2 || c2))
                return;
              const l2 = parseInt(t3.getAttribute("rowspan") || 1), d2 = "down" == e3 ? o3 + l2 : o3, u2 = [...new pg(i3, { endRow: d2 })], h2 = u2.find((e4) => e4.cell === t3).column, f2 = u2.find(({ row: t4, rowspan: n4, column: i4 }) => i4 === h2 && ("down" == e3 ? t4 === d2 : d2 === t4 + n4));
              return f2 && f2.cell;
            }(t2, this.direction);
            if (!n2)
              return;
            const i2 = this.isHorizontal ? "rowspan" : "colspan", o2 = parseInt(t2.getAttribute(i2) || 1);
            return parseInt(n2.getAttribute(i2) || 1) === o2 ? n2 : void 0;
          }
        }
        function $g(t2) {
          return 1 == t2.childCount && t2.getChild(0).is("paragraph") && t2.getChild(0).isEmpty;
        }
        class Qg extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection), e2 = t2[0];
            if (e2) {
              const n2 = lg("table", e2), i2 = this.editor.plugins.get("TableUtils").getRows(n2) - 1, o2 = xg(t2), r2 = 0 === o2.first && o2.last === i2;
              this.isEnabled = !r2;
            } else
              this.isEnabled = false;
          }
          execute() {
            const t2 = this.editor.model, e2 = yg(t2.document.selection), n2 = xg(e2), i2 = e2[0], o2 = lg("table", i2), r2 = this.editor.plugins.get("TableUtils").getCellLocation(i2).column, s2 = t2.createBatch();
            t2.enqueueChange(s2, (t3) => {
              t3.setSelection(t3.createSelection(o2, "on"));
              const e3 = n2.last - n2.first + 1;
              this.editor.plugins.get("TableUtils").removeRows(o2, { at: n2.first, rows: e3, batch: s2 });
            }), t2.enqueueChange(s2, (t3) => {
              const e3 = function(t4, e4, n3) {
                const i3 = t4.getChild(e4) || t4.getChild(t4.childCount - 1);
                let o3 = i3.getChild(0), r3 = 0;
                for (const t5 of i3.getChildren()) {
                  if (r3 > n3)
                    return o3;
                  o3 = t5, r3 += parseInt(t5.getAttribute("colspan") || 1);
                }
                return o3;
              }(o2, n2.first, r2);
              t3.setSelection(t3.createPositionAt(e3, 0));
            });
          }
        }
        class Kg extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection), e2 = t2[0];
            if (e2) {
              const n2 = lg("table", e2), i2 = this.editor.plugins.get("TableUtils").getColumns(n2), { first: o2, last: r2 } = Ag(t2);
              this.isEnabled = r2 - o2 < i2 - 1;
            } else
              this.isEnabled = false;
          }
          execute() {
            const [t2, e2] = function(t3) {
              const e3 = yg(t3), n3 = e3[0], i3 = e3.pop(), o3 = [n3, i3];
              return n3.isBefore(i3) ? o3 : o3.reverse();
            }(this.editor.model.document.selection), n2 = t2.parent.parent, i2 = [...new pg(n2)], o2 = { first: i2.find((e3) => e3.cell === t2).column, last: i2.find((t3) => t3.cell === e2).column }, r2 = function(t3, e3, n3, i3) {
              return parseInt(n3.getAttribute("colspan") || 1) > 1 ? n3 : e3.previousSibling || n3.nextSibling ? n3.nextSibling || e3.previousSibling : i3.first ? t3.reverse().find(({ column: t4 }) => t4 < i3.first).cell : t3.reverse().find(({ column: t4 }) => t4 > i3.last).cell;
            }(i2, t2, e2, o2);
            this.editor.model.change((t3) => {
              const e3 = o2.last - o2.first + 1;
              this.editor.plugins.get("TableUtils").removeColumns(n2, { at: o2.first, columns: e3 }), t3.setSelection(t3.createPositionAt(r2, 0));
            });
          }
        }
        class Jg extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection), e2 = t2.length > 0;
            this.isEnabled = e2, this.value = e2 && t2.every((t3) => this._isInHeading(t3, t3.parent.parent));
          }
          execute(t2 = {}) {
            if (t2.forceValue === this.value)
              return;
            const e2 = this.editor.model, n2 = yg(e2.document.selection), i2 = lg("table", n2[0]), { first: o2, last: r2 } = xg(n2), s2 = this.value ? o2 : r2 + 1, a2 = i2.getAttribute("headingRows") || 0;
            e2.change((t3) => {
              if (s2) {
                const e3 = function(t4, e4, n3) {
                  const i3 = [], o3 = new pg(t4, { startRow: e4 > n3 ? n3 : 0, endRow: e4 - 1 });
                  for (const { row: t5, rowspan: n4, cell: r3 } of o3)
                    n4 > 1 && t5 + n4 > e4 && i3.push(r3);
                  return i3;
                }(i2, s2, a2);
                for (const n3 of e3)
                  Zg(n3, s2, t3);
              }
              dg("headingRows", s2, i2, t3, 0);
            });
          }
          _isInHeading(t2, e2) {
            const n2 = parseInt(e2.getAttribute("headingRows") || 0);
            return !!n2 && t2.parent.index < n2;
          }
        }
        function Zg(t2, e2, n2) {
          const i2 = t2.parent, o2 = i2.parent, r2 = e2 - i2.index, s2 = {}, a2 = parseInt(t2.getAttribute("rowspan")) - r2;
          a2 > 1 && (s2.rowspan = a2);
          const c2 = parseInt(t2.getAttribute("colspan") || 1);
          c2 > 1 && (s2.colspan = c2);
          const l2 = o2.getChildIndex(i2), d2 = l2 + r2, u2 = [...new pg(o2, { startRow: l2, endRow: d2, includeSpanned: true })];
          let h2;
          for (const { row: e3, column: i3, cell: r3, cellIndex: a3 } of u2)
            if (r3 === t2 && void 0 === h2 && (h2 = i3), void 0 !== h2 && h2 === i3 && e3 === d2) {
              const t3 = o2.getChild(e3), i4 = n2.createPositionAt(t3, a3);
              ug(n2, i4, s2);
            }
          dg("rowspan", r2, t2, n2);
        }
        class Xg extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection), e2 = this.editor.plugins.get("TableUtils"), n2 = t2.length > 0;
            this.isEnabled = n2, this.value = n2 && t2.every((t3) => hg(e2, t3));
          }
          execute(t2 = {}) {
            if (t2.forceValue === this.value)
              return;
            const e2 = this.editor.model, n2 = yg(e2.document.selection), { first: i2, last: o2 } = Ag(n2), r2 = this.value ? i2 : o2 + 1;
            e2.change((t3) => {
              const e3 = lg("table", n2[0]);
              dg("headingColumns", r2, e3, t3, 0);
            });
          }
        }
        class tp extends $l {
          static get pluginName() {
            return "TableUtils";
          }
          getCellLocation(t2) {
            const e2 = t2.parent, n2 = e2.parent, i2 = n2.getChildIndex(e2), o2 = new pg(n2, { startRow: i2, endRow: i2 });
            for (const { cell: e3, row: n3, column: i3 } of o2)
              if (e3 === t2)
                return { row: n3, column: i3 };
          }
          createTable(t2, e2, n2) {
            const i2 = t2.createElement("table");
            return ep(t2, i2, 0, e2, n2), i2;
          }
          insertRows(t2, e2 = {}) {
            const n2 = this.editor.model, i2 = e2.at || 0, o2 = e2.rows || 1;
            n2.change((e3) => {
              const n3 = t2.getAttribute("headingRows") || 0;
              if (n3 > i2 && e3.setAttribute("headingRows", n3 + o2, t2), 0 === i2 || i2 === t2.childCount)
                return void ep(e3, t2, i2, o2, this.getColumns(t2));
              const r2 = new pg(t2, { endRow: i2 });
              let s2 = 0;
              for (const { row: t3, rowspan: n4, colspan: a2, cell: c2 } of r2) {
                const r3 = t3 + n4 > i2;
                t3 < i2 && r3 && e3.setAttribute("rowspan", n4 + o2, c2), t3 === i2 && (s2 += a2);
              }
              ep(e3, t2, i2, o2, s2);
            });
          }
          insertColumns(t2, e2 = {}) {
            const n2 = this.editor.model, i2 = e2.at || 0, o2 = e2.columns || 1;
            n2.change((e3) => {
              const n3 = t2.getAttribute("headingColumns");
              i2 < n3 && e3.setAttribute("headingColumns", n3 + o2, t2);
              const r2 = this.getColumns(t2);
              if (0 === i2 || r2 === i2) {
                for (const n4 of t2.getChildren())
                  np(o2, e3, e3.createPositionAt(n4, i2 ? "end" : 0));
                return;
              }
              const s2 = new pg(t2, { column: i2, includeSpanned: true });
              for (const { row: n4, cell: r3, cellIndex: a2 } of s2) {
                const c2 = parseInt(r3.getAttribute("rowspan") || 1), l2 = parseInt(r3.getAttribute("colspan") || 1);
                if (a2 !== i2 && l2 > 1) {
                  if (e3.setAttribute("colspan", l2 + o2, r3), s2.skipRow(n4), c2 > 1)
                    for (let t3 = n4 + 1; t3 < n4 + c2; t3++)
                      s2.skipRow(t3);
                } else {
                  const i3 = e3.createPositionAt(t2.getChild(n4), a2);
                  np(o2, e3, i3);
                }
              }
            });
          }
          removeRows(t2, e2) {
            const n2 = this.editor.model, i2 = e2.rows || 1, o2 = e2.at, r2 = o2 + i2 - 1, s2 = e2.batch || "default", { cellsToMove: a2, cellsToTrim: c2 } = function(t3, e3, n3) {
              const i3 = /* @__PURE__ */ new Map(), o3 = [];
              for (const { row: r3, column: s3, rowspan: a3, cell: c3 } of new pg(t3, { endRow: n3 })) {
                const t4 = r3 + a3 - 1;
                if (r3 >= e3 && r3 <= n3 && t4 > n3) {
                  const t5 = a3 - (n3 - r3 + 1);
                  i3.set(s3, { cell: c3, rowspan: t5 });
                }
                if (r3 < e3 && t4 >= e3) {
                  let i4;
                  i4 = t4 >= n3 ? n3 - e3 + 1 : t4 - e3 + 1, o3.push({ cell: c3, rowspan: a3 - i4 });
                }
              }
              return { cellsToMove: i3, cellsToTrim: o3 };
            }(t2, o2, r2);
            n2.enqueueChange(s2, (e3) => {
              !function(t3, e4, n3, i3) {
                const o3 = [...new pg(t3, { includeSpanned: true, startRow: e4, endRow: e4 })], r3 = t3.getChild(e4);
                let s3;
                for (const { column: t4, cell: e5, isSpanned: a3 } of o3)
                  if (n3.has(t4)) {
                    const { cell: e6, rowspan: o4 } = n3.get(t4), a4 = s3 ? i3.createPositionAfter(s3) : i3.createPositionAt(r3, 0);
                    i3.move(i3.createRangeOn(e6), a4), dg("rowspan", o4, e6, i3), s3 = e6;
                  } else
                    a3 || (s3 = e5);
              }(t2, r2 + 1, a2, e3);
              for (let n3 = r2; n3 >= o2; n3--)
                e3.remove(t2.getChild(n3));
              for (const { rowspan: t3, cell: n3 } of c2)
                dg("rowspan", t3, n3, e3);
              !function(t3, e4, n3, i3, o3) {
                const r3 = t3.getAttribute("headingRows") || 0;
                if (e4 < r3) {
                  const s3 = n3 < r3 ? r3 - (n3 - e4 + 1) : e4;
                  i3.enqueueChange(o3, (e5) => {
                    dg("headingRows", s3, t3, e5, 0);
                  });
                }
              }(t2, o2, r2, n2, s2);
            });
          }
          removeColumns(t2, e2) {
            const n2 = this.editor.model, i2 = e2.at, o2 = e2.columns || 1, r2 = e2.at + o2 - 1;
            n2.change((e3) => {
              !function(t3, e4, n3) {
                const i3 = t3.getAttribute("headingColumns") || 0;
                if (i3 && e4.first < i3) {
                  const o3 = Math.min(i3 - 1, e4.last) - e4.first + 1;
                  n3.setAttribute("headingColumns", i3 - o3, t3);
                }
              }(t2, { first: i2, last: r2 }, e3);
              for (let n3 = r2; n3 >= i2; n3--)
                for (const { cell: i3, column: o3, colspan: r3 } of [...new pg(t2)])
                  if (o3 <= n3 && r3 > 1 && o3 + r3 > n3)
                    dg("colspan", r3 - 1, i3, e3);
                  else if (o3 === n3) {
                    const n4 = i3.parent;
                    e3.remove(i3), n4.childCount || this.removeRows(t2, { at: n4.index });
                  }
            });
          }
          splitCellVertically(t2, e2 = 2) {
            const n2 = this.editor.model, i2 = t2.parent.parent, o2 = parseInt(t2.getAttribute("rowspan") || 1), r2 = parseInt(t2.getAttribute("colspan") || 1);
            n2.change((n3) => {
              if (r2 > 1) {
                const { newCellsSpan: i3, updatedSpan: s2 } = ip(r2, e2);
                dg("colspan", s2, t2, n3);
                const a2 = {};
                i3 > 1 && (a2.colspan = i3), o2 > 1 && (a2.rowspan = o2), np(r2 > e2 ? e2 - 1 : r2 - 1, n3, n3.createPositionAfter(t2), a2);
              }
              if (r2 < e2) {
                const s2 = e2 - r2, a2 = [...new pg(i2)], { column: c2 } = a2.find(({ cell: e3 }) => e3 === t2), l2 = a2.filter(({ cell: e3, colspan: n4, column: i3 }) => e3 !== t2 && i3 === c2 || i3 < c2 && i3 + n4 > c2);
                for (const { cell: t3, colspan: e3 } of l2)
                  n3.setAttribute("colspan", e3 + s2, t3);
                const d2 = {};
                o2 > 1 && (d2.rowspan = o2), np(s2, n3, n3.createPositionAfter(t2), d2);
                const u2 = i2.getAttribute("headingColumns") || 0;
                u2 > c2 && dg("headingColumns", u2 + s2, i2, n3);
              }
            });
          }
          splitCellHorizontally(t2, e2 = 2) {
            const n2 = this.editor.model, i2 = t2.parent, o2 = i2.parent, r2 = o2.getChildIndex(i2), s2 = parseInt(t2.getAttribute("rowspan") || 1), a2 = parseInt(t2.getAttribute("colspan") || 1);
            n2.change((n3) => {
              if (s2 > 1) {
                const i3 = [...new pg(o2, { startRow: r2, endRow: r2 + s2 - 1, includeSpanned: true })], { newCellsSpan: c2, updatedSpan: l2 } = ip(s2, e2);
                dg("rowspan", l2, t2, n3);
                const { column: d2 } = i3.find(({ cell: e3 }) => e3 === t2), u2 = {};
                c2 > 1 && (u2.rowspan = c2), a2 > 1 && (u2.colspan = a2);
                for (const { column: t3, row: e3, cellIndex: s3 } of i3) {
                  const i4 = t3 === d2, a3 = (e3 + r2 + l2) % c2 == 0;
                  if (e3 >= r2 + l2 && i4 && a3) {
                    const t4 = n3.createPositionAt(o2.getChild(e3), s3);
                    np(1, n3, t4, u2);
                  }
                }
              }
              if (s2 < e2) {
                const i3 = e2 - s2, c2 = [...new pg(o2, { startRow: 0, endRow: r2 })];
                for (const { cell: e3, rowspan: o3, row: s3 } of c2)
                  if (e3 !== t2 && s3 + o3 > r2) {
                    const t3 = o3 + i3;
                    n3.setAttribute("rowspan", t3, e3);
                  }
                const l2 = {};
                a2 > 1 && (l2.colspan = a2), ep(n3, o2, r2 + 1, i3, 1, l2);
                const d2 = o2.getAttribute("headingRows") || 0;
                d2 > r2 && dg("headingRows", d2 + i3, o2, n3);
              }
            });
          }
          getColumns(t2) {
            return [...t2.getChild(0).getChildren()].reduce((t3, e2) => t3 + parseInt(e2.getAttribute("colspan") || 1), 0);
          }
          getRows(t2) {
            return t2.childCount;
          }
        }
        function ep(t2, e2, n2, i2, o2, r2 = {}) {
          for (let s2 = 0; s2 < i2; s2++) {
            const i3 = t2.createElement("tableRow");
            t2.insert(i3, e2, n2), np(o2, t2, t2.createPositionAt(i3, "end"), r2);
          }
        }
        function np(t2, e2, n2, i2 = {}) {
          for (let o2 = 0; o2 < t2; o2++)
            ug(e2, n2, i2);
        }
        function ip(t2, e2) {
          if (t2 < e2)
            return { newCellsSpan: 1, updatedSpan: 1 };
          const n2 = Math.floor(t2 / e2);
          return { newCellsSpan: n2, updatedSpan: t2 - n2 * e2 + n2 };
        }
        class op extends td {
          refresh() {
            this.isEnabled = function(t2, e2) {
              const n2 = _g(t2);
              if (n2.length < 2 || !function(t3) {
                const e3 = lg("table", t3[0]), n3 = xg(t3), i3 = parseInt(e3.getAttribute("headingRows") || 0);
                if (!cp(n3, i3))
                  return false;
                const o3 = parseInt(e3.getAttribute("headingColumns") || 0);
                return cp(Ag(t3), o3);
              }(n2))
                return false;
              const i2 = /* @__PURE__ */ new Set(), o2 = /* @__PURE__ */ new Set();
              let r2 = 0;
              for (const t3 of n2) {
                const { row: n3, column: s2 } = e2.getCellLocation(t3), a2 = parseInt(t3.getAttribute("rowspan") || 1), c2 = parseInt(t3.getAttribute("colspan") || 1);
                i2.add(n3), o2.add(s2), a2 > 1 && i2.add(n3 + a2 - 1), c2 > 1 && o2.add(s2 + c2 - 1), r2 += a2 * c2;
              }
              return function(t3, e3) {
                const n3 = Array.from(t3.values()), i3 = Array.from(e3.values()), o3 = Math.max(...n3), r3 = Math.min(...n3), s2 = Math.max(...i3), a2 = Math.min(...i3);
                return (o3 - r3 + 1) * (s2 - a2 + 1);
              }(i2, o2) == r2;
            }(this.editor.model.document.selection, this.editor.plugins.get(tp));
          }
          execute() {
            const t2 = this.editor.model, e2 = this.editor.plugins.get(tp);
            t2.change((n2) => {
              const i2 = _g(t2.document.selection), o2 = i2.shift();
              n2.setSelection(o2, 0);
              const { mergeWidth: r2, mergeHeight: s2 } = function(t3, e3, n3) {
                let i3 = 0, o3 = 0;
                for (const t4 of e3) {
                  const { row: e4, column: r4 } = n3.getCellLocation(t4);
                  i3 = lp(t4, r4, i3, "colspan"), o3 = lp(t4, e4, o3, "rowspan");
                }
                const { row: r3, column: s3 } = n3.getCellLocation(t3);
                return { mergeWidth: i3 - s3, mergeHeight: o3 - r3 };
              }(o2, i2, e2);
              dg("colspan", r2, o2, n2), dg("rowspan", s2, o2, n2);
              for (const t3 of i2) {
                const e3 = t3.parent;
                sp(t3, o2, n2), rp(e3, n2);
              }
              n2.setSelection(o2, "in");
            });
          }
        }
        function rp(t2, e2) {
          if (t2.childCount)
            return;
          const n2 = t2.parent, i2 = n2.getChildIndex(t2);
          for (const { cell: t3, row: o2, rowspan: r2 } of new pg(n2, { endRow: i2 })) {
            o2 + r2 - 1 >= i2 && dg("rowspan", r2 - 1, t3, e2);
          }
          e2.remove(t2);
        }
        function sp(t2, e2, n2) {
          ap(t2) || (ap(e2) && n2.remove(n2.createRangeIn(e2)), n2.move(n2.createRangeIn(t2), n2.createPositionAt(e2, "end"))), n2.remove(t2);
        }
        function ap(t2) {
          return 1 == t2.childCount && t2.getChild(0).is("paragraph") && t2.getChild(0).isEmpty;
        }
        function cp({ first: t2, last: e2 }, n2) {
          return t2 < n2 === e2 < n2;
        }
        function lp(t2, e2, n2, i2) {
          const o2 = parseInt(t2.getAttribute(i2) || 1);
          return Math.max(n2, e2 + o2);
        }
        class dp extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection);
            this.isEnabled = t2.length > 0;
          }
          execute() {
            const t2 = this.editor.model, e2 = yg(t2.document.selection), n2 = xg(e2), i2 = lg("table", e2[0]), o2 = [];
            for (let e3 = n2.first; e3 <= n2.last; e3++)
              for (const n3 of i2.getChild(e3).getChildren())
                o2.push(t2.createRangeOn(n3));
            t2.change((t3) => {
              t3.setSelection(o2);
            });
          }
        }
        class up extends td {
          refresh() {
            const t2 = yg(this.editor.model.document.selection);
            this.isEnabled = t2.length > 0;
          }
          execute() {
            const t2 = this.editor.model, e2 = yg(t2.document.selection), n2 = e2[0], i2 = e2.pop(), o2 = this.editor.plugins.get("TableUtils"), r2 = o2.getCellLocation(n2), s2 = o2.getCellLocation(i2), a2 = Math.min(r2.column, s2.column), c2 = Math.max(r2.column, s2.column), l2 = [];
            for (const e3 of new pg(lg("table", n2)))
              e3.column >= a2 && e3.column <= c2 && l2.push(t2.createRangeOn(e3.cell));
            t2.change((t3) => {
              t3.setSelection(l2);
            });
          }
        }
        function hp(t2) {
          t2.document.registerPostFixer((e2) => function(t3, e3) {
            const n2 = e3.document.differ.getChanges();
            let i2 = false;
            const o2 = /* @__PURE__ */ new Set();
            for (const e4 of n2) {
              let n3;
              "table" == e4.name && "insert" == e4.type && (n3 = e4.position.nodeAfter), "tableRow" != e4.name && "tableCell" != e4.name || (n3 = lg("table", e4.position)), gp(e4) && (n3 = lg("table", e4.range.start)), n3 && !o2.has(n3) && (i2 = fp(n3, t3) || i2, i2 = mp(n3, t3) || i2, o2.add(n3));
            }
            return i2;
          }(e2, t2));
        }
        function fp(t2, e2) {
          let n2 = false;
          const i2 = function(t3) {
            const e3 = parseInt(t3.getAttribute("headingRows") || 0), n3 = t3.childCount, i3 = [];
            for (const { row: o2, rowspan: r2, cell: s2 } of new pg(t3)) {
              if (r2 < 2)
                continue;
              const t4 = o2 < e3 ? e3 : n3;
              if (o2 + r2 > t4) {
                const e4 = t4 - o2;
                i3.push({ cell: s2, rowspan: e4 });
              }
            }
            return i3;
          }(t2);
          if (i2.length) {
            n2 = true;
            for (const t3 of i2)
              dg("rowspan", t3.rowspan, t3.cell, e2, 1);
          }
          return n2;
        }
        function mp(t2, e2) {
          let n2 = false;
          const i2 = function(t3) {
            const e3 = {};
            for (const { row: n3 } of new pg(t3, { includeSpanned: true }))
              e3[n3] || (e3[n3] = 0), e3[n3] += 1;
            return e3;
          }(t2), o2 = i2[0];
          if (!Object.values(i2).every((t3) => t3 === o2)) {
            const o3 = Object.values(i2).reduce((t3, e3) => e3 > t3 ? e3 : t3, 0);
            for (const [r2, s2] of Object.entries(i2)) {
              const i3 = o3 - s2;
              if (i3) {
                for (let n3 = 0; n3 < i3; n3++)
                  ug(e2, e2.createPositionAt(t2.getChild(r2), "end"));
                n2 = true;
              }
            }
          }
          return n2;
        }
        function gp(t2) {
          const e2 = "attribute" === t2.type, n2 = t2.attributeKey;
          return e2 && ("headingRows" === n2 || "colspan" === n2 || "rowspan" === n2);
        }
        function pp(t2) {
          t2.document.registerPostFixer((e2) => function(t3, e3) {
            const n2 = e3.document.differ.getChanges();
            let i2 = false;
            for (const e4 of n2)
              "insert" == e4.type && "table" == e4.name && (i2 = bp(e4.position.nodeAfter, t3) || i2), "insert" == e4.type && "tableRow" == e4.name && (i2 = wp(e4.position.nodeAfter, t3) || i2), "insert" == e4.type && "tableCell" == e4.name && (i2 = kp(e4.position.nodeAfter, t3) || i2), _p(e4) && (i2 = kp(e4.position.parent, t3) || i2);
            return i2;
          }(e2, t2));
        }
        function bp(t2, e2) {
          let n2 = false;
          for (const i2 of t2.getChildren())
            n2 = wp(i2, e2) || n2;
          return n2;
        }
        function wp(t2, e2) {
          let n2 = false;
          for (const i2 of t2.getChildren())
            n2 = kp(i2, e2) || n2;
          return n2;
        }
        function kp(t2, e2) {
          if (0 == t2.childCount)
            return e2.insertElement("paragraph", t2), true;
          const n2 = Array.from(t2.getChildren()).filter((t3) => t3.is("text"));
          for (const t3 of n2)
            e2.wrap(e2.createRangeOn(t3), "paragraph");
          return !!n2.length;
        }
        function _p(t2) {
          return !(!t2.position || !t2.position.parent.is("tableCell")) && ("insert" == t2.type && "$text" == t2.name || "remove" == t2.type);
        }
        function vp(t2) {
          t2.document.registerPostFixer(() => function(t3) {
            const e2 = t3.document.differ, n2 = /* @__PURE__ */ new Set();
            for (const t4 of e2.getChanges()) {
              const e3 = "insert" == t4.type || "remove" == t4.type ? t4.position.parent : t4.range.start.parent;
              e3.is("tableCell") && yp(e3, t4.type) && n2.add(e3);
            }
            if (n2.size) {
              for (const t4 of n2.values())
                e2.refreshItem(t4);
              return true;
            }
            return false;
          }(t2));
        }
        function yp(t2, e2) {
          if (!Array.from(t2.getChildren()).some((t3) => t3.is("paragraph")))
            return false;
          if ("attribute" == e2) {
            const e3 = Array.from(t2.getChild(0).getAttributeKeys()).length;
            return 1 === t2.childCount && e3 < 2;
          }
          return t2.childCount <= ("insert" == e2 ? 2 : 1);
        }
        n(84);
        class xp extends $l {
          static get pluginName() {
            return "TableEditing";
          }
          init() {
            const t2 = this.editor, e2 = t2.model, n2 = e2.schema, i2 = t2.conversion;
            n2.register("table", { allowWhere: "$block", allowAttributes: ["headingRows", "headingColumns"], isLimit: true, isObject: true, isBlock: true }), n2.register("tableRow", { allowIn: "table", isLimit: true }), n2.register("tableCell", { allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isObject: true }), n2.extend("$block", { allowIn: "tableCell" }), n2.addChildCheck((t3, e3) => {
              if ("table" == e3.name && Array.from(t3.getNames()).includes("table"))
                return false;
            }), i2.for("upcast").add(fg()), i2.for("editingDowncast").add(Pg({ asWidget: true })), i2.for("dataDowncast").add(Pg()), i2.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), i2.for("editingDowncast").add(Sg({ asWidget: true })), i2.for("dataDowncast").add(Sg()), i2.for("downcast").add((t3) => t3.on("remove:tableRow", (t4, e3, n3) => {
              t4.stop();
              const i3 = n3.writer, o2 = n3.mapper, r2 = o2.toViewPosition(e3.position).getLastMatchingPosition((t5) => !t5.item.is("tr")).nodeAfter, s2 = r2.parent.parent, a2 = i3.createRangeOn(r2), c2 = i3.remove(a2);
              for (const t5 of i3.createRangeIn(c2).getItems())
                o2.unbindViewElement(t5);
              Bg("thead", s2, n3), Bg("tbody", s2, n3);
            }, { priority: "higher" })), i2.for("upcast").add(mg("td")), i2.for("upcast").add(mg("th")), i2.for("editingDowncast").add(Mg({ asWidget: true })), i2.for("dataDowncast").add(Mg()), i2.attributeToAttribute({ model: "colspan", view: "colspan" }), i2.attributeToAttribute({ model: "rowspan", view: "rowspan" }), i2.for("editingDowncast").add(Ig({ asWidget: true })), i2.for("dataDowncast").add(Ig()), i2.for("editingDowncast").add(Eg({ asWidget: true })), i2.for("dataDowncast").add(Eg()), t2.commands.add("insertTable", new Hg(t2)), t2.commands.add("insertTableRowAbove", new qg(t2, { order: "above" })), t2.commands.add("insertTableRowBelow", new qg(t2, { order: "below" })), t2.commands.add("insertTableColumnLeft", new Wg(t2, { order: "left" })), t2.commands.add("insertTableColumnRight", new Wg(t2, { order: "right" })), t2.commands.add("removeTableRow", new Qg(t2)), t2.commands.add("removeTableColumn", new Kg(t2)), t2.commands.add("splitTableCellVertically", new Yg(t2, { direction: "vertically" })), t2.commands.add("splitTableCellHorizontally", new Yg(t2, { direction: "horizontally" })), t2.commands.add("mergeTableCells", new op(t2)), t2.commands.add("mergeTableCellRight", new Gg(t2, { direction: "right" })), t2.commands.add("mergeTableCellLeft", new Gg(t2, { direction: "left" })), t2.commands.add("mergeTableCellDown", new Gg(t2, { direction: "down" })), t2.commands.add("mergeTableCellUp", new Gg(t2, { direction: "up" })), t2.commands.add("setTableColumnHeader", new Xg(t2)), t2.commands.add("setTableRowHeader", new Jg(t2)), t2.commands.add("selectTableRow", new dp(t2)), t2.commands.add("selectTableColumn", new up(t2)), hp(e2), vp(e2), pp(e2);
          }
          static get requires() {
            return [tp];
          }
        }
        n(86);
        class Ap extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isToggleable", false), this.set("isVisible", true), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new Ac(), this.focusTracker = new Oc(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e2.if("isVisible", "ck-hidden", (t3) => !t3), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
          }
          render() {
            super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (t2, e2) => {
              this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e2());
            }), this.keystrokes.set("arrowleft", (t2, e2) => {
              this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e2());
            });
          }
          focus() {
            this.actionView.focus();
          }
          _createActionView() {
            const t2 = new Nl();
            return t2.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t2.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), t2.delegate("execute").to(this), t2;
          }
          _createArrowView() {
            const t2 = new Nl(), e2 = t2.bindTemplate;
            return t2.icon = Ol, t2.extendTemplate({ attributes: { class: "ck-splitbutton__arrow", "aria-haspopup": true, "aria-expanded": e2.to("isOn", (t3) => String(t3)) } }), t2.bind("isEnabled").to(this), t2.delegate("execute").to(this, "open"), t2;
          }
        }
        n(88);
        class Tp extends cl {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.items = this._createGridCollection(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (t3, e3) => `${e3} \xD7 ${t3}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e2.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck-insert-table-dropdown__label"] }, children: [{ text: e2.to("label") }] }], on: { mousedown: e2.to((t3) => {
              t3.preventDefault();
            }), click: e2.to(() => {
              this.fire("execute");
            }) } }), this.on("boxover", (t3, e3) => {
              const { row: n2, column: i2 } = e3.target.dataset;
              this.set({ rows: parseInt(n2), columns: parseInt(i2) });
            }), this.on("change:columns", () => {
              this._highlightGridBoxes();
            }), this.on("change:rows", () => {
              this._highlightGridBoxes();
            });
          }
          focus() {
          }
          focusLast() {
          }
          _highlightGridBoxes() {
            const t2 = this.rows, e2 = this.columns;
            this.items.map((n2, i2) => {
              const o2 = Math.floor(i2 / 10) < t2 && i2 % 10 < e2;
              n2.set("isOn", o2);
            });
          }
          _createGridCollection() {
            const t2 = [];
            for (let e2 = 0; e2 < 100; e2++) {
              const n2 = Math.floor(e2 / 10), i2 = e2 % 10;
              t2.push(new Cp(this.locale, n2 + 1, i2 + 1));
            }
            return this.createCollection(t2);
          }
        }
        class Cp extends cl {
          constructor(t2, e2, n2) {
            super(t2);
            const i2 = this.bindTemplate;
            this.set("isOn", false), this.setTemplate({ tag: "div", attributes: { class: ["ck-insert-table-dropdown-grid-box", i2.if("isOn", "ck-on")], "data-row": e2, "data-column": n2 } });
          }
        }
        class Pp extends $l {
          init() {
            const t2 = this.editor, e2 = this.editor.t, n2 = "ltr" === t2.locale.contentLanguageDirection;
            t2.ui.componentFactory.add("insertTable", (n3) => {
              const i2 = t2.commands.get("insertTable"), o2 = Bl(n3);
              let r2;
              return o2.bind("isEnabled").to(i2), o2.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: e2("Insert table"), tooltip: true }), o2.on("change:isOpen", () => {
                r2 || (r2 = new Tp(n3), o2.panelView.children.add(r2), r2.delegate("execute").to(o2), o2.buttonView.on("open", () => {
                  r2.rows = 0, r2.columns = 0;
                }), o2.on("execute", () => {
                  t2.execute("insertTable", { rows: r2.rows, columns: r2.columns }), t2.editing.view.focus();
                }));
              }), o2;
            }), t2.ui.componentFactory.add("tableColumn", (t3) => {
              const i2 = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: e2("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: n2 ? "insertTableColumnLeft" : "insertTableColumnRight", label: e2("Insert column left") } }, { type: "button", model: { commandName: n2 ? "insertTableColumnRight" : "insertTableColumnLeft", label: e2("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: e2("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: e2("Select column") } }];
              return this._prepareDropdown(e2("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', i2, t3);
            }), t2.ui.componentFactory.add("tableRow", (t3) => {
              const n3 = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: e2("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowBelow", label: e2("Insert row below") } }, { type: "button", model: { commandName: "insertTableRowAbove", label: e2("Insert row above") } }, { type: "button", model: { commandName: "removeTableRow", label: e2("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: e2("Select row") } }];
              return this._prepareDropdown(e2("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n3, t3);
            }), t2.ui.componentFactory.add("mergeTableCells", (t3) => {
              const i2 = [{ type: "button", model: { commandName: "mergeTableCellUp", label: e2("Merge cell up") } }, { type: "button", model: { commandName: n2 ? "mergeTableCellRight" : "mergeTableCellLeft", label: e2("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: e2("Merge cell down") } }, { type: "button", model: { commandName: n2 ? "mergeTableCellLeft" : "mergeTableCellRight", label: e2("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: e2("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: e2("Split cell horizontally") } }];
              return this._prepareMergeSplitButtonDropdown(e2("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', i2, t3);
            });
          }
          _prepareDropdown(t2, e2, n2, i2) {
            const o2 = this.editor, r2 = Bl(i2), s2 = this._fillDropdownWithListOptions(r2, n2);
            return r2.buttonView.set({ label: t2, icon: e2, tooltip: true }), r2.bind("isEnabled").toMany(s2, "isEnabled", (...t3) => t3.some((t4) => t4)), this.listenTo(r2, "execute", (t3) => {
              o2.execute(t3.source.commandName), o2.editing.view.focus();
            }), r2;
          }
          _prepareMergeSplitButtonDropdown(t2, e2, n2, i2) {
            const o2 = this.editor, r2 = Bl(i2, Ap);
            return this._fillDropdownWithListOptions(r2, n2), r2.buttonView.set({ label: t2, icon: e2, tooltip: true, isEnabled: true }), this.listenTo(r2.buttonView, "execute", () => {
              o2.execute("mergeTableCells"), o2.editing.view.focus();
            }), this.listenTo(r2, "execute", (t3) => {
              o2.execute(t3.source.commandName), o2.editing.view.focus();
            }), r2;
          }
          _fillDropdownWithListOptions(t2, e2) {
            const n2 = this.editor, i2 = [], o2 = new An();
            for (const t3 of e2)
              Sp(t3, n2, i2, o2);
            return Fl(t2, o2, n2.ui.componentFactory), i2;
          }
        }
        function Sp(t2, e2, n2, i2) {
          const o2 = t2.model = new Nf(t2.model), { commandName: r2, bindIsOn: s2 } = t2.model;
          if ("button" === t2.type || "switchbutton" === t2.type) {
            const t3 = e2.commands.get(r2);
            n2.push(t3), o2.set({ commandName: r2 }), o2.bind("isEnabled").to(t3), s2 && o2.bind("isOn").to(t3, "value");
          }
          o2.set({ withText: true }), i2.add(t2);
        }
        class Mp extends Nr {
          constructor(t2) {
            super(t2), this.domEventType = ["mousemove", "mouseup", "mouseleave"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        function Ep(t2, e2, n2) {
          const i2 = Array.from(t2), o2 = i2[0], r2 = i2[i2.length - 1], { row: s2, column: a2 } = e2.getCellLocation(o2), c2 = function(t3, e3, n3, i3) {
            const o3 = n3.createElement("table"), r3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map();
            for (const e4 of t3) {
              const t4 = lg("tableRow", e4);
              if (!r3.has(t4)) {
                const e5 = t4._clone();
                n3.append(e5, o3), r3.set(t4, e5);
              }
              const a3 = e4._clone(true), { column: c3 } = i3.getCellLocation(e4);
              s3.set(a3, c3), n3.append(a3, r3.get(t4));
            }
            return function(t4, e4, n4, i4, o4) {
              for (const r4 of t4.getChildren())
                for (const t5 of Array.from(r4.getChildren())) {
                  const { column: r5 } = o4.getCellLocation(t5), s4 = n4.get(t5) - e4;
                  if (r5 !== s4)
                    for (let e5 = 0; e5 < s4 - r5; e5++) {
                      const e6 = i4.createElement("tableCell");
                      i4.insert(e6, i4.createPositionBefore(t5));
                      const n5 = i4.createElement("paragraph");
                      i4.insert(n5, e6, 0), i4.insertText("", n5, 0);
                    }
                }
            }(o3, e3, s3, n3, i3), o3;
          }(i2, a2, n2, e2), { row: l2, column: d2 } = e2.getCellLocation(r2);
          return function(t3, e3, n3, i3, o3) {
            for (const r3 of t3.getChildren())
              for (const t4 of r3.getChildren()) {
                const r4 = parseInt(t4.getAttribute("colspan") || 1), s3 = parseInt(t4.getAttribute("rowspan") || 1), { row: a3, column: c3 } = o3.getCellLocation(t4);
                if (c3 + r4 > e3) {
                  const n4 = e3 - c3;
                  n4 > 1 ? i3.setAttribute("colspan", n4, t4) : i3.removeAttribute("colspan", t4);
                }
                if (a3 + s3 > n3) {
                  const e4 = n3 - a3;
                  e4 > 1 ? i3.setAttribute("rowspan", e4, t4) : i3.removeAttribute("rowspan", t4);
                }
              }
          }(c2, d2 - a2 + 1, l2 - s2 + 1, n2, e2), function(t3, e3, n3, i3, o3) {
            const r3 = parseInt(e3.getAttribute("headingRows") || 0);
            if (r3 > 0) {
              const e4 = r3 - n3;
              o3.setAttribute("headingRows", e4, t3);
            }
            const s3 = parseInt(e3.getAttribute("headingColumns") || 0);
            if (s3 > 0) {
              const e4 = s3 - i3;
              o3.setAttribute("headingColumns", e4, t3);
            }
          }(c2, lg("table", o2), s2, a2, n2), c2;
        }
        n(90);
        class Ip extends $l {
          static get pluginName() {
            return "TableSelection";
          }
          static get requires() {
            return [tp];
          }
          init() {
            const t2 = this.editor, e2 = t2.model;
            this.listenTo(e2, "deleteContent", (t3, e3) => this._handleDeleteContent(t3, e3), { priority: "high" }), t2.editing.view.addObserver(Mp), this._defineSelectionConverter(), this._enableShiftClickSelection(), this._enableMouseDragSelection(), this._enablePluginDisabling();
          }
          getSelectedTableCells() {
            const t2 = _g(this.editor.model.document.selection);
            return 0 == t2.length ? null : t2;
          }
          getSelectionAsFragment() {
            const t2 = this.getSelectedTableCells();
            return t2 ? this.editor.model.change((e2) => {
              const n2 = e2.createDocumentFragment(), i2 = Ep(t2, this.editor.plugins.get("TableUtils"), e2);
              return e2.insert(i2, n2, 0), n2;
            }) : null;
          }
          _defineSelectionConverter() {
            const t2 = this.editor, e2 = /* @__PURE__ */ new Set();
            t2.conversion.for("editingDowncast").add((t3) => t3.on("selection", (t4, n2, i2) => {
              const o2 = i2.writer;
              !function(t5) {
                for (const n3 of e2)
                  t5.removeClass("ck-editor__editable_selected", n3);
                e2.clear();
              }(o2);
              const r2 = this.getSelectedTableCells();
              if (!r2)
                return;
              for (const t5 of r2) {
                const n3 = i2.mapper.toViewElement(t5);
                o2.addClass("ck-editor__editable_selected", n3), e2.add(n3);
              }
              const s2 = i2.mapper.toViewElement(r2[r2.length - 1]);
              o2.setSelection(s2, 0);
            }, { priority: "lowest" }));
          }
          _enableShiftClickSelection() {
            const t2 = this.editor;
            let e2 = false;
            this.listenTo(t2.editing.view.document, "mousedown", (n2, i2) => {
              if (!this.isEnabled)
                return;
              if (!i2.domEvent.shiftKey)
                return;
              const o2 = vg(t2.model.document.selection)[0];
              if (!o2)
                return;
              const r2 = this._getModelTableCellFromDomEvent(i2);
              r2 && Np(o2, r2) && (e2 = true, this._setCellSelection(o2, r2), i2.preventDefault());
            }), this.listenTo(t2.editing.view.document, "mouseup", () => {
              e2 = false;
            }), this.listenTo(t2.editing.view.document, "selectionChange", (t3) => {
              e2 && t3.stop();
            }, { priority: "highest" });
          }
          _enableMouseDragSelection() {
            const t2 = this.editor;
            let e2, n2, i2 = false, o2 = false;
            this.listenTo(t2.editing.view.document, "mousedown", (t3, n3) => {
              this.isEnabled && (n3.domEvent.shiftKey || n3.domEvent.ctrlKey || n3.domEvent.altKey || (e2 = this._getModelTableCellFromDomEvent(n3)));
            }), this.listenTo(t2.editing.view.document, "mousemove", (t3, r2) => {
              if (!r2.domEvent.buttons)
                return;
              if (!e2)
                return;
              const s2 = this._getModelTableCellFromDomEvent(r2);
              s2 && Np(e2, s2) && (n2 = s2, i2 || n2 == e2 || (i2 = true)), i2 && (o2 = true, this._setCellSelection(e2, n2), r2.preventDefault());
            }), this.listenTo(t2.editing.view.document, "mouseup", () => {
              i2 = false, o2 = false, e2 = null, n2 = null;
            }), this.listenTo(t2.editing.view.document, "selectionChange", (t3) => {
              o2 && t3.stop();
            }, { priority: "highest" });
          }
          _enablePluginDisabling() {
            const t2 = this.editor;
            this.on("change:isEnabled", () => {
              if (!this.isEnabled) {
                const e2 = this.getSelectedTableCells();
                if (!e2)
                  return;
                t2.model.change((n2) => {
                  const i2 = n2.createPositionAt(e2[0], 0), o2 = t2.model.schema.getNearestSelectionRange(i2);
                  n2.setSelection(o2);
                });
              }
            });
          }
          _handleDeleteContent(t2, e2) {
            const [n2, i2] = e2, o2 = this.editor.model, r2 = !i2 || "backward" == i2.direction, s2 = _g(n2);
            s2.length && (t2.stop(), o2.change((t3) => {
              const e3 = s2[r2 ? s2.length - 1 : 0];
              o2.change((t4) => {
                for (const e4 of s2)
                  o2.deleteContent(t4.createSelection(e4, "in"));
              });
              const i3 = o2.schema.getNearestSelectionRange(t3.createPositionAt(e3, 0));
              n2.is("documentSelection") ? t3.setSelection(i3) : n2.setTo(i3);
            }));
          }
          _setCellSelection(t2, e2) {
            const n2 = this._getCellsToSelect(t2, e2);
            this.editor.model.change((t3) => {
              t3.setSelection(n2.cells.map((e3) => t3.createRangeOn(e3)), { backward: n2.backward });
            });
          }
          _getModelTableCellFromDomEvent(t2) {
            const e2 = t2.target, n2 = this.editor.editing.view.createPositionAt(e2, 0), i2 = this.editor.editing.mapper.toModelPosition(n2).parent;
            return i2.is("tableCell") ? i2 : lg("tableCell", i2);
          }
          _getCellsToSelect(t2, e2) {
            const n2 = this.editor.plugins.get("TableUtils"), i2 = n2.getCellLocation(t2), o2 = n2.getCellLocation(e2), r2 = Math.min(i2.row, o2.row), s2 = Math.max(i2.row, o2.row), a2 = Math.min(i2.column, o2.column), c2 = Math.max(i2.column, o2.column), l2 = [];
            for (const e3 of new pg(lg("table", t2), { startRow: r2, endRow: s2 }))
              e3.column >= a2 && e3.column <= c2 && l2.push(e3.cell);
            return function(t3, e3) {
              if (t3.row > e3.row)
                return true;
              if (t3.row == e3.row && t3.column > e3.column)
                return true;
              return false;
            }(i2, o2) ? { cells: l2.reverse(), backward: true } : { cells: l2, backward: false };
          }
        }
        function Np(t2, e2) {
          return t2.parent.parent == e2.parent.parent;
        }
        class Op extends $l {
          static get pluginName() {
            return "TableClipboard";
          }
          static get requires() {
            return [Ip];
          }
          init() {
            const t2 = this.editor.editing.view.document;
            this.listenTo(t2, "copy", (t3, e2) => this._onCopyCut(t3, e2)), this.listenTo(t2, "cut", (t3, e2) => this._onCopyCut(t3, e2));
          }
          _onCopyCut(t2, e2) {
            const n2 = this.editor.plugins.get("TableSelection");
            if (!n2.getSelectedTableCells())
              return;
            if ("cut" == t2.name && this.editor.isReadOnly)
              return;
            e2.preventDefault(), t2.stop();
            const i2 = this.editor.data, o2 = this.editor.editing.view.document, r2 = i2.toView(n2.getSelectionAsFragment());
            o2.fire("clipboardOutput", { dataTransfer: e2.dataTransfer, content: r2, method: t2.name });
          }
        }
        class Rp extends $l {
          static get pluginName() {
            return "TableNavigation";
          }
          init() {
            const t2 = this.editor.editing.view.document;
            this.editor.keystrokes.set("Tab", (...t3) => this._handleTabOnSelectedTable(...t3), { priority: "low" }), this.editor.keystrokes.set("Tab", this._getTabHandler(true), { priority: "low" }), this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), { priority: "low" }), this.listenTo(t2, "keydown", (...t3) => this._onKeydown(...t3), { priority: un.get("high") + 1 });
          }
          _handleTabOnSelectedTable(t2, e2) {
            const n2 = this.editor, i2 = n2.model.document.selection;
            if (!i2.isCollapsed && 1 === i2.rangeCount && i2.getFirstRange().isFlat) {
              const t3 = i2.getSelectedElement();
              if (!t3 || !t3.is("table"))
                return;
              e2(), n2.model.change((e3) => {
                e3.setSelection(e3.createRangeIn(t3.getChild(0).getChild(0)));
              });
            }
          }
          _getTabHandler(t2) {
            const e2 = this.editor;
            return (n2, i2) => {
              const o2 = vg(e2.model.document.selection)[0];
              if (!o2)
                return;
              i2();
              const r2 = o2.parent, s2 = r2.parent, a2 = s2.getChildIndex(r2), c2 = r2.getChildIndex(o2), l2 = 0 === c2;
              if (!t2 && l2 && 0 === a2)
                return;
              const d2 = c2 === r2.childCount - 1, u2 = a2 === s2.childCount - 1;
              if (t2 && u2 && d2 && (e2.execute("insertTableRowBelow"), a2 === s2.childCount - 1))
                return;
              let h2;
              if (t2 && d2) {
                const t3 = s2.getChild(a2 + 1);
                h2 = t3.getChild(0);
              } else if (!t2 && l2) {
                const t3 = s2.getChild(a2 - 1);
                h2 = t3.getChild(t3.childCount - 1);
              } else
                h2 = r2.getChild(c2 + (t2 ? 1 : -1));
              e2.model.change((t3) => {
                t3.setSelection(t3.createRangeIn(h2));
              });
            };
          }
          _onKeydown(t2, e2) {
            const n2 = e2.keyCode;
            (function(t3) {
              return t3 == go.arrowright || t3 == go.arrowleft || t3 == go.arrowup || t3 == go.arrowdown;
            })(n2) && this._handleArrowKeys(function(t3, e3) {
              const n3 = "ltr" === e3;
              switch (t3) {
                case go.arrowleft:
                  return n3 ? "left" : "right";
                case go.arrowright:
                  return n3 ? "right" : "left";
                case go.arrowup:
                  return "up";
                case go.arrowdown:
                  return "down";
              }
            }(n2, this.editor.locale.contentLanguageDirection)) && (e2.preventDefault(), e2.stopPropagation(), t2.stop());
          }
          _handleArrowKeys(t2) {
            const e2 = this.editor.model, n2 = e2.document.selection, i2 = ["right", "down"].includes(t2), o2 = _g(n2);
            if (o2.length) {
              const e3 = i2 ? o2[o2.length - 1] : o2[0];
              return this._navigateFromCellInDirection(e3, t2), true;
            }
            const r2 = lg("tableCell", n2.focus);
            if (!r2)
              return false;
            const s2 = e2.createRangeIn(r2);
            if (this._isSelectionAtCellEdge(n2, i2))
              return this._navigateFromCellInDirection(r2, t2), true;
            const a2 = n2.getSelectedElement();
            if (a2 && e2.schema.isObject(a2))
              return false;
            if (this._isObjectElementNextToSelection(n2, i2))
              return false;
            const c2 = this._findTextRangeFromSelection(s2, n2, i2);
            return c2 ? !["left", "right"].includes(t2) && (this._isSingleLineRange(c2, i2) ? (e2.change((t3) => {
              t3.setSelection(i2 ? s2.end : s2.start);
            }), true) : void 0) : (this._navigateFromCellInDirection(r2, t2), true);
          }
          _isSelectionAtCellEdge(t2, e2) {
            const n2 = this.editor.model, i2 = this.editor.model.schema, o2 = e2 ? t2.getLastPosition() : t2.getFirstPosition();
            if (!i2.getLimitElement(o2).is("tableCell"))
              return false;
            const r2 = n2.createSelection(o2);
            return n2.modifySelection(r2, { direction: e2 ? "forward" : "backward" }), o2.isEqual(r2.focus);
          }
          _isObjectElementNextToSelection(t2, e2) {
            const n2 = this.editor.model, i2 = n2.schema, o2 = n2.createSelection(t2);
            n2.modifySelection(o2, { direction: e2 ? "forward" : "backward" });
            const r2 = e2 ? o2.focus.nodeBefore : o2.focus.nodeAfter;
            return r2 && i2.isObject(r2);
          }
          _findTextRangeFromSelection(t2, e2, n2) {
            const i2 = this.editor.model;
            if (n2) {
              const n3 = e2.getLastPosition(), o2 = this._getNearestVisibleTextPosition(t2, "backward");
              return o2 && n3.isBefore(o2) ? i2.createRange(n3, o2) : null;
            }
            {
              const n3 = e2.getFirstPosition(), o2 = this._getNearestVisibleTextPosition(t2, "forward");
              return o2 && n3.isAfter(o2) ? i2.createRange(o2, n3) : null;
            }
          }
          _getNearestVisibleTextPosition(t2, e2) {
            const n2 = this.editor.model.schema, i2 = this.editor.editing.mapper;
            for (const { nextPosition: o2, item: r2 } of t2.getWalker({ direction: e2 }))
              if (n2.checkChild(o2, "$text")) {
                const t3 = i2.toViewElement(r2);
                if (t3 && !t3.hasClass("ck-hidden"))
                  return o2;
              }
          }
          _isSingleLineRange(t2, e2) {
            const n2 = this.editor.model, i2 = this.editor.editing, o2 = i2.view.domConverter;
            if (e2) {
              const e3 = n2.createSelection(t2.start);
              n2.modifySelection(e3), e3.focus.isAtEnd || t2.start.isEqual(e3.focus) || (t2 = n2.createRange(e3.focus, t2.end));
            }
            const r2 = i2.mapper.toViewRange(t2), s2 = o2.viewRangeToDom(r2), a2 = Zr.getDomRangeRects(s2);
            let c2;
            for (const t3 of a2)
              if (void 0 !== c2) {
                if (Math.round(t3.top) >= c2)
                  return false;
                c2 = Math.max(c2, Math.round(t3.bottom));
              } else
                c2 = Math.round(t3.bottom);
            return true;
          }
          _navigateFromCellInDirection(t2, e2) {
            const n2 = this.editor.model, i2 = lg("table", t2), o2 = [...new pg(i2, { includeSpanned: true })], { row: r2, column: s2 } = o2[o2.length - 1], a2 = o2.find(({ cell: e3 }) => e3 == t2);
            let { row: c2, column: l2 } = a2;
            switch (e2) {
              case "left":
                l2--;
                break;
              case "up":
                c2--;
                break;
              case "right":
                l2 += a2.colspan;
                break;
              case "down":
                c2 += a2.rowspan;
            }
            if (c2 < 0 || c2 > r2 || l2 < 0 && c2 <= 0 || l2 > s2 && c2 >= r2)
              return void n2.change((t3) => {
                t3.setSelection(t3.createRangeOn(i2));
              });
            l2 < 0 ? (l2 = s2, c2--) : l2 > s2 && (l2 = 0, c2++);
            const d2 = o2.find((t3) => t3.row == c2 && t3.column == l2).cell, u2 = ["right", "down"].includes(e2), h2 = n2.createPositionAt(d2, u2 ? 0 : "end");
            n2.change((t3) => {
              t3.setSelection(h2);
            });
          }
        }
        n(92);
        class Dp {
          constructor(t2, e2) {
            this.model = t2, this.testCallback = e2, this.hasMatch = false, this.set("isEnabled", true), this.on("change:isEnabled", () => {
              this.isEnabled ? this._startListening() : (this.stopListening(t2.document.selection), this.stopListening(t2.document));
            }), this._startListening();
          }
          _startListening() {
            const t2 = this.model.document;
            this.listenTo(t2.selection, "change:range", (e2, { directChange: n2 }) => {
              n2 && (t2.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this.hasMatch = false));
            }), this.listenTo(t2, "change:data", (t3, e2) => {
              "transparent" != e2.type && this._evaluateTextBeforeSelection("data", { batch: e2 });
            });
          }
          _evaluateTextBeforeSelection(t2, e2 = {}) {
            const n2 = this.model, i2 = n2.document.selection, o2 = n2.createRange(n2.createPositionAt(i2.focus.parent, 0), i2.focus), { text: r2, range: s2 } = ru(o2, n2), a2 = this.testCallback(r2);
            if (!a2 && this.hasMatch && this.fire("unmatched"), this.hasMatch = !!a2, a2) {
              const n3 = Object.assign(e2, { text: r2, range: s2 });
              "object" == typeof a2 && Object.assign(n3, a2), this.fire("matched:" + t2, n3);
            }
          }
        }
        xn(Dp, Ui);
        var Lp = /[\\^$.*+?()[\]{}|]/g, jp = RegExp(Lp.source);
        var Vp = function(t2) {
          return (t2 = Zn(t2)) && jp.test(t2) ? t2.replace(Lp, "\\$&") : t2;
        };
        const zp = { copyright: { from: "(c)", to: "\xA9" }, registeredTrademark: { from: "(r)", to: "\xAE" }, trademark: { from: "(tm)", to: "\u2122" }, oneHalf: { from: "1/2", to: "\xBD" }, oneThird: { from: "1/3", to: "\u2153" }, twoThirds: { from: "2/3", to: "\u2154" }, oneForth: { from: "1/4", to: "\xBC" }, threeQuarters: { from: "3/4", to: "\xBE" }, lessThanOrEqual: { from: "<=", to: "\u2264" }, greaterThanOrEqual: { from: ">=", to: "\u2265" }, notEqual: { from: "!=", to: "\u2260" }, arrowLeft: { from: "<-", to: "\u2190" }, arrowRight: { from: "->", to: "\u2192" }, horizontalEllipsis: { from: "...", to: "\u2026" }, enDash: { from: /(^| )(--)( )$/, to: [null, "\u2013", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "\u2014", null] }, quotesPrimary: { from: Wp('"'), to: [null, "\u201C", null, "\u201D"] }, quotesSecondary: { from: Wp("'"), to: [null, "\u2018", null, "\u2019"] }, quotesPrimaryEnGb: { from: Wp("'"), to: [null, "\u2018", null, "\u2019"] }, quotesSecondaryEnGb: { from: Wp('"'), to: [null, "\u201C", null, "\u201D"] }, quotesPrimaryPl: { from: Wp('"'), to: [null, "\u201E", null, "\u201D"] }, quotesSecondaryPl: { from: Wp("'"), to: [null, "\u201A", null, "\u2019"] } }, Bp = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, Fp = ["symbols", "mathematical", "typography", "quotes"];
        function Up(t2) {
          return "string" == typeof t2 ? new RegExp(`(${Vp(t2)})$`) : t2;
        }
        function Hp(t2) {
          return "string" == typeof t2 ? () => [t2] : t2 instanceof Array ? () => t2 : t2;
        }
        function qp(t2) {
          return (t2.textNode ? t2.textNode : t2.nodeAfter).getAttributes();
        }
        function Wp(t2) {
          return new RegExp(`(^|\\s)(${t2})([^${t2}]*)(${t2})$`);
        }
        class Yp extends Gl {
        }
        Yp.builtinPlugins = [class extends $l {
          static get requires() {
            return [Xl, sd, gd, dd, Md, Qd];
          }
          static get pluginName() {
            return "Essentials";
          }
        }, nu, class extends $l {
          static get pluginName() {
            return "Autoformat";
          }
          afterInit() {
            this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats();
          }
          _addListAutoformats() {
            const t2 = this.editor.commands;
            t2.get("bulletedList") && new ou(this.editor, /^[*-]\s$/, "bulletedList"), t2.get("numberedList") && new ou(this.editor, /^1[.|)]\s$/, "numberedList");
          }
          _addBasicStylesAutoformats() {
            const t2 = this.editor.commands;
            if (t2.get("bold")) {
              const t3 = cu(this.editor, "bold");
              new su(this.editor, /(\*\*)([^*]+)(\*\*)$/g, t3), new su(this.editor, /(__)([^_]+)(__)$/g, t3);
            }
            if (t2.get("italic")) {
              const t3 = cu(this.editor, "italic");
              new su(this.editor, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, t3), new su(this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, t3);
            }
            if (t2.get("code")) {
              const t3 = cu(this.editor, "code");
              new su(this.editor, /(`)([^`]+)(`)$/g, t3);
            }
            if (t2.get("strikethrough")) {
              const t3 = cu(this.editor, "strikethrough");
              new su(this.editor, /(~~)([^~]+)(~~)$/g, t3);
            }
          }
          _addHeadingAutoformats() {
            const t2 = this.editor.commands.get("heading");
            t2 && t2.modelElements.filter((t3) => t3.match(/^heading[1-6]$/)).forEach((e2) => {
              const n2 = e2[7], i2 = new RegExp(`^(#{${n2}})\\s$`);
              new ou(this.editor, i2, () => {
                if (!t2.isEnabled)
                  return false;
                this.editor.execute("heading", { value: e2 });
              });
            });
          }
          _addBlockQuoteAutoformats() {
            this.editor.commands.get("blockQuote") && new ou(this.editor, /^>\s$/, "blockQuote");
          }
          _addCodeBlockAutoformats() {
            this.editor.commands.get("codeBlock") && new ou(this.editor, /^```$/, "codeBlock");
          }
        }, class extends $l {
          static get requires() {
            return [du, uu];
          }
          static get pluginName() {
            return "Bold";
          }
        }, class extends $l {
          static get requires() {
            return [hu, fu];
          }
          static get pluginName() {
            return "Italic";
          }
        }, class extends $l {
          static get requires() {
            return [ku, _u];
          }
          static get pluginName() {
            return "BlockQuote";
          }
        }, class extends $l {
          static get pluginName() {
            return "CKFinder";
          }
          static get requires() {
            return [Ch, vu, nu];
          }
        }, class extends $l {
          static get requires() {
            return [Oh, af, xf];
          }
          static get pluginName() {
            return "EasyImage";
          }
        }, class extends $l {
          static get requires() {
            return [If, Of];
          }
          static get pluginName() {
            return "Heading";
          }
        }, af, class extends $l {
          static get requires() {
            return [Lf];
          }
          static get pluginName() {
            return "ImageCaption";
          }
        }, class extends $l {
          static get requires() {
            return [Jf, Zf];
          }
          static get pluginName() {
            return "ImageStyle";
          }
        }, class extends $l {
          static get requires() {
            return [Xf];
          }
          static get pluginName() {
            return "ImageToolbar";
          }
          afterInit() {
            const t2 = this.editor, e2 = t2.t;
            t2.plugins.get(Xf).register("image", { ariaLabel: e2("Image toolbar"), items: t2.config.get("image.toolbar") || [], getRelatedElement: Ou });
          }
        }, xf, class extends $l {
          static get pluginName() {
            return "Indent";
          }
          static get requires() {
            return [im, sm];
          }
        }, class extends $l {
          static get requires() {
            return [yh, dm];
          }
          static get pluginName() {
            return "Link";
          }
        }, class extends $l {
          static get requires() {
            return [Lm, Vm];
          }
          static get pluginName() {
            return "List";
          }
        }, class extends $l {
          static get requires() {
            return [Gm, Jm, Qm, Lh];
          }
          static get pluginName() {
            return "MediaEmbed";
          }
        }, Cf, class extends $l {
          static get pluginName() {
            return "PasteFromOffice";
          }
          static get requires() {
            return [Xl];
          }
          init() {
            const t2 = this.editor, e2 = [];
            e2.push(new cg()), e2.push(new ng(t2.editing.view.document)), t2.plugins.get("Clipboard").on("inputTransformation", (t3, n2) => {
              if (n2.isTransformedWithPasteFromOffice)
                return;
              const i2 = n2.dataTransfer.getData("text/html"), o2 = e2.find((t4) => t4.isActive(i2));
              o2 && (o2.execute(n2), n2.isTransformedWithPasteFromOffice = true);
            }, { priority: "high" });
          }
        }, class extends $l {
          static get requires() {
            return [xp, Pp, Ip, Op, Rp, Lh];
          }
          static get pluginName() {
            return "Table";
          }
        }, class extends $l {
          static get requires() {
            return [Xf];
          }
          static get pluginName() {
            return "TableToolbar";
          }
          afterInit() {
            const t2 = this.editor, e2 = t2.t, n2 = t2.plugins.get(Xf), i2 = t2.config.get("table.contentToolbar"), o2 = t2.config.get("table.tableToolbar");
            i2 && n2.register("tableContent", { ariaLabel: e2("Table toolbar"), items: i2, getRelatedElement: kg }), o2 && n2.register("table", { ariaLabel: e2("Table toolbar"), items: o2, getRelatedElement: wg });
          }
        }, class extends $l {
          static get pluginName() {
            return "TextTransformation";
          }
          constructor(t2) {
            super(t2), t2.config.define("typing", { transformations: { include: Fp } });
          }
          init() {
            const t2 = this.editor.model.document.selection;
            t2.on("change:range", () => {
              this.isEnabled = !t2.anchor.parent.is("codeBlock");
            }), this._enableTransformationWatchers();
          }
          _enableTransformationWatchers() {
            const t2 = this.editor, e2 = t2.model, n2 = t2.plugins.get("Input"), i2 = function(t3) {
              const e3 = t3.extra || [], n3 = t3.remove || [], i3 = (t4) => !n3.includes(t4);
              return function(t4) {
                const e4 = /* @__PURE__ */ new Set();
                for (const n4 of t4)
                  if (Bp[n4])
                    for (const t5 of Bp[n4])
                      e4.add(t5);
                  else
                    e4.add(n4);
                return Array.from(e4);
              }(t3.include.concat(e3).filter(i3)).filter(i3).map((t4) => zp[t4] || t4).map((t4) => ({ from: Up(t4.from), to: Hp(t4.to) }));
            }(t2.config.get("typing.transformations")), o2 = new Dp(t2.model, (t3) => {
              for (const e3 of i2) {
                if (e3.from.test(t3))
                  return { normalizedTransformation: e3 };
              }
            });
            o2.on("matched:data", (t3, i3) => {
              if (!n2.isInput(i3.batch))
                return;
              const { from: o3, to: r2 } = i3.normalizedTransformation, s2 = o3.exec(i3.text), a2 = r2(s2.slice(1)), c2 = i3.range;
              let l2 = s2.index;
              e2.enqueueChange((t4) => {
                for (let n3 = 1; n3 < s2.length; n3++) {
                  const i4 = s2[n3], o4 = a2[n3 - 1];
                  if (null == o4) {
                    l2 += i4.length;
                    continue;
                  }
                  const r3 = c2.start.getShiftedBy(l2), d2 = e2.createRange(r3, r3.getShiftedBy(i4.length)), u2 = qp(r3);
                  e2.insertContent(t4.createText(o4, u2), d2), l2 += o4.length;
                }
              });
            }), o2.bind("isEnabled").to(this);
          }
        }], Yp.defaultConfig = { toolbar: { items: ["heading", "|", "bold", "italic", "link", "bulletedList", "numberedList", "|", "indent", "outdent", "|", "imageUpload", "blockQuote", "insertTable", "mediaEmbed", "undo", "redo"] }, image: { toolbar: ["imageStyle:full", "imageStyle:side", "|", "imageTextAlternative"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, language: "en" };
      }]).default;
    });
  }
});
export default require_ckeditor();
/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
//# sourceMappingURL=@ckeditor_ckeditor5-build-classic.js.map
